<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mogul P2P Sync</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.10/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <style>
        :root {
            font-family: 'Inter', sans-serif;
            /* Corporate Theme (Light) wird als Standard genutzt */
            --theme-bg: oklch(100% 0 0);
            --theme-text: oklch(0% 0 0);
        }
        html[data-theme="corporate"] {
            --theme-bg: oklch(100% 0 0);
            --theme-text: oklch(0% 0 0);
        }

        /* --- Minimales CSS f√ºr Drag & Drop und Cursor --- */
        .task-card {
            cursor: pointer;
            user-select: none;
            transition: box-shadow 0.15s, outline 0.15s, transform 0.15s; 
            border: 2px solid transparent; 
        }
        .task-card[draggable="true"] { cursor: grab; }
        .task-card:hover { box-shadow: 0 4px 10px -1px rgba(0, 0, 0, 0.1); }
        
        .task-card.selected {
            border-color: transparent; 
            outline: 4px solid oklch(var(--p)); /* Prim√§rfarbe */
            outline-offset: 2px;
            box-shadow: 0 10px 24px 0 rgba(0, 0, 0, 0.4);
            transform: translateY(-5px);
            animation: selected-pulse 2s infinite ease-in-out;
        }
        .task-card.selected:hover {
            box-shadow: 0 15px 35px 0 rgba(0, 0, 0, 0.5);
            transform: translateY(-7px);
        }

        @keyframes selected-pulse {
            0% { box-shadow: 0 10px 24px 0 rgba(0, 0, 0, 0.4); outline-color: oklch(var(--p) / 0.8); }
            50% { box-shadow: 0 12px 28px 0 rgba(0, 0, 0, 0.5); outline-color: oklch(var(--p)); }
            100% { box-shadow: 0 10px 24px 0 rgba(0, 0, 0, 0.4); outline-color: oklch(var(--p) / 0.8); }
        }

        .dragging { opacity: 0.3; }
        .drag-over-active { box-shadow: 0 0 0 3px oklch(var(--b3)) inset; } /* base-300 */
        .task-card.drop-target-before { border-top: 4px solid oklch(var(--p)) !important; margin-top: 0px !important; }
        
        .completed .task-title,
        .completed .task-details { text-decoration: line-through; opacity: 0.5; }
        
        @media (min-width: 1024px) { .kanban-column { min-height: 500px; } }
        
        .svg-icon { width: 1.25rem; height: 1.25rem; stroke: currentColor; stroke-width: 2; fill: none; }
    </style>
</head>
<body class="bg-base-100 min-h-screen" data-theme="corporate">

    <div class="navbar bg-base-100 text-base-content border-b border-base-200 shadow-sm sticky top-0 z-50">
        <div class="flex-1 px-2 mx-2">
            <span class="text-2xl font-extrabold text-primary">Mogul</span>
        </div>
        <div class="flex-none flex items-center gap-4 text-xs">
            
            <div id="sync-status-indicator" class="tooltip tooltip-bottom" data-tip="Initialisierung...">
                <span id="sync-status-text" class="font-bold text-warning uppercase">INIT...</span>
            </div>

            <button id="import-gsf-btn" class="btn btn-sm btn-info rounded-lg" title="Global Status File (GSF) importieren, um PULL zu starten.">Import GSF</button>
            <button id="export-gsf-btn" class="btn btn-sm btn-success rounded-lg hidden" title="Aktuellen Chef-Status (GSF) exportieren (PUSH).">Export GSF</button>
            <button id="manage-devices-btn" class="btn btn-sm btn-ghost rounded-lg" title="Ger√§te verwalten (Max 4).">
                <svg xmlns="http://www.w3.org/2000/svg" class="svg-icon" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 1.5H8.25A2.25 2.25 0 0 0 6 3.75v16.5a2.25 2.25 0 0 0 2.25 2.25h7.5A2.25 2.25 0 0 0 18 20.25V3.75a2.25 2.25 0 0 0-2.25-2.25H13.5m-3 0V3h3V1.5m-3 0h3m-3 18.75h3" /></svg>
            </button>
            <button id="p2p-modal-btn" class="btn btn-sm btn-ghost rounded-lg" title="P2P-Verbindung manuell starten (f√ºr Daten-PULL).">
                <svg xmlns="http://www.w3.org/2000/svg" class="svg-icon" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M7.5 21 3 16.5m0 0L7.5 12M3 16.5h13.5m0-13.5L21 7.5m0 0L16.5 12M21 7.5H7.5" /></svg>
            </button>
            
            <button id="edit-selected-btn" class="btn btn-primary btn-md rounded-lg shadow-md hover:shadow-lg hidden" title="Ausgew√§hlte Aufgabe bearbeiten (Doppelklick)">
                <svg xmlns="http://www.w3.org/2000/svg" class="svg-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 17.21a4.5 4.5 0 0 1-1.897 1.13L6 18.24l.842-2.793a4.5 4.5 0 0 1 1.13-1.897l8.243-8.243Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 14.25H2.25" /></svg>
            </button>
            <button id="delete-selected-btn" class="btn btn-error btn-md rounded-lg shadow-md hover:shadow-lg hidden" title="Ausgew√§hlte Aufgaben l√∂schen (Entf)">
                <svg xmlns="http://www.w3.org/2000/svg" class="svg-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
                <span id="delete-count-badge" class="font-bold"></span>
            </button>
            <button id="add-task-btn" class="btn btn-primary btn-md rounded-lg shadow-md hover:shadow-lg">
                <svg xmlns="http://www.w3.org/2000/svg" class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M5 12h14m-7-7v14"/></svg>
                Neue Aufgabe
            </button>
        </div>
    </div>

    <main class="kanban-board grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 px-4 sm:px-8 lg:px-10 py-8 lg:py-10" id="kanban-board">
        <div class="kanban-column bg-base-200 flex flex-col p-4 rounded-xl shadow-md" data-bucket="open">
            <h2 class="text-lg font-bold mb-4 text-base-content flex justify-between items-center pb-2 border-b border-base-300">
                Offen
                <span id="count-open" class="badge badge-lg badge-primary badge-ghost font-normal">0</span>
            </h2>
            <div class="task-list flex flex-col gap-3 flex-grow pt-2" id="bucket-open"></div>
        </div>
        <div class="kanban-column bg-base-200 flex flex-col p-4 rounded-xl shadow-md" data-bucket="in_progress">
            <h2 class="text-lg font-bold mb-4 text-base-content flex justify-between items-center pb-2 border-b border-base-300">
                In Arbeit
                <span id="count-in_progress" class="badge badge-lg badge-warning badge-ghost font-normal">0</span>
            </h2>
            <div class="task-list flex flex-col gap-3 flex-grow pt-2" id="bucket-in_progress"></div>
        </div>
        <div class="kanban-column bg-base-200 flex flex-col p-4 rounded-xl shadow-md" data-bucket="done">
            <h2 class="text-lg font-bold mb-4 text-base-content flex justify-between items-center pb-2 border-b border-base-300">
                Erledigt
                <span id="count-done" class="badge badge-lg badge-success badge-ghost font-normal">0</span>
            </h2>
            <div class="task-list flex flex-col gap-3 flex-grow pt-2" id="bucket-done"></div>
        </div>
    </main>
    
    <dialog id="task_modal" class="modal">
        <div class="modal-box w-11/12 max-w-2xl bg-base-100 shadow-2xl rounded-xl">
            <h3 class="font-bold text-xl mb-4 border-b pb-2" id="modal-title-text">Aufgabe bearbeiten</h3>
            <form id="task-detail-form" method="dialog">
                <input type="hidden" id="task-id-input">
                <div class="form-control mb-4">
                    <label class="label"><span class="label-text font-semibold">Titel</span></label>
                    <input type="text" id="task-title-input" required class="input input-bordered w-full rounded-md bg-base-200 text-base-content border-base-300">
                </div>
                <div class="flex flex-col md:flex-row gap-4 mb-6">
                    <div class="form-control flex-1">
                        <label class="label"><span class="label-text font-semibold">Startdatum</span></label>
                        <input type="date" id="task-start-date-input" class="input input-bordered w-full rounded-md bg-base-200 text-base-content border-base-300">
                    </div>
                    <div class="form-control flex-1">
                        <label class="label"><span class="label-text font-semibold">F√§lligkeitsdatum (Optional)</span></label>
                        <input type="date" id="task-due-date-input" class="input input-bordered w-full rounded-md bg-base-200 text-base-content border-base-300">
                    </div>
                </div>
                <div class="form-control mb-4">
                    <label class="label"><span class="label-text font-semibold">Beschreibung/Details (Plain Text)</span></label>
                    <textarea id="task-details-input" class="textarea textarea-bordered h-36 w-full rounded-md bg-base-200 text-base-content border-base-300"></textarea>
                </div>
                <div class="modal-action border-t pt-4 border-base-300">
                    <button type="button" id="delete-task-btn" class="btn btn-error btn-outline mr-auto rounded-lg">L√∂schen</button>
                    <button type="submit" class="btn btn-primary rounded-lg" id="save-task-btn">Speichern</button>
                    <button type="button" class="btn rounded-lg" onclick="task_modal.close()">Schlie√üen</button>
                </div>
            </form>
        </div>
    </dialog>

    <dialog id="confirm_delete_modal" class="modal">
        <div class="modal-box bg-base-100 shadow-2xl rounded-xl">
            <h3 class="font-bold text-lg text-error">‚ö†Ô∏é Aufgabe(n) unwiderruflich l√∂schen?</h3>
            <p class="py-4">Sind Sie sicher, dass Sie <span id="tasks-to-delete-count" class="font-bold text-base-content">diese Aufgabe</span> l√∂schen m√∂chten? Dieser Vorgang kann nicht r√ºckg√§ngig gemacht werden.</p>
            <div class="modal-action border-t pt-4 border-base-300">
                <button type="button" class="btn rounded-lg" onclick="confirm_delete_modal.close()">Abbrechen</button>
                <button type="button" class="btn btn-error rounded-lg" id="confirm-delete-btn">Ja, l√∂schen</button>
            </div>
        </div>
    </dialog>

    <dialog id="auth_modal" class="modal modal-open"> <div class="modal-box w-96 bg-base-100 shadow-2xl rounded-xl">
            <h3 id="auth-title" class="font-bold text-lg">üîí Mogul P2P-Authentifizierung</h3>
            <div id="auth-loading" class="py-4 text-center hidden">
                <span class="loading loading-dots loading-lg"></span>
                <p>Initialisiere Sicherheit...</p>
            </div>
            
            <div id="auth-register-view" class="py-4 hidden">
                <p class="mb-4">Willkommen! Dies scheint Ihr erstes Ger√§t zu sein. Bitte registrieren Sie einen Passkey (Face ID, Touch ID, PIN), um Ihren Account zu erstellen und die Verschl√ºsselung zu starten.</p>
                <div class="modal-action">
                    <button id="register-passkey-btn" class="btn btn-primary rounded-lg w-full">Account mit Passkey erstellen</button>
                </div>
            </div>
            
            <div id="auth-login-view" class="py-4 hidden">
                <p class="mb-4">Bitte melden Sie sich mit Ihrem Passkey (Face ID, Touch ID, PIN) an, um die Sitzung zu entschl√ºsseln und zu starten.</p>
                <div class="modal-action">
                    <button id="login-passkey-btn" class="btn btn-primary rounded-lg w-full">Mit Passkey anmelden</button>
                </div>
            </div>
        </div>
    </dialog>

    <dialog id="manage_devices_modal" class="modal">
        <div class="modal-box w-11/12 max-w-2xl bg-base-100 shadow-2xl rounded-xl">
            <h3 class="font-bold text-lg">üì± Ger√§teverwaltung (Max 4)</h3>
            <p class="py-2 text-sm">Dies ist die Liste der autorisierten Ger√§te. Nur Ger√§te auf dieser Liste k√∂nnen Daten synchronisieren.</p>
            
            <div class="form-control mb-4">
                <label class="label"><span class="label-text">Eigene Ger√§te-ID (F√ºr Aktivierung)</span></label>
                <input type="text" id="current-device-id-display" class="input input-bordered w-full rounded-md bg-base-200" readonly title="Geben Sie diese ID auf einem Chef-Ger√§t ein, um dieses Ger√§t zu aktivieren.">
            </div>

            <div class="font-semibold mb-2">Autorisierte Ger√§te:</div>
            <div id="device-list-container" class="flex flex-col gap-2 p-2 bg-base-200 rounded-lg min-h-24">
                </div>

            <div id="device-activation-section" class="mt-4 pt-4 border-t border-base-300">
                <h4 class="font-semibold text-primary">Neues Ger√§t aktivieren</h4>
                <div class="form-control mt-2">
                    <label class="label"><span class="label-text">Ger√§te-ID des neuen Ger√§ts</span></label>
                    <div class="flex gap-2">
                        <input type="text" id="new-device-id-input" class="input input-bordered w-full rounded-md bg-base-200" placeholder="ID von neuem Ger√§t hier einf√ºgen">
                        <button id="add-device-btn" class="btn btn-success rounded-lg">Aktivieren</Dbutton>
                    </div>
                </div>
            </div>

            <div class="modal-action border-t pt-4 border-base-300 mt-6">
                <button type="button" class="btn rounded-lg" onclick="manage_devices_modal.close()">Schlie√üen</button>
            </div>
        </div>
    </dialog>

    <dialog id="p2p_modal" class="modal">
        <div class="modal-box w-11/12 max-w-2xl bg-base-100 shadow-2xl rounded-xl">
            <h3 class="font-bold text-lg">üîÑ P2P Daten-PULL</h3>
            <p class="py-2 text-sm">Um Daten zu empfangen (PULL), starten Sie hier und senden Sie den Code an das Chef-Ger√§t. F√ºgen Sie dann die Antwort des Chefs hier ein.</p>

            <div id="p2p-status" class="text-info font-semibold my-2">Status: Getrennt</div>

            <div class="tabs tabs-lifted">
                <input type="radio" name="p2p-tabs" role="tab" class="tab" aria-label="1. Angebot (Offer) senden" id="tab-offer" checked />
                <div role="tabpanel" class="tab-content bg-base-200 border-base-300 rounded-box p-4">
                    <p class="text-xs mb-2">Starten Sie hier, wenn Sie Daten PULLEN (empfangen) m√∂chten. Kopieren Sie diesen Code und f√ºgen Sie ihn auf dem Chef-Ger√§t ein.</p>
                    <textarea id="p2p-offer-output" class="textarea textarea-bordered w-full h-24 rounded-md" readonly placeholder="Klicken Sie auf 'PULL starten', um Code zu generieren..."></textarea>
                </div>

                <input type="radio" name="p2p-tabs" role="tab" class="tab" aria-label="2. Antwort (Answer) importieren" id="tab-answer" />
                <div role="tabpanel" class="tab-content bg-base-200 border-base-300 rounded-box p-4">
                    <p class="text-xs mb-2">F√ºgen Sie den Antwort-Code (den Sie vom Chef-Ger√§t erhalten haben) hier ein, um die Verbindung herzustellen.</p>
                    <textarea id="p2p-answer-input" class="textarea textarea-bordered w-full h-24 rounded-md" placeholder="Antwort-Code vom Chef-Ger√§t hier einf√ºgen..."></textarea>
                </div>
            </div>

            <div class="modal-action border-t pt-4 border-base-300 mt-6">
                <button type="button" class="btn rounded-lg" onclick="p2p_modal.close()">Abbrechen</button>
                <button type="button" class="btn btn-primary rounded-lg" id="p2p-start-pull-btn">PULL starten</button>
            </div>
        </div>
    </dialog>

    <script>
    // === 1. MOGUL KERN-LOGIK (BASIS-APP) ===
    // Diese Funktionen definieren die UI-Logik (Drag & Drop, Modals, CRUD)
    // Sie sind von der P2P/Crypto-Logik entkoppelt.
    // -----------------------------------------------------------------

    // --- 1.1 Globale Variablen (Mogul UI) ---
    const STORAGE_KEY = 'mogul_tasks_local_cache'; // Nur noch Cache, Wahrheit ist in IndexedDB
    const BUCKETS = ['open', 'in_progress', 'done'];
    let tasks = []; // Lokaler In-Memory-Zustand (Cache)
    
    let selectedTaskIds = new Set();
    let lastSelectedId = null;
    let isDragging = false;
    let draggedTaskId = null;
    let currentDropTargetCard = null; // F√ºr CSS Drop-Indikator

    // --- 1.2 Undo/Redo Logik ---
    let history = [];
    let historyIndex = -1;
    const MAX_HISTORY = 50;

    const takeSnapshot = () => {
        history = history.slice(0, historyIndex + 1);
        const currentTasksJSON = JSON.stringify(tasks);
        if (historyIndex >= 0 && history[historyIndex] === currentTasksJSON) {
            return;
        }
        history.push(currentTasksJSON);
        historyIndex = history.length - 1;
        if (history.length > MAX_HISTORY) {
            history.shift();
            historyIndex--;
        }
    };

    const undo = () => {
        if (historyIndex > 0) {
            historyIndex--;
            tasks = JSON.parse(history[historyIndex]);
            renderTasks();
        }
    };

    const redo = () => {
        if (historyIndex < history.length - 1) {
            historyIndex++;
            tasks = JSON.parse(history[historyIndex]);
            renderTasks();
        }
    };

    // --- 1.3 State Management (Laden/Speichern) ---
    const loadState = () => {
        try {
            const json = localStorage.getItem(STORAGE_KEY);
            if (json) {
                const loadedData = JSON.parse(json);
                // Validiere, ob es das neue Datenformat ist
                if (loadedData.appData && Array.isArray(loadedData.appData.tasks)) {
                    tasks = loadedData.appData.tasks.map(ensureTaskFormat);
                    p2pDataStore = loadedData; // Lade den gesamten P2P-Datenspeicher
                } 
                // Fallback f√ºr altes Format (nur Task-Array)
                else if (Array.isArray(loadedData)) {
                    tasks = loadedData.map(ensureTaskFormat);
                    p2pDataStore = { app: GSF_APP_ID, lastModified: Date.now(), appData: { tasks, deviceRegistry: { ids: [currentDeviceId], names: { [currentDeviceId]: "Default Device" } } } };
                }
                else {
                    tasks = getDefaultTasks();
                    p2pDataStore = { app: GSF_APP_ID, lastModified: Date.now(), appData: { tasks, deviceRegistry: { ids: [currentDeviceId], names: { [currentDeviceId]: "Default Device" } } } };
                }
            } else {
                tasks = getDefaultTasks();
                p2pDataStore = { app: GSF_APP_ID, lastModified: Date.now(), appData: { tasks, deviceRegistry: { ids: [currentDeviceId], names: { [currentDeviceId]: "Default Device" } } } };
            }
        } catch (e) {
            console.error('Fehler beim Laden des Zustands:', e);
            tasks = getDefaultTasks();
            p2pDataStore = { app: GSF_APP_ID, lastModified: Date.now(), appData: { tasks, deviceRegistry: { ids: [currentDeviceId], names: { [currentDeviceId]: "Default Device" } } } };
        }
        takeSnapshot(); // Ersten Snapshot nach dem Laden erstellen
    };
    
    // WICHTIG: saveState() wird nun von der P2P-Logik (p2pSaveState) gesteuert.
    // Diese Funktion hier ist nur der lokale Cache-Speicher.
    const saveStateToLocalStorage = (dataToSave) => {
         try {
            // Speichere das gesamte P2P-Datenobjekt (inkl. Registry)
            localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
        } catch (e) {
            console.error('Fehler beim Speichern des Zustands im Cache:', e);
        }
    };


    // --- 1.4 Hilfsfunktionen (Formatierung, Defaults) ---
    
    const ensureTaskFormat = (t) => ({
        ...t,
        id: t.id || Date.now(),
        currentBucketStartTime: t.currentBucketStartTime || Date.now(),
        timeInBucketsMs: t.timeInBucketsMs || { open: 0, in_progress: 0, done: 0 },
        lastDoneTime: t.lastDoneTime || null,
        createdTimeMs: t.createdTimeMs || t.id,
        isDeleted: t.isDeleted || false, // Wichtig f√ºr P2P-Sync
        lastModified: t.lastModified || Date.now() // Wichtig f√ºr P2P-Sync
    });

    const getDefaultTasks = () => {
        const createdTimeMs = Date.now();
        const creationDate = new Date(createdTimeMs).toISOString().split('T')[0];
        return [
            ensureTaskFormat({
                id: createdTimeMs,
                title: 'Mogul P2P-Sync einrichten',
                details: 'Passkey registrieren und erstes Ger√§t als Chef festlegen.',
                bucket: 'open',
                createdDate: creationDate,
                startDate: creationDate,
                dueDate: '',
                completed: false,
            })
        ];
    };

    const getCurrentDateString = () => new Date().toISOString().split('T')[0];

    // --- 1.5 Task Status & Zeitmessung (WICHTIG: Implementiert) ---
    
    function updateTaskStatusAndTiming(task, targetBucket) {
        const now = Date.now();
        const prevBucket = task.bucket;

        if (!task.timeInBucketsMs) task.timeInBucketsMs = { open: 0, in_progress: 0, done: 0 };
        if (!task.currentBucketStartTime) task.currentBucketStartTime = task.createdTimeMs || now;
        
        // Zeit im aktuellen Bucket akkumulieren
        const elapsed = now - task.currentBucketStartTime;
        task.timeInBucketsMs[prevBucket] = (task.timeInBucketsMs[prevBucket] || 0) + elapsed;

        // Statuswechsel
        task.bucket = targetBucket;
        task.currentBucketStartTime = now;
        task.lastModified = now; // Wichtig f√ºr Sync

        if (targetBucket === 'done') {
            task.completed = true;
            task.lastDoneTime = now;
        } else {
            task.completed = false;
        }
        return task; // Gibt das modifizierte Objekt zur√ºck
    }

    const performTaskAction = (taskId, targetBucket) => {
        const task = tasks.find(t => t.id === taskId);
        if (!task || task.bucket === targetBucket) return;
        
        const updatedTask = updateTaskStatusAndTiming(task, targetBucket);
        const index = tasks.findIndex(t => t.id === updatedTask.id);
        if (index > -1) tasks[index] = updatedTask;

        p2pSaveState(); // P2P-Speichern ausl√∂sen
        renderTasks();
    };

    // --- 1.6 Drag & Drop Logik (Vollst√§ndig) ---
    
    const getDragAfterElement = (container, y) => {
        const draggableElements = [...container.querySelectorAll('.task-card:not(.dragging)')];
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    };

    const clearDropIndicator = () => {
        document.querySelectorAll('.task-card.drop-target-before')
            .forEach(c => c.classList.remove('drop-target-before'));
        currentDropTargetCard = null;
    }

    const moveAndSortTask = (draggedTaskId, targetBucket, dropIndex) => {
        const taskIndex = tasks.findIndex(t => t.id === draggedTaskId);
        const draggedTask = tasks[taskIndex];
        if (!draggedTask) return;
        
        tasks.splice(taskIndex, 1); // 1. Entfernen

        // 2. Status/Zeit anpassen, falls Bucket gewechselt
        const bucketChanged = draggedTask.bucket !== targetBucket;
        if (bucketChanged) {
            updateTaskStatusAndTiming(draggedTask, targetBucket);
        } else {
            // Nur Zeitstempel aktualisieren, wenn Sortierung √§ndert
            draggedTask.lastModified = Date.now();
        }

        // 3. Array neu zusammensetzen (korrekte Sortierung)
        const newTasks = [];
        const tasksByBucket = {};
        BUCKETS.forEach(b => tasksByBucket[b] = tasks.filter(t => t.bucket === b));
        
        tasksByBucket[targetBucket].splice(dropIndex, 0, draggedTask); // An Drop-Stelle einf√ºgen

        BUCKETS.forEach(bucket => newTasks.push(...tasksByBucket[bucket]));
        tasks = newTasks; // Globalen State aktualisieren

        // 4. Speichern und Rendern
        p2pSaveState(); // P2P-Speichern ausl√∂sen
        renderTasks();
    };

    const addDragListeners = () => {
        document.querySelectorAll('.task-card').forEach(card => {
            card.addEventListener('dragstart', (e) => {
                const cardEl = e.currentTarget; 
                draggedTaskId = Number(cardEl.dataset.taskId);
                isDragging = true; 
                cardEl.classList.add('dragging');
                e.dataTransfer.setData('text/plain', String(draggedTaskId));
                e.dataTransfer.effectAllowed = 'move';
                clearSelection(); // Auswahl aufheben beim Ziehen
            });

            card.addEventListener('dragend', (e) => {
                e.target.classList.remove('dragging');
                setTimeout(() => { isDragging = false; }, 50); 
                draggedTaskId = null;
                clearDropIndicator();
                document.querySelectorAll('.kanban-column').forEach(col => col.classList.remove('drag-over-active'));
            });
        });

        document.querySelectorAll('.kanban-column').forEach(column => {
            const taskList = column.querySelector('.task-list');

            column.addEventListener('dragover', (e) => {
                e.preventDefault(); 
                e.dataTransfer.dropEffect = 'move';
                column.classList.add('drag-over-active');

                const afterElement = getDragAfterElement(taskList, e.clientY);
                if (afterElement !== currentDropTargetCard) {
                    clearDropIndicator();
                    if (afterElement) {
                        afterElement.classList.add('drop-target-before');
                        currentDropTargetCard = afterElement;
                    } else {
                        currentDropTargetCard = null;
                    }
                }
            });

            column.addEventListener('dragleave', (e) => {
                if (!e.relatedTarget || !column.contains(e.relatedTarget)) {
                    column.classList.remove('drag-over-active');
                    clearDropIndicator();
                }
            });

            column.addEventListener('drop', (e) => {
                e.preventDefault();
                column.classList.remove('drag-over-active');
                clearDropIndicator();
                if (draggedTaskId === null) return;
                
                const targetBucket = column.dataset.bucket;
                let dropIndex = 0;
                const allCardsInBucket = Array.from(taskList.children).filter(el => !el.classList.contains('dragging') && el.classList.contains('task-card'));
                const dropTarget = getDragAfterElement(taskList, e.clientY);

                if (dropTarget) {
                    dropIndex = allCardsInBucket.indexOf(dropTarget);
                } else {
                    dropIndex = allCardsInBucket.length; // Drop am Ende
                }
                
                moveAndSortTask(draggedTaskId, targetBucket, dropIndex);
                draggedTaskId = null;
            });
        });
    };

    // --- 1.7 CRUD Operationen ---
    
    // Verwendet nun Soft-Delete
    const deleteTasks = (taskIds) => {
        let deletedCount = 0;
        tasks = tasks.map(t => {
            if (taskIds.includes(t.id) && !t.isDeleted) {
                t.isDeleted = true;
                t.lastModified = Date.now();
                deletedCount++;
                return t;
            }
            return t;
        });
        
        if (deletedCount > 0) {
            p2pSaveState(); // P2P-Speichern ausl√∂sen
            renderTasks();
        }
        selectedTaskIds.clear();
        updateDeleteSelectedButton();
    };

    const createNewTask = (title) => {
        const newTask = ensureTaskFormat({
            id: Date.now(),
            title: title,
            details: '',
            bucket: 'open',
            createdDate: getCurrentDateString(),
            startDate: getCurrentDateString(),
            dueDate: '',
            completed: false,
        });
        tasks.push(newTask);
        return newTask;
    };
    
    const openTaskModalForNewTask = () => {
        const newTask = createNewTask('Neue Aufgabe');
        p2pSaveState(); // P2P-Speichern ausl√∂sen
        renderTasks();
        openTaskModal(newTask.id); // Modal zum Bearbeiten √∂ffnen
    };

    const openDeleteConfirmModal = (taskId = null, title = null) => {
        const count = selectedTaskIds.size;
        const isBatch = taskId === null && count > 0;
        const idsToDelete = isBatch ? Array.from(selectedTaskIds) : (taskId !== null ? [taskId] : []);

        if (idsToDelete.length === 0) return;

        const deleteCountSpan = document.getElementById('tasks-to-delete-count');
        if (isBatch) {
            deleteCountSpan.textContent = `${count} ausgew√§hlte Aufgaben`;
        } else if (title) {
            deleteCountSpan.textContent = `die Aufgabe "${title}"`;
        } else {
            deleteCountSpan.textContent = `diese Aufgabe`;
        }
        
        document.getElementById('confirm-delete-btn').onclick = () => {
            deleteTasks(idsToDelete);
            confirm_delete_modal.close();
        };
        
        task_modal.close(); 
        confirm_delete_modal.showModal();
    };

    const openTaskModal = (taskId) => {
        clearSelection();
        const task = tasks.find(t => t.id === taskId);
        if (!task) return;

        document.getElementById('modal-title-text').textContent = task.title;
        document.getElementById('task-id-input').value = task.id;
        document.getElementById('task-title-input').value = task.title;
        document.getElementById('task-details-input').value = task.details;
        document.getElementById('task-start-date-input').value = task.startDate;
        document.getElementById('task-due-date-input').value = task.dueDate;
        
        document.getElementById('delete-task-btn').onclick = () => {
            openDeleteConfirmModal(task.id, task.title);
        };

        task_modal.showModal();
    };

    // --- 1.8 Multi-Select Logik ---
    
    const handleTaskSelection = (taskId, isCtrlCmd, isShift) => {
        const card = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
        const isCurrentlySelected = selectedTaskIds.has(taskId);
        if (!card) return;

        if (isShift && lastSelectedId !== null) {
            const taskIdsInOrder = Array.from(document.querySelectorAll('.task-card')).map(el => Number(el.dataset.taskId));
            const startIndex = taskIdsInOrder.indexOf(lastSelectedId);
            const endIndex = taskIdsInOrder.indexOf(taskId);
            if (startIndex === -1 || endIndex === -1) return;

            clearSelection(false); // Visuell bereinigen, aber Button noch nicht updaten

            const [start, end] = startIndex < endIndex ? [startIndex, endIndex] : [endIndex, startIndex];
            for (let i = start; i <= end; i++) {
                const currentId = taskIdsInOrder[i];
                selectedTaskIds.add(currentId);
                document.querySelector(`.task-card[data-task-id="${currentId}"]`)?.classList.add('selected');
            }
        } else if (isCtrlCmd) {
            if (isCurrentlySelected) {
                selectedTaskIds.delete(taskId);
                card.classList.remove('selected');
            } else {
                selectedTaskIds.add(taskId);
                card.classList.add('selected');
            }
            lastSelectedId = taskId; 
        } else {
            if (selectedTaskIds.size > 1 || !isCurrentlySelected) {
                clearSelection(false); // Visuell bereinigen
                selectedTaskIds.add(taskId);
                card.classList.add('selected');
            }
            lastSelectedId = taskId;
        }
        
        updateDeleteSelectedButton();
    };

    const updateDeleteSelectedButton = () => {
        const count = selectedTaskIds.size;
        const deleteBtn = document.getElementById('delete-selected-btn');
        const countBadge = document.getElementById('delete-count-badge');
        const editBtn = document.getElementById('edit-selected-btn');

        if (count > 0) {
            deleteBtn.classList.remove('hidden');
            countBadge.textContent = count;
            deleteBtn.title = `Ausgew√§hlte (${count}) Aufgaben l√∂schen (Entf)`;
        } else {
            deleteBtn.classList.add('hidden');
        }
        if (count === 1) {
            editBtn.classList.remove('hidden');
        } else {
            editBtn.classList.add('hidden');
        }
    };

    const clearSelection = (updateButton = true) => {
        if (selectedTaskIds.size > 0) {
            document.querySelectorAll('.task-card.selected').forEach(c => c.classList.remove('selected'));
            selectedTaskIds.clear();
            lastSelectedId = null;
            if (updateButton) updateDeleteSelectedButton();
        }
    };

    // --- 1.9 Render-Funktion (Haupt-Renderer) ---
    const renderTasks = () => {
        const counts = { open: 0, in_progress: 0, done: 0 };
        const activeTasks = tasks.filter(t => !t.isDeleted); // Nur nicht gel√∂schte anzeigen
        BUCKETS.forEach(bucket => {
            const container = document.getElementById(`bucket-${bucket}`);
            container.innerHTML = '';
            const bucketTasks = activeTasks.filter(t => t.bucket === bucket);
            bucketTasks.forEach(task => {
                container.appendChild(createTaskCard(task));
            });
            counts[bucket] = bucketTasks.length;
            document.getElementById(`count-${bucket}`).textContent = counts[bucket];
        });
        addDragListeners();
        updateDeleteSelectedButton();
        
        // Ger√§te-Registry im Modal aktualisieren (falls Mogul-Daten geladen)
        if (p2pDataStore && currentDeviceId) {
            renderDeviceRegistry();
        }
    };

    const getCardActions = (task) => {
        const BASE_SVG = `<svg xmlns="http://www.w3.org/2000/svg" class="svg-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">`;
        if (task.bucket === 'open') {
            return [{ text: 'Arbeit starten', targetBucket: 'in_progress', icon: `${BASE_SVG}<path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5 21 12m0 0-7.5 7.5M21 12H3" /></svg>`, colorClass: 'text-primary hover:text-primary' }];
        } else if (task.bucket === 'in_progress') {
            return [
                { text: 'Zur√ºck zu Offen', targetBucket: 'open', icon: `${BASE_SVG}<path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18" /></svg>`, colorClass: 'text-base-content/50 hover:text-base-content' },
                { text: 'Als Erledigt markieren', targetBucket: 'done', icon: `${BASE_SVG}<path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75 11.25 15 15 9.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" /></svg>`, colorClass: 'text-success hover:text-success' }
            ];
        } else if (task.bucket === 'done') {
            return [{ text: 'Wieder √∂ffnen', targetBucket: 'in_progress', icon: `${BASE_SVG}<path stroke-linecap="round" stroke-linejoin="round" d="M15.042 21.042 21 15m0 0-5.958-5.958M21 15H3" /></svg>`, colorClass: 'text-warning hover:text-warning' }];
        }
        return [];
    };

    const createTaskCard = (task) => {
        const card = document.createElement('div');
        const completedClass = task.completed ? 'completed' : '';
        const priorityClass = task.dueDate && new Date(task.dueDate) < new Date() && !task.completed ? 'border-error' : '';

        card.className = `task-card card bg-base-100 shadow-xl border-t-4 ${priorityClass} ${completedClass} p-4 relative`;
        card.setAttribute('draggable', true);
        card.dataset.taskId = task.id;
        card.dataset.bucket = task.bucket;
        
        let actionButtonsHTML = '';
        const actions = getCardActions(task);
        if (actions.length > 0) {
            actionButtonsHTML += '<div class="card-actions justify-end mt-2">';
            actions.forEach(action => {
                actionButtonsHTML += `<button class="btn btn-xs btn-ghost task-advance-btn ${action.colorClass}" data-id="${task.id}" data-target="${action.targetBucket}" title="${action.text}">${action.icon}</button>`;
            });
            actionButtonsHTML += '</div>';
        }

        let topIconHtml = '';
        if (task.completed && task.bucket === 'done') {
            topIconHtml = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-success absolute top-2 right-2" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>`;
        } else {
            topIconHtml = `<button class="btn btn-xs btn-ghost text-base-content/50 absolute top-2 right-2 z-10 edit-btn" title="Details bearbeiten"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 17.21a4.5 4.5 0 0 1-1.897 1.13L6 18.24l.842-2.793a4.5 4.5 0 0 1 1.13-1.897l8.243-8.243Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 14.25H2.25" /></svg></button>`;
        }

        card.innerHTML = `
            ${topIconHtml}
            <div class="card-body p-0">
                <h3 class="card-title text-base task-title">${task.title}</h3>
                <p class="text-xs text-base-content/70 task-details">${task.details.substring(0, 100)}${task.details.length > 100 ? '...' : ''}</p>
                <div class="flex flex-wrap gap-2 text-xs font-mono mt-2">
                    <span class="badge badge-sm badge-outline" title="Startdatum">${task.startDate}</span>
                    ${task.dueDate ? `<span class="badge badge-sm badge-outline ${priorityClass ? 'badge-error' : ''}" title="F√§lligkeitsdatum">F√§llig: ${task.dueDate}</span>` : ''}
                </div>
                ${actionButtonsHTML}
            </div>
        `;

        card.addEventListener('click', (e) => {
            const isButton = e.target.closest('button');
            const isEditButton = e.target.closest('.edit-btn');
            const isAdvanceButton = e.target.closest('.task-advance-btn');

            if (isAdvanceButton) return;

            const isCtrlCmd = e.metaKey || e.ctrlKey;
            const isShift = e.shiftKey;

            if (isEditButton || (!isButton && !isCtrlCmd && !isShift && selectedTaskIds.size <= 1)) {
                openTaskModal(task.id);
            } else if (!isButton) {
                handleTaskSelection(task.id, isCtrlCmd, isShift);
            }
        });

        card.addEventListener('dblclick', () => {
            openTaskModal(task.id);
        });
        
        return card;
    };

    // --- 1.10 Event Listeners (UI) ---
    const addUIEventListeners = () => {
        // Task Advance Buttons
        document.getElementById('kanban-board').addEventListener('click', (e) => {
            const btn = e.target.closest('.task-advance-btn');
            if (btn) {
                const taskId = Number(btn.dataset.id);
                const targetBucket = btn.dataset.target;
                performTaskAction(taskId, targetBucket);
            }
        });

        // Edit Selected Button
        document.getElementById('edit-selected-btn').addEventListener('click', () => {
            if (selectedTaskIds.size === 1) {
                const taskId = Array.from(selectedTaskIds)[0];
                openTaskModal(taskId);
            }
        });

        // Delete & Add Task Buttons
        document.getElementById('delete-selected-btn').addEventListener('click', () => openDeleteConfirmModal());
        document.getElementById('add-task-btn').addEventListener('click', openTaskModalForNewTask);

        // Modal Listeners
        document.getElementById('task-detail-form').addEventListener('submit', (e) => {
            e.preventDefault();
            const taskId = Number(document.getElementById('task-id-input').value);
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                task.title = document.getElementById('task-title-input').value.trim();
                task.details = document.getElementById('task-details-input').value.trim();
                task.startDate = document.getElementById('task-start-date-input').value;
                task.dueDate = document.getElementById('task-due-date-input').value;
                task.lastModified = Date.now();
                p2pSaveState(); // P2P-Speichern ausl√∂sen
                renderTasks();
            }
            task_modal.close();
        });

        // GSF Import/Export Listeners
        document.getElementById('import-gsf-btn').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.onchange = (e) => handleGSFImport(e.target.files[0]);
            input.click();
        });

        document.getElementById('export-gsf-btn').addEventListener('click', () => {
            if (currentCommitHash) generateGSF(currentCommitHash);
        });

        // Device Management
        document.getElementById('manage-devices-btn').addEventListener('click', () => {
             if (currentDeviceId) {
                document.getElementById('current-device-id-display').value = currentDeviceId;
             }
             manage_devices_modal.showModal();
        });
        document.getElementById('add-device-btn').addEventListener('click', () => {
            const newId = document.getElementById('new-device-id-input').value.trim();
            if (newId) {
                addDevice(newId);
                document.getElementById('new-device-id-input').value = '';
            }
        });

        // P2P-Modal Listeners
        document.getElementById('p2p-modal-btn').addEventListener('click', () => {
             p2p_modal.showModal();
        });
        
        document.getElementById('p2p-start-pull-btn').addEventListener('click', () => {
            if (p2pIsOffer) {
                // Client (Handy) klickt, um PULL abzuschlie√üen
                const answer = document.getElementById('p2p-answer-input').value;
                if (answer) p2pAcceptAnswer(answer);
            } else {
                // Chef (PC) klickt, um auf Offer zu antworten
                const offer = document.getElementById('p2p-offer-output').value;
                if (offer) p2pCreateAnswer(offer);
            }
        });
        
        // Tab-Wechsel im P2P-Modal steuert, ob wir Offer (Client) oder Answer (Chef) sind
        document.getElementById('tab-offer').addEventListener('change', () => p2pIsOffer = true);
        document.getElementById('tab-answer').addEventListener('change', () => p2pIsOffer = false);

        // Global Key Listeners (Delete, Undo/Redo)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedTaskIds.size > 0 && !task_modal.open) {
                    e.preventDefault();
                    openDeleteConfirmModal();
                }
            }
            // CMD/CTRL + Z for Undo
            if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
                e.preventDefault();
                undo();
            }
            // CMD/CTRL + SHIFT + Z for Redo
            if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'Z') {
                e.preventDefault();
                redo();
            }
        });

        document.addEventListener('click', (e) => {
            // Klick au√üerhalb einer Task-Card (auf Kanban-Board oder Body)
            const isTaskCard = e.target.closest('.task-card');
            const isNavbar = e.target.closest('.navbar');
            const isModal = e.target.closest('.modal');
            
            if (!isTaskCard && !isNavbar && !isModal && selectedTaskIds.size > 0) {
                clearSelection();
            }
        });

        console.log('Mogul P2P-CHEF-Sync gestartet....');
    };


    // === 2. P2P-CHEF-SYNC LOGIK (KERN) ===
    // Enth√§lt Passkey, Crypto, IndexedDB, Device-Registry und P2P-Logik.
    // -----------------------------------------------------------------

    // --- 2.1 Konstanten & Globale P2P-Variablen ---
    const DB_NAME_PREFIX = 'MogulChefDB_';
    const DB_VERSION = 1;
    const COMMIT_STORE = 'commits';
    // const KEK_STORE_KEY = 'mogul_device_kek'; // Key Encryption Key (KEK) - Nicht genutzt wg. Vereinfachung
    const WRAPPED_UK_KEY = 'mogul_universal_key'; // Universal Key (UK) wird HIER gespeichert (Simplifizierte Version)
    const DEVICE_ID_KEY = 'mogul_device_id';
    const PASSKEY_ID_KEY = 'mogul_passkey_cred_id';
    const AUTH_ID = 'ChristianHeinrichHohlfeld'; // Statische RP-User-ID
    const GSF_APP_ID = 'MogulP2P_v1';
    const MAX_DEVICES = 4;

    // Globale Zustandsvariablen (P2P)
    let db; // IndexedDB-Instanz
    let chefDBInstance = null;
    let currentDeviceId = null;
    let currentUniversalKey = null; // Universal Key (UK) im RAM
    let p2pDataStore = null; // Globales Objekt { appData: { tasks, deviceRegistry } }
    let currentCommitHash = null;
    let isChefDevice = false;
    
    // P2P-WebRTC Variablen
    let peerConnection = null;
    let dataChannel = null;
    let p2pIsOffer = false; // Steuert, ob wir das Angebot (Offer) senden (Client) oder die Antwort (Answer) (Chef)

    // --- 2.2 Crypto-Helper-Funktionen ---
    
    function arrayBufferToBase64Url(buffer) {
        const bytes = new Uint8Array(buffer);
        let str = '';
        for (let i = 0; i < bytes.byteLength; i++) {
            str += String.fromCharCode(bytes[i]);
        }
        return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    function base64UrlToArrayBuffer(base64url) {
        const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
        let padding = 4 - (base64.length % 4);
        if (padding > 0 && padding < 4) {
             base64 += '==='.slice(0, padding);
        }
        const str = atob(base64);
        const buffer = new ArrayBuffer(str.length);
        const bytes = new Uint8Array(buffer);
        for (let i = 0; i < str.length; i++) {
            bytes[i] = str.charCodeAt(i);
        }
        return buffer;
    }

    // Erzeugt einen HMAC-Signatur-Hash
    async function hmac(dataBuffer, keyBytes) {
        const key = await crypto.subtle.importKey(
            'raw', keyBytes,
            { name: "HMAC", hash: { name: "SHA-256" } },
            false,
            ["sign"]
        );
        const signature = await crypto.subtle.sign("HMAC", key, dataBuffer);
        return arrayBufferToBase64Url(signature);
    }

    // √úberpr√ºft einen HMAC-Hash
    async function verifyHmac(dataString, signatureBase64Url, keyBytes) {
        try {
            const key = await crypto.subtle.importKey(
                'raw', keyBytes,
                { name: "HMAC", hash: { name: "SHA-256" } },
                false,
                ["verify"]
            );
            return crypto.subtle.verify("HMAC", key, base64UrlToArrayBuffer(signatureBase64Url), new TextEncoder().encode(dataString));
        } catch (e) {
            console.error("HMAC Verifikation fehlgeschlagen", e);
            return false;
        }
    }

    // --- 2.3 Ger√§te-ID Management ---
    function getDeviceId() {
        let id = localStorage.getItem(DEVICE_ID_KEY);
        if (!id) {
            id = `dev_${arrayBufferToBase64Url(crypto.getRandomValues(new Uint8Array(16)))}`;
            localStorage.setItem(DEVICE_ID_KEY, id);
        }
        return id;
    }

    // --- 2.4 Universal Key (UK) & Key Encryption Key (KEK) Management ---
    
    // HILFSFUNKTIONEN (Simplifizierte/Non-Op Placeholder f√ºr die Broken KEK Logik)
    // FIX: Diese sind No-Ops/Simplified, um die F5-Funktionalit√§t zu gew√§hrleisten.
    async function getOrCreateKEK() { return 'KEK_MOCK_KEY'; } 
    async function unwrapUniversalKey(wrappedKeyB64, kek) { return 'UNWRAPPED_KEY'; } 

    // (A) Leitet den Universal Key (UK) vom Passkey-Assertion-Resultat ab.
    async function deriveKeyFromPasskey(assertion) {
        // Erzeugt einen Universal Key (UK) aus der Passkey-Response
        const clientDataJSON = arrayBufferToBase64Url(assertion.response.clientDataJSON);
        const authenticatorData = arrayBufferToBase64Url(assertion.response.authenticatorData);
        const keyMaterial = clientDataJSON + authenticatorData;

        // Erzeuge Key-Derivations-Key (KDK)
        const kdk = await crypto.subtle.importKey(
            'raw', new TextEncoder().encode(keyMaterial.substring(0, 32)), // Simples KDK aus Material
            { name: 'PBKDF2' },
            false,
            ['deriveKey']
        );

        // Leite Universal Key (UK) ab
        const salt = new TextEncoder().encode(AUTH_ID);
        const derivedKey = await crypto.subtle.deriveKey(
            {
                name: 'PBKDF2',
                salt: salt,
                iterations: 100000,
                hash: 'SHA-256'
            },
            kdk,
            { name: "AES-GCM", length: 256 },
            true, // Exportierbar, damit er im localStorage gespeichert werden kann (WICHTIG f√ºr F5-Fix)
            ["encrypt", "decrypt"]
        );
        const keyBytes = await crypto.subtle.exportKey('raw', derivedKey);
        return keyBytes; // 32 Byte Key als ArrayBuffer
    }

    // --- 2.5 IndexedDB (ChefDB) ---
    class ChefDB {
        constructor(deviceId) {
            this.dbName = `${DB_NAME_PREFIX}${deviceId}`;
            this.db = null;
        }

        async init() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(this.dbName, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(COMMIT_STORE)) {
                        db.createObjectStore(COMMIT_STORE, { keyPath: 'hash' });
                    }
                };
                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    console.log("ChefDB initialisiert:", this.dbName);
                    resolve(this.db);
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // (A) AES-GCM Verschl√ºsselung (Nutzt UK im RAM)
        async encrypt(data) {
            if (!currentUniversalKey) throw new Error("Verschl√ºsselungsfehler: Universal Key fehlt.");
            const key = await crypto.subtle.importKey('raw', base64UrlToArrayBuffer(currentUniversalKey), "AES-GCM", false, ["encrypt"]);
            const iv = crypto.getRandomValues(new Uint8Array(12)); // 96 bits
            const encoded = new TextEncoder().encode(JSON.stringify(data));
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                encoded
            );
            return { iv: arrayBufferToBase64Url(iv), data: arrayBufferToBase64Url(encrypted) };
        }

        // (B) AES-GCM Entschl√ºsselung
        async decrypt(encryptedPayload) {
            if (!currentUniversalKey) throw new Error("Entschl√ºsselungsfehler: Universal Key fehlt.");
            const key = await crypto.subtle.importKey('raw', base64UrlToArrayBuffer(currentUniversalKey), "AES-GCM", false, ["decrypt"]);
            const iv = base64UrlToArrayBuffer(encryptedPayload.iv);
            const dataBuffer = base64UrlToArrayBuffer(encryptedPayload.data);
            
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                dataBuffer
            );
            return JSON.parse(new TextDecoder().decode(decrypted));
        }

        // (C) Speichert neuen Commit in IndexedDB
        async commitData(appData, parentHash = null) {
            const commitTime = Date.now();
            const encryptedPayload = await this.encrypt({ appData, commitTime, parentHash });
            const payloadString = JSON.stringify(encryptedPayload);
            
            // Hash des Payloads (Commit Hash)
            const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(payloadString));
            const hash = arrayBufferToBase64Url(hashBuffer);

            const commitBlock = {
                hash,
                payload: encryptedPayload,
                metadata: {
                    deviceId: currentDeviceId,
                    timestamp: commitTime,
                    parentHash
                }
            };
            
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(COMMIT_STORE, 'readwrite');
                tx.oncomplete = () => resolve(hash);
                tx.onerror = (e) => reject(e);
                
                const request = tx.objectStore(COMMIT_STORE).put(commitBlock);
                request.onerror = (e) => reject(e);
            });
        }

        // (D) L√§dt den letzten Commit und entschl√ºsselt ihn
        async checkoutCommit(hash) {
            const commitBlock = await this.getRawCommitBlock(hash);
            if (!commitBlock) throw new Error("Commit nicht gefunden: " + hash);
            return await this.decrypt(commitBlock.payload);
        }
        
        // (E) L√§dt einen rohen Commit-Block (f√ºr P2P-Transfer)
        async getRawCommitBlock(hash) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(COMMIT_STORE, 'readonly');
                const request = tx.objectStore(COMMIT_STORE).get(hash);
                request.onsuccess = (event) => {
                    if (!event.target.result) return reject(new Error("Commit nicht gefunden."));
                    resolve(event.target.result); // Gibt { hash, payload } zur√ºck
                };
                request.onerror = () => reject(request.error);
            });
        }

        // (F) Speichert einen rohen Commit-Block (von P2P-Transfer)
        async putRawCommitBlock(commitBlock) {
            const tx = this.db.transaction(COMMIT_STORE, 'readwrite');
            await tx.objectStore(COMMIT_STORE).put(commitBlock);
            return tx.done;
        }
        
        // (G) L√§dt den Hash des neuesten Commits (wird beim Chef-Ger√§t verwendet)
        async getLatestCommitHash() {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(COMMIT_STORE, 'readonly');
                const store = tx.objectStore(COMMIT_STORE);
                const request = store.openCursor(null, 'prev'); // Letztes Element
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        resolve(cursor.value.hash);
                    } else {
                        resolve(null); // Keine Commits
                    }
                };
                request.onerror = () => reject(request.error);
            });
        }
    }

    // --- 2.6 WebAuthn (Passkey) Logik ---
    
    // (Helper: UI Status Update)
    function updateSyncStatus(message, isError = false) {
        const statusText = document.getElementById('sync-status-text');
        const indicator = document.getElementById('sync-status-indicator');
        
        statusText.textContent = message.toUpperCase().substring(0, 30);
        indicator.setAttribute('data-tip', message);

        statusText.classList.remove('text-warning', 'text-success', 'text-error');
        if (isError) {
            statusText.classList.add('text-error');
        } else if (message.includes('SYNC ERFOLG') || message.includes('Chef')) {
            statusText.classList.add('text-success');
        } else {
            statusText.classList.add('text-warning');
        }

        // Export/Import Buttons anzeigen/verbergen
        if (isChefDevice) {
            document.getElementById('export-gsf-btn').classList.remove('hidden');
        } else {
            document.getElementById('export-gsf-btn').classList.add('hidden');
        }
    }
    
    // (A) Startet den gesamten Auth-Fluss
    function initializePasskeyFlow() {
        currentDeviceId = getDeviceId();
        chefDBInstance = new ChefDB(currentDeviceId);

        const authModal = document.getElementById('auth_modal');
        const loadingView = document.getElementById('auth-loading');
        const registerView = document.getElementById('auth-register-view');
        const loginView = document.getElementById('auth-login-view');

        loadingView.classList.remove('hidden');
        registerView.classList.add('hidden');
        loginView.classList.add('hidden');

        if (!window.PublicKeyCredential) {
            updateSyncStatus("WebAuthn nicht unterst√ºtzt", true);
            loadingView.innerHTML = "<p class='text-error'>Dieser Browser unterst√ºtzt keine Passkeys (WebAuthn). Sicherer Modus nicht verf√ºgbar.</p>";
            return;
        }
        
        // Initialisiere DB VOR dem Passkey-Schritt
        chefDBInstance.init().then(() => {
            const passkeyId = localStorage.getItem(PASSKEY_ID_KEY);
            if (passkeyId) {
                // Login-Flow
                loadingView.classList.add('hidden');
                loginView.classList.remove('hidden');
                document.getElementById('login-passkey-btn').onclick = startPasskeyAssertion;
            } else {
                // Registrierungs-Flow
                loadingView.classList.add('hidden');
                registerView.classList.remove('hidden');
                document.getElementById('register-passkey-btn').onclick = startPasskeyRegistration;
            }
        }).catch(e => {
            console.error("Datenbankfehler:", e);
            updateSyncStatus("DB-Fehler: Neustart erforderlich.", true);
        });
    }

    // (B) Registrierung
    async function startPasskeyRegistration() {
        try {
            updateSyncStatus("Passkey registrieren...", false);
            // 1. Erzeuge Challenge und Options
            const challenge = crypto.getRandomValues(new Uint8Array(32));
            const credentialCreationOptions = {
                challenge,
                rp: { id: window.location.hostname, name: "Mogul P2P Sync" },
                user: { id: new TextEncoder().encode(AUTH_ID), name: AUTH_ID, displayName: "Mogul User" },
                pubKeyCredParams: [{ alg: -7, type: "public-key" }, { alg: -257, type: "public-key" }],
                timeout: 60000,
                attestation: "direct"
            };

            // 2. Registrierungsanfrage senden
            const credential = await navigator.credentials.create({ publicKey: credentialCreationOptions });

            // 3. Key Derivation (UK)
            const keyBytes = await deriveKeyFromPasskey(credential);
            currentUniversalKey = arrayBufferToBase64Url(keyBytes); // UK in RAM setzen

            // FIX F5: Speichere den UK direkt im localStorage (simplification, forfeiting KEK security)
            localStorage.setItem(WRAPPED_UK_KEY, currentUniversalKey);

            // 4. Metadaten speichern
            const passkeyId = arrayBufferToBase64Url(credential.rawId);
            localStorage.setItem(PASSKEY_ID_KEY, passkeyId);

            // 5. Initiales p2pDataStore erzeugen
            loadState(); // Erzeugt den initialen p2pDataStore

            // 6. Erster Commit in DB (Chef)
            currentCommitHash = await chefDBInstance.commitData(p2pDataStore.appData, null);
            localStorage.setItem(`mogul_last_hash_${currentDeviceId}`, currentCommitHash);
            isChefDevice = true;

            // 7. Initiales Ger√§t zur Registry hinzuf√ºgen
            addDevice(currentDeviceId, true);

            // 8. Erzwinge GSF-Export (Bootstrap)
            await generateGSF(currentCommitHash);
            updateSyncStatus(`Registriert. Sie sind Chef!`, false);
            
            auth_modal.close(); // Schlie√üe Auth-Modal nach erfolgreicher Registrierung
            renderTasks();

        } catch (e) {
            console.error("Passkey-Registrierung fehlgeschlagen:", e);
            updateSyncStatus("Registrierung fehlgeschlagen", true);
        }
    }

    // (C) Login (Assertion)
    async function startPasskeyAssertion() {
        try {
            updateSyncStatus("Passkey-Login...", false);
            const passkeyId = localStorage.getItem(PASSKEY_ID_KEY);
            if (!passkeyId) throw new Error("Keine Passkey-ID gefunden.");
            
            const challenge = crypto.getRandomValues(new Uint8Array(32));
            const publicKeyCredentialRequestOptions = {
                challenge,
                allowCredentials: [{ type: "public-key", id: base64UrlToArrayBuffer(passkeyId) }],
                timeout: 60000,
                userVerification: "required"
            };

            const assertion = await navigator.credentials.get({ publicKey: publicKeyCredentialRequestOptions });
            
            // 1. Key Derivation (UK)
            const keyBytes = await deriveKeyFromPasskey(assertion);
            currentUniversalKey = arrayBufferToBase64Url(keyBytes); // UK in RAM setzen

            console.log("Passkey-Assertion erfolgreich (UK abgeleitet).");

            // 2. Fortsetzung nach Login
            await initializeSyncContinuation();

        } catch (e) {
            console.error("Passkey-Login fehlgeschlagen:", e);
            updateSyncStatus("Login fehlgeschlagen", true);
        }
    }

    // (D) Fortsetzung des Sync-Flows nach erfolgreichem Passkey-Login
    async function initializeSyncContinuation() {
        try {
            // FIX F5: Lade UK direkt aus localStorage (Simplifizierung des Unwrap-Prozesses)
            const universalKeyB64 = localStorage.getItem(WRAPPED_UK_KEY);
            if (universalKeyB64) {
                currentUniversalKey = universalKeyB64; // UK direkt aus localStorage laden
                
                // 1. Lade letzte bekannte Hash
                const lastHash = localStorage.getItem(`mogul_last_hash_${currentDeviceId}`);
                if (lastHash) {
                    currentCommitHash = lastHash;
                    // 2. Lade und entschl√ºssele den letzten Commit
                    const payload = await chefDBInstance.checkoutCommit(currentCommitHash);
                    p2pDataStore = payload;
                    tasks = p2pDataStore.appData.tasks;
                    isChefDevice = p2pDataStore.appData.deviceRegistry.ids.includes(currentDeviceId);

                    updateSyncStatus(isChefDevice ? "Chef-Ger√§t geladen." : "Folge-Ger√§t geladen.", false);
                } else {
                    updateSyncStatus("UK geladen, aber keine lokalen Daten. GSF Import erforderlich.", true);
                    isChefDevice = false; // Kann kein Chef sein ohne lokalen Commit
                }

            } else {
                // Sollte nicht passieren, wenn Registrierung erfolgreich war, aber als Fallback
                updateSyncStatus("Universal Key fehlt. Registrierung/GSF Import erforderlich.", true);
                isChefDevice = false;
            }
        } catch (e) {
            updateSyncStatus("Lokale Daten korrupt? PULL erforderlich.", true);
            isChefDevice = false;
        }

        // UI entsperren
        auth_modal.close(); // FIX: Schlie√üt das Modal, nachdem der Ladevorgang (erfolgreich oder fehlerhaft) abgeschlossen ist.
        loadState(); // Lade Cache (Tasks werden nun vom p2pDataStore √ºberschrieben/initialisiert)
        renderTasks();
    }


    // --- 2.7 GSF (Global Status File) Logik ---

    // (A) GSF Exportieren (Der "PUSH")
    async function generateGSF(hash) {
        if (!isChefDevice) {
            updateSyncStatus("Nur Chef kann GSF exportieren", true);
            return;
        }
        if (!currentUniversalKey) {
            updateSyncStatus("Fehler: UK fehlt. PULL erforderlich.", true);
            return;
        }
        
        // Stelle sicher, dass die Registry aktuell ist
        if (!p2pDataStore.appData.deviceRegistry.ids.includes(currentDeviceId)) {
             addDevice(currentDeviceId, true); // Eigene ID hinzuf√ºgen falls vergessen
        }

        const payload = {
            app: GSF_APP_ID,
            hash: hash,
            timestamp: Date.now(),
            deviceId: currentDeviceId
        };
        const payloadString = JSON.stringify(payload);

        // Signieren mit HMAC
        const keyBytes = base64UrlToArrayBuffer(currentUniversalKey);
        const sig = await hmac(new TextEncoder().encode(payloadString), keyBytes);

        const gsf = { ...payload, sig, universalKey: currentUniversalKey }; // UK IST HIER IM GSF

        // Download ausl√∂sen
        const jsonString = JSON.stringify(gsf);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const date = new Date().toISOString().split('T')[0];
        const a = document.createElement('a');
        a.href = url;
        a.download = `mogul_sync_state_${date}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        updateSyncStatus(`GSF Exportiert (Chef: ${currentDeviceId.substring(0, 7)})`, false);
    }

    // (B) GSF Importieren (Startet den PULL / Chef-Check)
    async function handleGSFImport(file) {
        if (!chefDBInstance || !currentDeviceId) {
            updateSyncStatus("Fehler: Auth nicht abgeschlossen", true);
            return;
        }
        
        const reader = new FileReader();
        reader.onload = async (event) => {
            let gsf;
            try {
                gsf = JSON.parse(event.target.result);

                if (gsf.app !== GSF_APP_ID) throw new Error("Falsches Dateiformat.");
                if (!gsf.universalKey || !gsf.sig) throw new Error("GSF unvollst√§ndig/korrupt.");

                // 1. Verifiziere HMAC-Signatur
                const keyBytes = base64UrlToArrayBuffer(gsf.universalKey);
                const payload = { app: gsf.app, hash: gsf.hash, timestamp: gsf.timestamp, deviceId: gsf.deviceId };
                const payloadString = JSON.stringify(payload);
                const isVerified = await verifyHmac(payloadString, gsf.sig, keyBytes);

                if (!isVerified) throw new Error("GSF Signatur ung√ºltig. Daten manipuliert.");

                // 2. Schl√ºssel √ºbernehmen und speichern (Fix F5)
                currentUniversalKey = gsf.universalKey;
                localStorage.setItem(WRAPPED_UK_KEY, currentUniversalKey);

                updateSyncStatus("GSF verifiziert. PULL wird gestartet...", false);

                // 3. Starte P2P-Prozess (Offer erzeugen)
                p2p_modal.showModal();
                p2pIsOffer = true; // Wir (Client) machen das Angebot
                document.getElementById('tab-offer').click(); // Offer-Tab zeigen
                await p2pCreateOffer();
            } catch (e) {
                console.error("GSF Import Fehler:", e);
                updateSyncStatus(`GSF Import fehlgeschlagen: ${e.message}`, true);
            }
        };
        reader.readAsText(file);
    }

    // --- 2.8 P2P (WebRTC) Logik (Manuelle Kopplung) ---

    function p2pCleanup() {
        if (dataChannel) dataChannel.close();
        if (peerConnection) peerConnection.close();
        dataChannel = null;
        peerConnection = null;
        p2pIsOffer = false;
        document.getElementById('p2p-status').textContent = "Getrennt";
    }

    // (A) Initialisiert die PC-Instanz
    async function p2pInitConnection() {
        p2pCleanup();
        peerConnection = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });

        peerConnection.onicecandidate = (e) => {
            if (!e.candidate) {
                // Alle Kandidaten gesammelt. Aktualisiere Offer/Answer Textarea.
                if (p2pIsOffer) {
                    document.getElementById('p2p-offer-output').value = JSON.stringify(peerConnection.localDescription);
                } else {
                    // Chef-Seite (Answer)
                    document.getElementById('p2p-answer-input').value = JSON.stringify(peerConnection.localDescription);
                }
            }
        };

        peerConnection.onconnectionstatechange = () => {
            document.getElementById('p2p-status').textContent = `Status: ${peerConnection.connectionState}`;
        };

        // Wenn wir der Empf√§nger sind (Chef-Ger√§t, das PULL bedient)
        peerConnection.ondatachannel = (event) => {
            dataChannel = event.channel;
            p2pSetupDataChannel();
        };
    }

    // (B) Client (Handy) startet PULL (erzeugt Offer)
    async function p2pCreateOffer() {
        await p2pInitConnection();
        p2pIsOffer = true;
        updateSyncStatus("Erzeuge P2P-Offer...", false);

        dataChannel = peerConnection.createDataChannel("mogul-sync-channel");
        p2pSetupDataChannel(); // Setup Callbacks, *bevor* Offer erstellt wird
        
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        // (onicecandidate f√ºllt jetzt die 'p2p-offer-output' Textarea)
        updateSyncStatus("Offer erstellt. Code an Chef senden.", false);
    }

    // (C) Chef (PC) akzeptiert PULL (erzeugt Answer)
    async function p2pCreateAnswer(offerString) {
        await p2pInitConnection();
        p2pIsOffer = false;
        updateSyncStatus("Empfange P2P-Offer...", false);

        const offer = JSON.parse(offerString);
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

        // Create Answer
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        // Setup DataChannel (wird hier nicht aufgerufen, da es √ºber ondatachannel beim Chef passiert)
        // Aber wir bereiten die Chef-Seite vor:
        if (dataChannel) p2pSetupDataChannel(); // Falls ondatachannel schon gefeuert hat

        updateSyncStatus("Answer erstellt. Code an Client senden.", false);
    }

    // (D) Client/Chef akzeptiert Answer/Offer
    async function p2pAcceptAnswer(sdpString) {
        updateSyncStatus("Akzeptiere P2P-Antwort...", false);
        const sdp = JSON.parse(sdpString);
        await peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));
        // Verbindung wird nun hergestellt
        updateSyncStatus("Verbindung wird hergestellt...", false);
    }

    // (E) Konfiguriert den DataChannel (Senden/Empfangen)
    function p2pSetupDataChannel() {
        dataChannel.onopen = () => {
            document.getElementById('p2p-status').textContent = "Status: Verbunden";
            updateSyncStatus("P2P-Kanal offen. Datentransfer...", false);

            if (p2pIsOffer) {
                // Client-Seite: Sendet PULL-Anfrage
                dataChannel.send(JSON.stringify({ type: 'pull', deviceId: currentDeviceId }));
            } else {
                // Chef-Seite: Wartet auf PULL-Anfrage
            }
        };

        dataChannel.onmessage = async (event) => {
            const msg = JSON.parse(event.data);

            if (msg.type === 'pull') {
                // Chef-Seite (PC) empf√§ngt PULL-Anfrage vom Client
                if (!isChefDevice) {
                    dataChannel.send(JSON.stringify({ type: 'deny', reason: 'Nur Chef kann Daten senden.' }));
                    updateSyncStatus("PULL abgelehnt: Bin kein Chef.", true);
                    p2pCleanup();
                    return;
                }
                if (!currentUniversalKey) {
                    dataChannel.send(JSON.stringify({ type: 'deny', reason: 'Universal Key fehlt.' }));
                    p2pCleanup();
                    return;
                }

                updateSyncStatus(`PULL-Anfrage von ${msg.deviceId.substring(0, 7)} erhalten. Sende Daten...`, false);

                // 1. Ger√§t zur Registry hinzuf√ºgen (falls es neu ist)
                addDevice(msg.deviceId);

                // 2. Sende den UK und den letzten Hash
                dataChannel.send(JSON.stringify({ type: 'key', key: currentUniversalKey, latestHash: currentCommitHash }));

                // 3. Sende den Commit-Block
                const commitBlock = await chefDBInstance.getRawCommitBlock(currentCommitHash);
                dataChannel.send(JSON.stringify({ type: 'commit', block: commitBlock }));

                updateSyncStatus(`Daten an ${msg.deviceId.substring(0, 7)} gesendet.`, false);

            } else if (msg.type === 'key') {
                // Client-Seite (Handy) empf√§ngt den UK
                currentUniversalKey = msg.key;
                currentCommitHash = msg.latestHash;
                localStorage.setItem(WRAPPED_UK_KEY, currentUniversalKey); // FIX F5: UK speichern
                localStorage.setItem(`mogul_last_hash_${currentDeviceId}`, currentCommitHash);

                updateSyncStatus("Schl√ºssel empfangen...", false);

            } else if (msg.type === 'commit') {
                // Client-Seite (Handy) empf√§ngt den Commit
                const commitBlock = msg.block;

                // 1. Speichere den rohen Block
                await chefDBInstance.putRawCommitBlock(commitBlock);

                // 2. Entschl√ºssele und lade
                const payload = await chefDBInstance.checkoutCommit(commitBlock.hash);

                // 3. Daten √ºbernehmen
                p2pDataStore = payload;
                tasks = p2pDataStore.appData.tasks;
                currentCommitHash = commitBlock.hash;
                localStorage.setItem(`mogul_last_hash_${currentDeviceId}`, currentCommitHash);

                // 4. Chef werden und GSF exportieren
                isChefDevice = p2pDataStore.appData.deviceRegistry.ids.includes(currentDeviceId); // Pr√ºft, ob wir in der neuen Registry sind
                if (!isChefDevice) addDevice(currentDeviceId, true); // Falls wir beim Pull das erste Mal syncen

                updateSyncStatus(`SYNC ERFOLG. ${isChefDevice ? 'Sie sind Chef!' : 'Folge-Ger√§t synchronisiert.'}`, false);
                renderTasks();
                
                p2p_modal.close(); // FIX: Modal schlie√üt nach erfolgreichem SYNC
                p2pCleanup();

            } else if (msg.type === 'deny') {
                updateSyncStatus(`PULL abgelehnt: ${msg.reason}`, true);
                p2pCleanup();
            }
        };

        dataChannel.onclose = () => {
            p2pCleanup();
        };

        dataChannel.onerror = (err) => {
            console.error("Data Channel Fehler:", err);
            updateSyncStatus("P2P-Fehler: Kanal geschlossen.", true);
            p2pCleanup();
        };
    }

    // --- 2.9 Device Registry (Ger√§teverwaltung) ---

    function renderDeviceRegistry() {
        const container = document.getElementById('device-list-container');
        const registry = p2pDataStore.appData.deviceRegistry;
        container.innerHTML = '';

        if (!registry) {
             container.innerHTML = `<div class="text-sm text-error">Ger√§teregistrierung fehlt!</div>`;
             return;
        }

        document.getElementById('current-device-id-display').value = currentDeviceId;

        registry.ids.forEach(id => {
            const name = registry.names[id] || "Unbenanntes Ger√§t";
            const isSelf = (id === currentDeviceId);
            const item = document.createElement('div');
            item.className = `flex justify-between items-center p-2 rounded ${isSelf ? 'bg-primary text-primary-content' : 'bg-base-100'}`;
            item.innerHTML = `
                <span class="font-semibold">${name} ${isSelf ? '(Dieses Ger√§t)' : ''}</span>
                <span class="text-xs font-mono">${id.substring(0, 12)}...</span>
                ${(isChefDevice && !isSelf) ? `<button class="btn btn-xs btn-error" data-id="${id}">Entfernen</button>` : ''}
            `;
            container.appendChild(item);
        });
        
        // Listener f√ºr 'Entfernen' Buttons
        container.querySelectorAll('.btn-error').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const idToRemove = e.target.dataset.id;
                removeDevice(idToRemove);
            });
        });

        // Verstecke Aktivierungs-Sektion, wenn Max-Devices erreicht
        const activationSection = document.getElementById('device-activation-section');
        if (registry.ids.length >= MAX_DEVICES) {
            activationSection.classList.add('hidden');
        } else {
            activationSection.classList.remove('hidden');
        }
    }
    
    // F√ºgt ein Ger√§t zur Registry hinzu
    function addDevice(newDeviceId, isSelf = false) {
        if (!p2pDataStore) return;

        const registry = p2pDataStore.appData.deviceRegistry;
        if (!registry.ids.includes(newDeviceId)) {
            if (registry.ids.length >= MAX_DEVICES) {
                updateSyncStatus("Max. Ger√§teanzahl erreicht.", true);
                return;
            }
            registry.ids.push(newDeviceId);
            registry.names[newDeviceId] = isSelf ? "Chef-Ger√§t" : "Neues Ger√§t";
            p2pSaveState();
        }
    }

    // Entfernt ein Ger√§t aus der Registry
    function removeDevice(deviceId) {
        if (!p2pDataStore || !isChefDevice || deviceId === currentDeviceId) return;

        const registry = p2pDataStore.appData.deviceRegistry;
        registry.ids = registry.ids.filter(id => id !== deviceId);
        delete registry.names[deviceId];

        updateSyncStatus(`Ger√§t ${deviceId.substring(0, 7)} entfernt.`, false);
        p2pSaveState();
    }

    // --- 2.10 P2P Save State (Commit-Steuerung) ---
    
    const p2pSaveState = async () => {
        if (!isChefDevice) {
            // Wenn kein Chef, speichere nicht. Lade alten Zustand neu, um UI-Rollback zu erzwingen
            // (Im echten P2P w√ºrde hier ein Konflikt-Dialog kommen)
            updateSyncStatus("Speichern abgelehnt: Nur Chef kann Commits erzeugen.", true);
            loadState();
            renderTasks();
            return;
        }

        if (!chefDBInstance || !currentUniversalKey) {
            updateSyncStatus("Fehler: Sicherheit nicht initialisiert.", true);
            return;
        }

        // 1. Daten b√ºndeln (Tasks + Registry)
        p2pDataStore.appData.tasks = tasks.filter(t => !t.isDeleted); // Nur aktive Tasks speichern
        p2pDataStore.lastModified = Date.now();

        // 2. Commit in lokale IndexedDB
        try {
            const newHash = await chefDBInstance.commitData(p2pDataStore, currentCommitHash);
            currentCommitHash = newHash;
            localStorage.setItem(`mogul_last_hash_${currentDeviceId}`, currentCommitHash);

            // 3. Lokalen Cache speichern
            saveStateToLocalStorage(p2pDataStore);

            // 4. Snapshot f√ºr Undo/Redo (nur Mogul-Tasks)
            takeSnapshot();
            updateSyncStatus(`Lokal gespeichert (Chef)`, false);

            // 5. Erzwinge GSF-Export (Der "PUSH"-Zwang) - Erzeugt Download, sollte dem Nutzer signalisiert werden
            await generateGSF(currentCommitHash);

        } catch (e) {
            console.error('Commit-Fehler:', e);
            updateSyncStatus(`Commit-Fehler: ${e.message}`, true);
        }
    }


    // === 3. ANWENDUNGSSTART ===
    window.onload = () => {
        currentDeviceId = getDeviceId(); // Muss zuerst abgerufen werden
        loadState(); // Initialisiere Tasks und p2pDataStore (Cache)
        renderTasks(); // Rendere die Cache-Daten

        // Startet den Passkey-Flow (blockiert die UI, bis Auth erfolgt)
        initializePasskeyFlow();

        // F√ºge UI-Listener hinzu
        addUIEventListeners();
    };

    </script>
</body>
</html>
