<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <title>Sinus und Cosinus Oscillator Spiel</title>
    <style>
        /* Basisstile */
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            font-family: Arial, sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            position: relative;
        }

        /* Canvas für Three.js */
        #oscillator-canvas {
            display: block;
        }

        /* Steuerungselemente */
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
        }

        .controls h2 {
            margin-top: 0;
            font-size: 20px;
        }

        .controls button {
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 10px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background-color: #ff5722;
            color: #fff;
        }

        .controls button:hover {
            background-color: #e64a19;
        }

        .controls .parameters {
            margin-top: 15px;
        }

        .controls .parameters div {
            margin-bottom: 8px;
            font-size: 14px;
        }

        /* Anweisungen */
        .instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 10;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            max-width: 300px;
            font-size: 14px;
        }

        .instructions h3 {
            margin-top: 0;
            font-size: 16px;
        }

        .instructions ul {
            padding-left: 20px;
        }

        /* Prevent text selection during drag */
        body {
            user-select: none;
        }
    </style>
</head>

<body>
    <!-- Three.js Canvas -->
    <canvas id="oscillator-canvas"></canvas>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- FlyControls -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/FlyControls.js"></script>

    <!-- Main JavaScript -->
    <script>
        // ============================
        // Three.js Setup
        // ============================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 15);

        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('oscillator-canvas'),
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1); // Schwarzer Hintergrund

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // Licht hinzufügen
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1);
        camera.add(pointLight);
        scene.add(camera);

        // ============================
        // FlyControls Setup
        // ============================
        const flyControls = new THREE.FlyControls(camera, renderer.domElement);
        flyControls.movementSpeed = 10;
        flyControls.rollSpeed = Math.PI / 24;
        flyControls.autoForward = false;
        flyControls.dragToLook = true; // Rechte Maustaste gedrückt halten zum Drehen
        flyControls.enabled = false; // Standardmäßig deaktiviert

        // ============================
        // Pointer Lock Setup für Fly Mode
        // ============================
        // Rechtsklick aktiviert Fly Mode durch Pointer Lock
        renderer.domElement.addEventListener('contextmenu', function (e) {
            e.preventDefault();
        }, false);

        renderer.domElement.addEventListener('mousedown', (event) => {
            if (event.button === 2) { // Rechtsklick
               renderer.domElement.requestPointerLock();
            }
        });

        // Listen for Pointer Lock changes
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === renderer.domElement) {
                flyControls.enabled = true;
            } else {
                flyControls.enabled = false;
            }
        }, false);

        // ============================
        // Parameter und Einstellungen
        // ============================
        const defaultParams = {
            frequencySin: 1.00, // Hz
            amplitudeSin: 1.00,
            phaseSin: 0.00, // in Grad
            frequencyCos: 1.00, // Hz
            amplitudeCos: 1.00,
            phaseCos: 0.00 // in Grad
        };

        let frequencySin = defaultParams.frequencySin;
        let amplitudeSin = defaultParams.amplitudeSin;
        let phaseSin = defaultParams.phaseSin;
        let frequencyCos = defaultParams.frequencyCos;
        let amplitudeCos = defaultParams.amplitudeCos;
        let phaseCos = defaultParams.phaseCos;

        // ============================
        // HUD Elemente aktualisieren
        // ============================
        function updateHUD() {

        }

        updateHUD();

        // ============================
        // Oszillator erstellen
        // ============================
        const oscillatorMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 0.8,
            metalness: 0.5,
            roughness: 0.1
        });

        const oscillatorGeometry = new THREE.SphereGeometry(0.3, 32, 32); // Kleinere Sphere
        const oscillator = new THREE.Mesh(oscillatorGeometry, oscillatorMaterial);
        oscillator.position.set(0, 0, 0);
        scene.add(oscillator);

        // ============================
        // Trail (Spur) hinzufügen mit Fade-Out
        // ============================
        const trailGeometry = new THREE.BufferGeometry();
        const maxTrailPoints = 500;
        const trailPositions = new Float32Array(maxTrailPoints * 3);
        const trailAlphas = new Float32Array(maxTrailPoints * 1); // Alpha-Werte für jeden Punkt

        // Initialisiere Positionen und Alphas
        for (let i = 0; i < maxTrailPoints; i++) {
            trailPositions[i * 3] = 0;
            trailPositions[i * 3 + 1] = 0;
            trailPositions[i * 3 + 2] = 0;
            trailAlphas[i] = 0;
        }

        trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
        trailGeometry.setAttribute('alpha', new THREE.BufferAttribute(trailAlphas, 1));

        // Shader Material für Trail mit Alpha-Fade-Out
        const trailMaterial = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0x00ff00) },
                opacity: { value: 1.0 }
            },
            vertexShader: `
                attribute float alpha;
                varying float vAlpha;
                void main() {
                    vAlpha = alpha;
                    gl_PointSize = 5.0;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                uniform float opacity;
                varying float vAlpha;
                void main() {
                    gl_FragColor = vec4(color, vAlpha * opacity);
                }
            `,
            transparent: true,
            depthWrite: false
        });

        const trail = new THREE.Points(trailGeometry, trailMaterial);
        scene.add(trail);
        let trailIndex = 0;

        function updateTrail(position) {
            // Setze die neue Position
            trailPositions[trailIndex * 3] = position.x;
            trailPositions[trailIndex * 3 + 1] = position.y;
            trailPositions[trailIndex * 3 + 2] = position.z;

            // Setze den Alpha-Wert auf maximal (1.0)
            trailAlphas[trailIndex] = 1.0;

            // Aktualisiere den Index
            trailIndex = (trailIndex + 1) % maxTrailPoints;

            // Aktualisiere die BufferAttributes
            trailGeometry.attributes.position.needsUpdate = true;
            trailGeometry.attributes.alpha.needsUpdate = true;
        }

        // ============================
        // Dragging-Mechanik für Parameter
        // ============================
        let isDragging = false;
        let dragType = null; // 'sin_frequency', 'sin_amplitude', 'sin_phase', 'cos_frequency', 'cos_amplitude', 'cos_phase'
        let startMouse = new THREE.Vector2();
        let currentMouse = new THREE.Vector2();

        renderer.domElement.addEventListener('mousedown', (event) => {
            if (event.button === 0) { // Linksklick
                isDragging = true;
                startMouse.set(event.clientX, event.clientY);

                // Bestimme, welche Art von Drag basierend auf Modifier-Tasten
                if (event.altKey) {
                    if (Math.abs(event.movementX) > Math.abs(event.movementY)) {
                        dragType = 'cos_amplitude';
                    } else {
                        dragType = 'sin_amplitude';
                    }
                    return;
                } else if (event.ctrlKey) {
                    if (Math.abs(event.movementX) > Math.abs(event.movementY)) {
                        dragType = 'cos_phase';
                    } else {
                        dragType = 'sin_phase';
                    }
                    return;
                } else {
                    if (Math.abs(event.movementX) > Math.abs(event.movementY)) {
                        dragType = 'cos_frequency';
                    } else {
                        dragType = 'sin_frequency';
                    }
                    return;
                }
                 dragType = null;
            }
        });

        renderer.domElement.addEventListener('mousemove', (event) => {
            if (!isDragging || !dragType) return;
            currentMouse.set(event.clientX, event.clientY);
        });

        renderer.domElement.addEventListener('mouseup', (event) => {
            if (!isDragging || !dragType) return;

            isDragging = false;

            const endMouse = new THREE.Vector2(event.clientX, event.clientY);
            const dragVector = new THREE.Vector2().subVectors(endMouse, startMouse);

            const dragDistance = dragVector.length();
            if (dragDistance < 10) {
                // Kleine Drags ignorieren
                dragType = null;
                return;
            }

            const dragDirection = dragVector.clone().normalize();
            const isHorizontal = Math.abs(dragVector.x) > Math.abs(dragVector.y);

            // Bestimme die Änderungsrichtung basierend auf Drag-Richtung
            const delta = isHorizontal ? dragVector.x : -dragVector.y;

            // Ändere die entsprechenden Parameter
            switch (dragType) {
                case 'sin_frequency':
                    frequencySin += delta * 0.05;
                    frequencySin = Math.max(0.1, frequencySin); // Mindestfrequenz
                    break;
                case 'cos_frequency':
                    frequencyCos += delta * 0.05;
                    frequencyCos = Math.max(0.1, frequencyCos); // Mindestfrequenz
                    break;
                case 'sin_amplitude':
                    amplitudeSin += delta * 0.05;
                    amplitudeSin = Math.max(0.1, amplitudeSin); // Mindestamplitude
                    break;
                case 'cos_amplitude':
                    amplitudeCos += delta * 0.05;
                    amplitudeCos = Math.max(0.1, amplitudeCos); // Mindestamplitude
                    break;
                case 'sin_phase':
                    phaseSin += delta * 1.0;
                    phaseSin %= 360;
                    if (phaseSin < 0) phaseSin += 360;
                    break;
                case 'cos_phase':
                    phaseCos += delta * 1.0;
                    phaseCos %= 360;
                    if (phaseCos < 0) phaseCos += 360;
                    break;
                default:
                    break;
            }

            updateHUD();
            dragType = null;
        });

        // ============================
        // Animation Loop
        // ============================
        const clock = new THREE.Clock();
        let startTime = Date.now();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Update FlyControls, wenn aktiviert
            flyControls.update(delta);

            const elapsed = (Date.now() - startTime) / 1000; // Sekunden seit Start

            // Berechne die Position basierend auf Sinus und Cosinus
            const radiansSin = THREE.Math.degToRad(phaseSin);
            const radiansCos = THREE.Math.degToRad(phaseCos);
            const xOsc = amplitudeSin * Math.sin(2 * Math.PI * frequencySin * elapsed + radiansSin);
            const yOsc = amplitudeCos * Math.cos(2 * Math.PI * frequencyCos * elapsed + radiansCos);

            // Setze die Position des Oszillators
            oscillator.position.set(xOsc, yOsc, 0);

            // Update Trail
            updateTrail(oscillator.position.clone());

            // Fade out the trail by reducing alpha values
            for (let i = 0; i < maxTrailPoints; i++) {
                trailAlphas[i] *= 0.99; // Dämpfungsfaktor für Alpha
                if (trailAlphas[i] < 0.01) {
                    trailAlphas[i] = 0.0;
                }
            }
            trailGeometry.attributes.alpha.needsUpdate = true;

            renderer.render(scene, camera);
        }

        animate();



        // ============================
        // Reset Perspektive mit Taste "F"
        // ============================
        window.addEventListener('keydown', (event) => {
            if (event.key === 'f' || event.key === 'F') {
                // Setze die Kamera-Perspektive zurück
                camera.position.set(0, 0, 15);
                camera.lookAt(new THREE.Vector3(0, 0, 0));
                flyControls.enabled = false;
                document.exitPointerLock(); // Beende Pointer Lock, falls aktiviert
            }
        });
    </script>
</body>

</html>
