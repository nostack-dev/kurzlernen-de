<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <title>Sinus und Cosinus Oscillator Spiel</title>
    <style>
        /* Basisstile */
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            font-family: Arial, sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            position: relative;
        }

        /* Canvas für Three.js */
        #oscillator-canvas {
            display: block;
        }

        /* Steuerungselemente */
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .controls.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .controls h2 {
            margin-top: 0;
            font-size: 20px;
        }

        .controls button {
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 10px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background-color: #ff5722;
            color: #fff;
        }

        .controls button:hover {
            background-color: #e64a19;
        }

        .controls .parameters {
            margin-top: 15px;
        }

        .controls .parameters div {
            margin-bottom: 8px;
            font-size: 14px;
        }

        /* Anweisungen */
        .instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 10;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            max-width: 300px;
            font-size: 14px;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .instructions.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .instructions h3 {
            margin-top: 0;
            font-size: 16px;
        }

        .instructions ul {
            padding-left: 20px;
        }

        /* Verhindert Textauswahl während des Ziehens */
        body {
            user-select: none;
        }
    </style>

    <!-- Import Maps Polyfill -->
    <!-- Entfernen Sie dies, wenn Import Maps in Ihren Zielbrowsern unterstützt werden -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <!-- Definieren Sie die Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three/build/three.module.js",
                "three/addons/": "https://unpkg.com/three/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <!-- Three.js Canvas -->
    <canvas id="oscillator-canvas"></canvas>

    <!-- Steuerungselemente -->
    <div class="controls">
        <h2>Sinus & Cosinus Steuerung</h2>
        <button id="reset-button">Reset</button>
        <div class="parameters">
            <div><strong>Frequenz Sinus:</strong> <span id="frequency-sin">1.00</span> Hz</div>
            <div><strong>Amplitude Sinus:</strong> <span id="amplitude-sin">1.00</span></div>
            <div><strong>Phase Sinus:</strong> <span id="phase-sin">0.00</span>°</div>
            <hr>
            <div><strong>Frequenz Cosinus:</strong> <span id="frequency-cos">1.00</span> Hz</div>
            <div><strong>Amplitude Cosinus:</strong> <span id="amplitude-cos">1.00</span></div>
            <div><strong>Phase Cosinus:</strong> <span id="phase-cos">0.00</span>°</div>
        </div>
    </div>

    <!-- Anweisungen -->
    <div class="instructions">
        <h3>Anweisungen:</h3>
        <ul>
            <li><strong>Linksklick + Draggen:</strong>
                <ul>
                    <li>Draggen nach oben/unten: Ändert die Frequenz des Sinus</li>
                    <li>Draggen nach links/rechts: Ändert die Frequenz des Cosinus</li>
                    <li>Mit <strong>Alt</strong> gedrückt:
                        <ul>
                            <li>Draggen nach oben/unten: Ändert die Amplitude des Sinus</li>
                            <li>Draggen nach links/rechts: Ändert die Amplitude des Cosinus</li>
                        </ul>
                    </li>
                    <li>Mit <strong>Strg</strong> gedrückt:
                        <ul>
                            <li>Draggen nach oben/unten: Ändert die Phase des Sinus</li>
                            <li>Draggen nach links/rechts: Ändert die Phase des Cosinus</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><strong>Kamera-Navigation:</strong>
                <ul>
                    <li>Tastatur: W/A/S/D für Vorwärts, Links, Rückwärts, Rechts</li>
                    <li>Tastatur: Q für Abwärts, E für Aufwärts</li>
                    <li>Taste <strong>"F"</strong>: Setzt die Kamera-Perspektive zurück</li>
                </ul>
            </li>
            <li><strong>Leertaste (Space):</strong> Blendet Steuerungselemente und Anweisungen ein oder aus</li>
            <li><strong>Reset-Button:</strong> Setzt alle Parameter und die Kamera zurück</li>
        </ul>
    </div>

    <!-- Haupt-JavaScript-Modul -->
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ============================
        // Three.js Setup
        // ============================
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 15);

        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('oscillator-canvas'),
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 1); // Schwarzer Hintergrund

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // ============================
        // Beleuchtung hinzufügen
        // ============================
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1);
        camera.add(pointLight);
        scene.add(camera);

        // ============================
        // PointerLockControls Setup
        // ============================
        const controls = new PointerLockControls(camera, document.body);

        // Aktivieren des Pointer Locks beim Klicken auf das Canvas
        const canvas = document.getElementById('oscillator-canvas');
        canvas.addEventListener('click', () => {
            controls.lock();
        });

        controls.addEventListener('lock', () => {
            console.log('Pointer locked');
        });

        controls.addEventListener('unlock', () => {
            console.log('Pointer unlocked');
        });

        scene.add(controls.getObject());

        // ============================
        // HUD Elemente aktualisieren
        // ============================
        function updateHUD() {
            document.getElementById('frequency-sin').innerText = frequencySin.toFixed(2);
            document.getElementById('amplitude-sin').innerText = amplitudeSin.toFixed(2);
            document.getElementById('phase-sin').innerText = phaseSin.toFixed(2);
            document.getElementById('frequency-cos').innerText = frequencyCos.toFixed(2);
            document.getElementById('amplitude-cos').innerText = amplitudeCos.toFixed(2);
            document.getElementById('phase-cos').innerText = phaseCos.toFixed(2);
        }

        // ============================
        // Parameter und Einstellungen
        // ============================
        const defaultParams = {
            frequencySin: 1.00, // Hz
            amplitudeSin: 1.00,
            phaseSin: 0.00, // in Grad
            frequencyCos: 1.00, // Hz
            amplitudeCos: 1.00,
            phaseCos: 0.00 // in Grad
        };

        let frequencySin = defaultParams.frequencySin;
        let amplitudeSin = defaultParams.amplitudeSin;
        let phaseSin = defaultParams.phaseSin;
        let frequencyCos = defaultParams.frequencyCos;
        let amplitudeCos = defaultParams.amplitudeCos;
        let phaseCos = defaultParams.phaseCos;

        updateHUD();

        // ============================
        // Oszillator erstellen
        // ============================
        const oscillatorMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 0.8,
            metalness: 0.5,
            roughness: 0.1,
            transparent: true,
            opacity: 0.7,
        });

        const oscillatorGeometry = new THREE.SphereGeometry(0.3, 32, 32); // Kleinere Sphere
        const oscillator = new THREE.Mesh(oscillatorGeometry, oscillatorMaterial);
        oscillator.position.set(0, 0, 0);
        scene.add(oscillator);

        // ============================
        // Spur (Trail) hinzufügen mit Fade-Out
        // ============================
        const trailGeometry = new THREE.BufferGeometry();
        const maxTrailPoints = 500;
        const trailPositions = new Float32Array(maxTrailPoints * 3);
        const trailAlphas = new Float32Array(maxTrailPoints * 1); // Alpha-Werte für jeden Punkt

        // Initialisiere Positionen und Alphas
        for (let i = 0; i < maxTrailPoints; i++) {
            trailPositions[i * 3] = 0;
            trailPositions[i * 3 + 1] = 0;
            trailPositions[i * 3 + 2] = 0;
            trailAlphas[i] = 0;
        }

        trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
        trailGeometry.setAttribute('alpha', new THREE.BufferAttribute(trailAlphas, 1));

        // Shader Material für Spur mit Alpha-Fade-Out
        const trailMaterial = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0x00ff00) },
                opacity: { value: 1.0 }
            },
            vertexShader: `
                attribute float alpha;
                varying float vAlpha;
                void main() {
                    vAlpha = alpha;
                    gl_PointSize = 5.0;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                uniform float opacity;
                varying float vAlpha;
                void main() {
                    gl_FragColor = vec4(color, vAlpha * opacity);
                }
            `,
            transparent: true,
            depthWrite: false
        });

        const trail = new THREE.Points(trailGeometry, trailMaterial);
        scene.add(trail);
        let trailIndex = 0;

        function updateTrail(position) {
            // Setze die neue Position
            trailPositions[trailIndex * 3] = position.x;
            trailPositions[trailIndex * 3 + 1] = position.y;
            trailPositions[trailIndex * 3 + 2] = position.z;

            // Setze den Alpha-Wert auf maximal (1.0)
            trailAlphas[trailIndex] = 1.0;

            // Aktualisiere den Index
            trailIndex = (trailIndex + 1) % maxTrailPoints;

            // Aktualisiere die BufferAttributes
            trailGeometry.attributes.position.needsUpdate = true;
            trailGeometry.attributes.alpha.needsUpdate = true;
        }

        // ============================
        // Dragging-Mechanik für Parameter
        // ============================
        let isDragging = false;
        let dragType = null; // 'sin_frequency', 'sin_amplitude', 'sin_phase', 'cos_frequency', 'cos_amplitude', 'cos_phase'
        let startMouse = new THREE.Vector2();
        let currentMouse = new THREE.Vector2();

        // Parameter-Änderung nur mit linker Maustaste, wenn Pointer nicht gesperrt
        renderer.domElement.addEventListener('mousedown', (event) => {
            if (event.button === 0 && !controls.isLocked) { // Linksklick und Pointer nicht gesperrt
                isDragging = true;
                startMouse.set(event.clientX, event.clientY);

                // Temporär setzen, Drag-Typ wird beim Draggen bestimmt
                dragType = null;
            }
        });

        renderer.domElement.addEventListener('mousemove', (event) => {
            if (!isDragging) return;
            currentMouse.set(event.clientX, event.clientY);
        });

        renderer.domElement.addEventListener('mouseup', (event) => {
            if (!isDragging) return;
            isDragging = false;

            const endMouse = new THREE.Vector2(event.clientX, event.clientY);
            const dragVector = new THREE.Vector2().subVectors(endMouse, startMouse);

            const dragDistance = dragVector.length();
            if (dragDistance < 10) {
                // Kleine Drags ignorieren
                dragType = null;
                return;
            }

            const isHorizontal = Math.abs(dragVector.x) > Math.abs(dragVector.y);

            // Bestimme Drag-Typ basierend auf Modifier-Tasten
            if (event.altKey) {
                if (isHorizontal) {
                    dragType = 'cos_amplitude';
                } else {
                    dragType = 'sin_amplitude';
                }
            } else if (event.ctrlKey) {
                if (isHorizontal) {
                    dragType = 'cos_phase';
                } else {
                    dragType = 'sin_phase';
                }
            } else {
                if (isHorizontal) {
                    dragType = 'cos_frequency';
                } else {
                    dragType = 'sin_frequency';
                }
            }

            const delta = isHorizontal ? dragVector.x : -dragVector.y;

            // Ändere die entsprechenden Parameter
            switch (dragType) {
                case 'sin_frequency':
                    frequencySin += delta * 0.05;
                    frequencySin = Math.max(0.1, frequencySin); // Mindestfrequenz
                    break;
                case 'cos_frequency':
                    frequencyCos += delta * 0.05;
                    frequencyCos = Math.max(0.1, frequencyCos); // Mindestfrequenz
                    break;
                case 'sin_amplitude':
                    amplitudeSin += delta * 0.05;
                    amplitudeSin = Math.max(0.1, amplitudeSin); // Mindestamplitude
                    break;
                case 'cos_amplitude':
                    amplitudeCos += delta * 0.05;
                    amplitudeCos = Math.max(0.1, amplitudeCos); // Mindestamplitude
                    break;
                case 'sin_phase':
                    phaseSin += delta * 1.0;
                    phaseSin %= 360;
                    if (phaseSin < 0) phaseSin += 360;
                    break;
                case 'cos_phase':
                    phaseCos += delta * 1.0;
                    phaseCos %= 360;
                    if (phaseCos < 0) phaseCos += 360;
                    break;
                default:
                    break;
            }

            updateHUD();
            dragType = null;
        });

        renderer.domElement.addEventListener('mouseleave', () => {
            if (isDragging) {
                isDragging = false;
                dragType = null;
            }
        });

        // ============================
        // Kamera Bewegung via Tastatur
        // ============================
        const moveSpeed = 10.0; // Geschwindigkeit der Kamera (Einheiten pro Sekunde)
        const move = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            up: false,
            down: false
        };

        const keys = {
            'w': 'forward',
            'W': 'forward',
            's': 'backward',
            'S': 'backward',
            'a': 'left',
            'A': 'left',
            'd': 'right',
            'D': 'right',
            'q': 'down',
            'Q': 'down',
            'e': 'up',
            'E': 'up'
        };

        window.addEventListener('keydown', (event) => {
            const key = event.key;
            if (keys[key] !== undefined) {
                move[keys[key]] = true;
            }

            // Leertaste (Space) zum Ein-/Ausblenden der Steuerungselemente
            if (event.code === 'Space') {
                event.preventDefault(); // Verhindert das Scrollen der Seite
                toggleControlsVisibility();
            }

            // 'F' Taste zum Zurücksetzen der Kamera-Perspektive
            if (event.key === 'f' || event.key === 'F') {
                resetCamera();
            }
        });

        window.addEventListener('keyup', (event) => {
            const key = event.key;
            if (keys[key] !== undefined) {
                move[keys[key]] = false;
            }
        });

        // ============================
        // Toggle Controls Visibility
        // ============================
        let controlsVisible = true;

        function toggleControlsVisibility() {
            controlsVisible = !controlsVisible;
            document.querySelector('.controls').classList.toggle('hidden', !controlsVisible);
            document.querySelector('.instructions').classList.toggle('hidden', !controlsVisible);
        }

        // ============================
        // Reset Camera Funktion
        // ============================
        function resetCamera() {
            // Setze die Kamera-Position zurück
            controls.getObject().position.set(0, 0, 15);
            camera.lookAt(0, 0, 0);
            updateHUD();

            // Optional: Entsperre den Pointer Lock
            controls.unlock();
        }

        // ============================
        // Animation Loop
        // ============================
        const clock = new THREE.Clock();
        let startTime = Date.now();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Kamera Bewegung basierend auf Tastatureingaben
            const moveDistance = moveSpeed * delta;

            if (move.forward) {
                controls.moveForward(moveDistance);
            }
            if (move.backward) {
                controls.moveForward(-moveDistance);
            }
            if (move.left) {
                controls.moveRight(-moveDistance);
            }
            if (move.right) {
                controls.moveRight(moveDistance);
            }
            if (move.up) {
                controls.getObject().position.y += moveDistance;
            }
            if (move.down) {
                controls.getObject().position.y -= moveDistance;
            }

            // Aktualisiere PointerLockControls
            controls.update();

            const elapsed = (Date.now() - startTime) / 1000; // Sekunden seit Start

            // Berechne die Position basierend auf Sinus und Cosinus
            const radiansSin = THREE.MathUtils.degToRad(phaseSin);
            const radiansCos = THREE.MathUtils.degToRad(phaseCos);
            const xOsc = amplitudeSin * Math.sin(2 * Math.PI * frequencySin * elapsed + radiansSin);
            const yOsc = amplitudeCos * Math.cos(2 * Math.PI * frequencyCos * elapsed + radiansCos);

            // Setze die Position des Oszillators
            oscillator.position.set(xOsc, yOsc, 0);

            // Update Trail
            updateTrail(oscillator.position.clone());

            // Fade out the trail by reducing alpha values
            for (let i = 0; i < maxTrailPoints; i++) {
                trailAlphas[i] *= 0.99; // Dämpfungsfaktor für Alpha
                if (trailAlphas[i] < 0.01) {
                    trailAlphas[i] = 0.0;
                }
            }
            trailGeometry.attributes.alpha.needsUpdate = true;

            renderer.render(scene, camera);
        }

        animate();

        // ============================
        // Reset-Button Logik
        // ============================
        document.getElementById('reset-button').addEventListener('click', () => {
            resetCamera();

            // Setze alle Parameter zurück
            frequencySin = defaultParams.frequencySin;
            amplitudeSin = defaultParams.amplitudeSin;
            phaseSin = defaultParams.phaseSin;
            frequencyCos = defaultParams.frequencyCos;
            amplitudeCos = defaultParams.amplitudeCos;
            phaseCos = defaultParams.phaseCos;

            updateHUD();

            // Setze die Position des Oszillators zurück
            oscillator.position.set(0, 0, 0);

            // Setze die Startzeit zurück
            startTime = Date.now();

            // Leere den Trail
            trailIndex = 0;
            for (let i = 0; i < trailGeometry.attributes.position.array.length; i++) {
                trailGeometry.attributes.position.array[i] = 0;
                trailAlphas[i] = 0.0;
            }
            trailGeometry.attributes.position.needsUpdate = true;
            trailGeometry.attributes.alpha.needsUpdate = true;

            // Zeige die Steuerungselemente wieder an, falls versteckt
            if (!controlsVisible) {
                toggleControlsVisibility();
            }

            // Entsperre den Pointer Lock, falls gesperrt
            controls.unlock();
        });
    </script>
</body>

</html>
