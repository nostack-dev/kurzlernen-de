<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <title>Sinus und Cosinus Oscillator Spiel</title>
    <style>
        /* Basisstile */
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            font-family: Arial, sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            position: relative;
        }

        /* Canvas für Three.js */
        #oscillator-canvas {
            display: block;
        }

        /* Steuerungselemente */
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .controls.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .controls h2 {
            margin-top: 0;
            font-size: 20px;
        }

        .controls button {
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 10px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background-color: #ff5722;
            color: #fff;
        }

        .controls button:hover {
            background-color: #e64a19;
        }

        .controls .parameters {
            margin-top: 15px;
        }

        .controls .parameters div {
            margin-bottom: 8px;
            font-size: 14px;
        }

        /* Anweisungen */
        .instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 10;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            max-width: 300px;
            font-size: 14px;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .instructions.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .instructions h3 {
            margin-top: 0;
            font-size: 16px;
        }

        .instructions ul {
            padding-left: 20px;
        }

        /* Verhindert Textauswahl während des Ziehens */
        body {
            user-select: none;
        }
    </style>

    <!-- Import maps polyfill -->
    <!-- Entfernen Sie dies, wenn Import Maps in Ihren Zielbrowsern unterstützt werden -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <!-- Definieren Sie die Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three/build/three.module.js",
                "three/addons/": "https://unpkg.com/three/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <!-- Three.js Canvas -->
    <canvas id="oscillator-canvas"></canvas>

    <!-- Steuerungselemente -->
    <div class="controls">
        <h2>Sinus & Cosinus Steuerung</h2>
        <button id="reset-button">Reset</button>
        <div class="parameters">
            <div><strong>Frequenz Sinus:</strong> <span id="frequency-sin">1.00</span> Hz</div>
            <div><strong>Amplitude Sinus:</strong> <span id="amplitude-sin">1.00</span></div>
            <div><strong>Phase Sinus:</strong> <span id="phase-sin">0.00</span>°</div>
            <hr>
            <div><strong>Frequenz Cosinus:</strong> <span id="frequency-cos">1.00</span> Hz</div>
            <div><strong>Amplitude Cosinus:</strong> <span id="amplitude-cos">1.00</span></div>
            <div><strong>Phase Cosinus:</strong> <span id="phase-cos">0.00</span>°</div>
        </div>
    </div>

    <!-- Anweisungen -->
    <div class="instructions">
        <h3>Anweisungen:</h3>
        <ul>
            <li><strong>Rechtsklick + Draggen:</strong>
                <ul>
                    <li>Draggen nach oben/unten: Ändert die Frequenz des Sinus</li>
                    <li>Draggen nach links/rechts: Ändert die Frequenz des Cosinus</li>
                    <li>Mit <strong>Alt</strong> gedrückt:
                    <ul>
                        <li>Draggen nach oben/unten: Ändert die Amplitude des Sinus</li>
                        <li>Draggen nach links/rechts: Ändert die Amplitude des Cosinus</li>
                    </ul>
                    </li>
                    <li>Mit <strong>Strg</strong> gedrückt:
                    <ul>
                        <li>Draggen nach oben/unten: Ändert die Phase des Sinus</li>
                        <li>Draggen nach links/rechts: Ändert die Phase des Cosinus</li>
                    </ul>
                    </li>
                </ul>
            </li>
            <li><strong>Kamera-Navigation:</strong>
                <ul>
                    <li>Tastatur: W/A/S/D für Vorwärts, Links, Rückwärts, Rechts</li>
                    <li>Tastatur: Q für Abwärts, E für Aufwärts</li>
                    <li>Taste <strong>"F"</strong>: Setzt die Kamera-Perspektive zurück</li>
                </ul>
            </li>
            <li><strong>Leertaste (Space):</strong> Blendet Steuerungselemente und Anweisungen ein oder aus</li>
            <li><strong>Reset-Button:</strong> Setzt alle Parameter und die Kamera zurück</li>
        </ul>
    </div>

    <!-- Haupt-JavaScript-Modul -->
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ============================
        // Three.js Setup
        // ============================
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 15);

        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('oscillator-canvas'),
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 1); // Schwarzer Hintergrund

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // ============================
        // Beleuchtung hinzufügen
        // ============================
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1);
        camera.add(pointLight);
        scene.add(camera);

        // ============================
        // PointerLockControls Setup
        // ============================
        const controls = new PointerLockControls(camera, document.body);

        // Aktivieren des Pointer Locks beim Klicken auf das Canvas
        const canvas = document.getElementById('oscillator-canvas');
        canvas.addEventListener('click', () => {
            controls.lock();
        });

        controls.addEventListener('lock', () => {
            console.log('Pointer locked');
        });

        controls.addEventListener('unlock', () => {
            console.log('Pointer unlocked');
        });

        scene.add(controls.getObject());

        // ============================
        // HUD Elemente aktualisieren
        // ============================
        function updateHUD() {
            document.getElementById('frequency-sin').innerText = frequencySin.toFixed(2);
            document.getElementById('amplitude-sin').innerText = amplitudeSin.toFixed(2);
            document.getElementById('phase-sin').innerText = phaseSin.toFixed(2);
            document.getElementById('frequency-cos').innerText = frequencyCos.toFixed(2);
            document.getElementById('amplitude-cos').innerText = amplitudeCos.toFixed(2);
            document.getElementById('phase-cos').innerText = phaseCos.toFixed(2);
        }

        // ============================
        // Parameter und Einstellungen
        // ============================
        const defaultParams = {
            frequencySin: 1.00, // Hz
            amplitudeSin: 1.00,
            phaseSin: 0.00, // in Grad
            frequencyCos: 1.00, // Hz
            amplitudeCos: 1.00,
            phaseCos: 0.00 // in Grad
        };

        let frequencySin = defaultParams.frequencySin;
        let amplitudeSin = defaultParams.amplitudeSin;
        let phaseSin = defaultParams.phaseSin;
        let frequencyCos = defaultParams.frequencyCos;
        let amplitudeCos = defaultParams.amplitudeCos;
        let phaseCos = defaultParams.phaseCos;

        updateHUD();

        // ============================
        // Oszillator erstellen
        // ============================
        const oscillatorMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 0.8,
            metalness: 0.5,
            roughness: 0.1,
            transparent: true,
            opacity: 0.7,
        });

        const oscillatorGeometry = new THREE.SphereGeometry(0.3, 32, 32); // Kleinere Sphere
        const oscillator = new THREE.Mesh(oscillatorGeometry, oscillatorMaterial);
        oscillator.position.set(0, 0, 0);
        scene.add(oscillator);

        // ============================
        // Spur (Trail) hinzufügen mit Fade-Out
        // ============================
        const trailGeometry = new THREE.BufferGeometry();
        const maxTrailPoints = 500;
        const trailPositionsArray = new Float32Array(maxTrailPoints * 3);
        const trailAlphasArray = new Float32Array(maxTrailPoints * 1); // Alpha-Werte für jeden Punkt

        // Initialisiere Positionen und Alphas
        for (let i = 0; i < maxTrailPoints; i++) {
            trailPositionsArray[i * 3] = 0;
            trailPositionsArray[i * 3 + 1] = 0;
            trailPositionsArray[i * 3 + 2] = 0;
            trailAlphasArray[i] = 0;
        }

        trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositionsArray, 3));
        trailGeometry.setAttribute('alpha', new THREE.BufferAttribute(trailAlphasArray, 1));

        // Shader Material für Spur mit Alpha-Fade-Out
        const trailMaterial = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0x00ff00) },
                opacity: { value: 1.0 }
            },
            vertexShader: `
                attribute float alpha;
                varying float vAlpha;
                void main() {
                    vAlpha = alpha;
                    gl_PointSize = 5.0;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                uniform float opacity;
                varying float vAlpha;
                void main() {
                    gl_FragColor = vec4(color, vAlpha * opacity);
                }
            `,
            transparent: true,
            depthWrite: false
        });

        const trail = new THREE.Points(trailGeometry, trailMaterial);
        scene.add(trail);
        let trailIndex = 0;

        function updateTrail(position) {
            // Setze die neue Position
            trailPositionsArray[trailIndex * 3] = position.x;
            trailPositionsArray[trailIndex * 3 + 1] = position.y;
            trailPositionsArray[trailIndex * 3 + 2] = position.z;

            // Setze den Alpha-Wert auf maximal (1.0)
            trailAlphasArray[trailIndex] = 1.0;

            // Aktualisiere den Index
            trailIndex = (trailIndex + 1) % maxTrailPoints;

            // Aktualisiere die BufferAttributes
            trailGeometry.attributes.position.needsUpdate = true;
            trailGeometry.attributes.alpha.needsUpdate = true;
        }

        // ============================
        // Dragging-Mechanik für Parameter (Rechtsklick)
        // ============================
        let isRightDragging = false;
        let startRightMouse = new THREE.Vector2();
        let currentRightMouse = new THREE.Vector2();

        // Verhindere das Kontextmenü für den Canvas
        canvas.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });

        canvas.addEventListener('mousedown', (event) => {
            if (event.button === 2) { // Rechtsklick
                isRightDragging = true;
                startRightMouse.set(event.clientX, event.clientY);
            }
        });

        window.addEventListener('mousemove', (event) => {
            if (!isRightDragging) return;
            currentRightMouse.set(event.clientX, event.clientY);
        });

        window.addEventListener('mouseup', (event) => {
            if (event.button === 2 && isRightDragging) { // Rechtsklick
                isRightDragging = false;

                const endMouse = new THREE.Vector2(event.clientX, event.clientY);
                const dragVector = new THREE.Vector2().subVectors(endMouse, startRightMouse);

                const dragDistance = dragVector.length();
                if (dragDistance < 10) {
                    // Kleine Drags ignorieren
                    return;
                }

                const isHorizontal = Math.abs(dragVector.x) > Math.abs(dragVector.y);

                // Bestimme Drag-Typ basierend auf Modifier-Tasten
                let dragType = null;
                if (event.altKey) {
                    if (isHorizontal) {
                        dragType = 'frequency_cos';
                    } else {
                        dragType = 'frequency_sin';
                    }
                } else if (event.ctrlKey) {
                    if (isHorizontal) {
                        dragType = 'phase_cos';
                    } else {
                        dragType = 'phase_sin';
                    }
                } else {
                    if (isHorizontal) {
                        dragType = 'amplitude_cos';
                    } else {
                        dragType = 'amplitude_sin';
                    }
                }

                const delta = isHorizontal ? dragVector.x : -dragVector.y;

                // Ändere die entsprechenden Parameter
                switch (dragType) {
                    case 'frequency_sin':
                        frequencySin += delta * 0.05;
                        frequencySin = Math.max(0.1, frequencySin); // Mindestfrequenz
                        break;
                    case 'frequency_cos':
                        frequencyCos += delta * 0.05;
                        frequencyCos = Math.max(0.1, frequencyCos); // Mindestfrequenz
                        break;
                    case 'amplitude_sin':
                        amplitudeSin += delta * 0.05;
                        amplitudeSin = Math.max(0.1, amplitudeSin); // Mindestamplitude
                        break;
                    case 'amplitude_cos':
                        amplitudeCos += delta * 0.05;
                        amplitudeCos = Math.max(0.1, amplitudeCos); // Mindestamplitude
                        break;
                    case 'phase_sin':
                        phaseSin += delta * 1.0;
                        phaseSin %= 360;
                        if (phaseSin < 0) phaseSin += 360;
                        break;
                    case 'phase_cos':
                        phaseCos += delta * 1.0;
                        phaseCos %= 360;
                        if (phaseCos < 0) phaseCos += 360;
                        break;
                    default:
                        break;
                }

                updateHUD();
            }
        });

        // ============================
        // Kamera Bewegung via Tastatur
        // ============================
        // PointerLockControls handle keyboard controls (W/A/S/D, Q/E)
        // Zusätzlich: 'F' Taste und Space für UI-Toggle

        // ============================
        // Toggle Controls Visibility
        // ============================
        let controlsVisible = true;

        function toggleControlsVisibility() {
            controlsVisible = !controlsVisible;
            document.querySelector('.controls').classList.toggle('hidden', !controlsVisible);
            document.querySelector('.instructions').classList.toggle('hidden', !controlsVisible);
        }

        // ============================
        // Reset Camera Funktion
        // ============================
        function resetCamera() {
            // Setze die Kamera-Position zurück
            controls.getObject().position.set(0, 0, 15);
            camera.lookAt(0, 0, 0);
            updateHUD();

            // Entsperre den Pointer Lock
            controls.unlock();
        }

        // ============================
        // Animation Loop
        // ============================
        const clock = new THREE.Clock();
        let startTime = Date.now();

        function animate() {
            requestAnimationFrame(animate);

            // Kamera Bewegung wird von PointerLockControls gehandhabt
            controls.update();

            const elapsed = (Date.now() - startTime) / 1000; // Sekunden seit Start

            // Berechne die Position basierend auf Sinus und Cosinus
            const radiansSin = THREE.MathUtils.degToRad(phaseSin);
            const radiansCos = THREE.MathUtils.degToRad(phaseCos);
            const xOsc = amplitudeSin * Math.sin(2 * Math.PI * frequencySin * elapsed + radiansSin);
            const yOsc = amplitudeCos * Math.cos(2 * Math.PI * frequencyCos * elapsed + radiansCos);

            // Setze die Position des Oszillators
            oscillator.position.set(xOsc, yOsc, 0);

            // Update Trail
            updateTrail(oscillator.position.clone());

            // Fade out the trail by reducing alpha values
            for (let i = 0; i < trailAlphasArray.length; i++) {
                trailAlphasArray[i] *= 0.99; // Dämpfungsfaktor für Alpha
                if (trailAlphasArray[i] < 0.01) {
                    trailAlphasArray[i] = 0.0;
                }
            }
            trailGeometry.attributes.alpha.needsUpdate = true;

            renderer.render(scene, camera);
        }

        animate();

        // ============================
        // Reset-Button Logik
        // ============================
        document.getElementById('reset-button').addEventListener('click', () => {
            resetCamera();

            // Setze alle Parameter zurück
            frequencySin = defaultParams.frequencySin;
            amplitudeSin = defaultParams.amplitudeSin;
            phaseSin = defaultParams.phaseSin;
            frequencyCos = defaultParams.frequencyCos;
            amplitudeCos = defaultParams.amplitudeCos;
            phaseCos = defaultParams.phaseCos;

            updateHUD();

            // Setze die Position des Oszillators zurück
            oscillator.position.set(0, 0, 0);

            // Setze die Startzeit zurück
            startTime = Date.now();

            // Leere den Trail
            trailIndex = 0;
            for (let i = 0; i < trailGeometry.attributes.position.array.length; i++) {
                trailGeometry.attributes.position.array[i] = 0;
                trailAlphasArray[i] = 0.0;
            }
            trailGeometry.attributes.position.needsUpdate = true;
            trailGeometry.attributes.alpha.needsUpdate = true;

            // Zeige die Steuerungselemente wieder an, falls versteckt
            if (!controlsVisible) {
                toggleControlsVisibility();
            }

            // Entsperre den Pointer Lock, falls gesperrt
            controls.unlock();
        });

        // ============================
        // Keyboard Events
        // ============================
        window.addEventListener('keydown', (event) => {
            // Leertaste (Space) zum Ein-/Ausblenden der Steuerungselemente
            if (event.code === 'Space') {
                event.preventDefault(); // Verhindert das Scrollen der Seite
                toggleControlsVisibility();
            }

            // 'F' Taste zum Zurücksetzen der Kamera-Perspektive
            if (event.key === 'f' || event.key === 'F') {
                resetCamera();
            }
        });

        window.addEventListener('keyup', (event) => {
            // Optional: Weitere Tastaturaktionen hier einfügen
        });

    </script>
</body>

</html>
