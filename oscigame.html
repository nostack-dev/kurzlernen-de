<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <title>Sinus und Cosinus Oscillator Spiel</title>
    <style>
        /* Basisstile */
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            background-color: #1e1e1e;
        }

        /* Canvas für Three.js */
        #oscillator-canvas {
            display: block;
        }
    </style>
</head>

<body>
    <!-- Three.js Canvas -->
    <canvas id="oscillator-canvas"></canvas>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Haupt-JavaScript -->
    <script>
        // ============================
        // Three.js Setup
        // ============================
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 15);

        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('oscillator-canvas'),
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 1); // Schwarzer Hintergrund

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // ============================
        // Beleuchtung hinzufügen
        // ============================
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1);
        camera.add(pointLight);
        scene.add(camera);

        // ============================
        // Parameter und Einstellungen
        // ============================
        const defaultParams = {
            frequencySin: 1.00, // Hz
            amplitudeSin: 1.00,
            phaseSin: 0.00, // in Grad
            frequencyCos: 1.00, // Hz (anders als Sinus für verschiedene Muster)
            amplitudeCos: 1.00,
            phaseCos: 0.00 // in Grad
        };

        let frequencySin = defaultParams.frequencySin;
        let amplitudeSin = defaultParams.amplitudeSin;
        let phaseSin = defaultParams.phaseSin;
        let frequencyCos = defaultParams.frequencyCos;
        let amplitudeCos = defaultParams.amplitudeCos;
        let phaseCos = defaultParams.phaseCos;

        // ============================
        // Oszillator erstellen
        // ============================
        const oscillatorMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 0.8,
            metalness: 0.5,
            roughness: 0.1,
            transparent: true,
            opacity: 0.7,
        });

        const oscillatorGeometry = new THREE.SphereGeometry(0.01,0.01,0); // Kleinere Sphere
        const oscillator = new THREE.Mesh(oscillatorGeometry, oscillatorMaterial);
        oscillator.position.set(0, 0, 0);
        scene.add(oscillator);

        // ============================
        // Trail (Spur) hinzufügen mit Fade-Out
        // ============================
        const trailGeometry = new THREE.BufferGeometry();
        const maxTrailPoints = 500;
        const trailPositions = new Float32Array(maxTrailPoints * 3);
        const trailAlphas = new Float32Array(maxTrailPoints * 1); // Alpha-Werte für jeden Punkt

        // Initialisiere Positionen und Alphas
        for (let i = 0; i < maxTrailPoints; i++) {
            trailPositions[i * 3] = 0;
            trailPositions[i * 3 + 1] = 0;
            trailPositions[i * 3 + 2] = 0;
            trailAlphas[i] = 0;
        }

        trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
        trailGeometry.setAttribute('alpha', new THREE.BufferAttribute(trailAlphas, 1));

        // Shader Material für Spur mit Alpha-Fade-Out
        const trailMaterial = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0x00ff00) },
                opacity: { value: 1.0 }
            },
            vertexShader: `
                attribute float alpha;
                varying float vAlpha;
                void main() {
                    vAlpha = alpha;
                    gl_PointSize = 5.0;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                uniform float opacity;
                varying float vAlpha;
                void main() {
                    gl_FragColor = vec4(color, vAlpha * opacity);
                }
            `,
            transparent: true,
            depthWrite: false
        });

        const trail = new THREE.Points(trailGeometry, trailMaterial);
        scene.add(trail);
        let trailIndex = 0;

        function updateTrail(position) {
            // Setze die neue Position
            trailPositions[trailIndex * 3] = position.x;
            trailPositions[trailIndex * 3 + 1] = position.y;
            trailPositions[trailIndex * 3 + 2] = position.z;

            // Setze den Alpha-Wert auf maximal (1.0)
            trailAlphas[trailIndex] = 1.0;

            // Aktualisiere den Index
            trailIndex = (trailIndex + 1) % maxTrailPoints;

            // Aktualisiere die BufferAttributes
            trailGeometry.attributes.position.needsUpdate = true;
            trailGeometry.attributes.alpha.needsUpdate = true;
        }

        // ============================
        // Dragging-Mechanik für Parameter (Rechte Maustaste)
        // ============================
        let isRightDragging = false;
        let rightStartMouse = new THREE.Vector2();
        let dragType = null; // 'sin_frequency', 'sin_amplitude', 'sin_phase', 'cos_frequency', 'cos_amplitude', 'cos_phase'

        // Verhindert das Kontextmenü bei Rechtsklick
        renderer.domElement.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        }, false);

        renderer.domElement.addEventListener('mousedown', (event) => {
            if (event.button === 2) { // Rechte Maustaste
                isRightDragging = true;
                rightStartMouse.set(event.clientX, event.clientY);
            }
        });

        renderer.domElement.addEventListener('mousemove', (event) => {
            if (!isRightDragging) return;
            // Optional: Implementiere visuelles Feedback während des Dragging
        });

        renderer.domElement.addEventListener('mouseup', (event) => {
            if (event.button !== 2) return; // Nur rechte Maustaste
            if (!isRightDragging) return;
            isRightDragging = false;

            const endMouse = new THREE.Vector2(event.clientX, event.clientY);
            const dragVector = new THREE.Vector2().subVectors(endMouse, rightStartMouse);

            const dragDistance = dragVector.length();
            if (dragDistance < 10) {
                // Kleine Drags ignorieren
                return;
            }

            const isHorizontal = Math.abs(dragVector.x) > Math.abs(dragVector.y);

            // Bestimme Drag-Typ basierend auf Modifier-Tasten
            if (event.altKey) {
              
                if (isHorizontal) {
                    dragType = 'cos_amplitude';
                } else {
                    dragType = 'sin_amplitude';
                }
            } else if (event.ctrlKey) {
                // Mit Strg-Taste: Ändert die Phase
                if (isHorizontal) {
                    dragType = 'cos_phase';
                } else {
                    dragType = 'sin_phase';
                }
            } else {

           
                if (isHorizontal) {
                    dragType = 'cos_frequency';
                } else {
                    dragType = 'sin_frequency';
                }
            }

            const delta = isHorizontal ? dragVector.x : -dragVector.y;

            // Ändere die entsprechenden Parameter
            switch (dragType) {
                case 'sin_frequency':
                    frequencySin += delta * 0.005;
                    frequencySin = Math.max(0.1, frequencySin); // Mindestfrequenz
                    break;
                case 'cos_frequency':
                    frequencyCos += delta * 0.005;
                    frequencyCos = Math.max(0.1, frequencyCos); // Mindestfrequenz
                    break;
                case 'sin_amplitude':
                    amplitudeSin += delta * 0.005;
                    amplitudeSin = Math.max(0.1, amplitudeSin); // Mindestamplitude
                    break;
                case 'cos_amplitude':
                    amplitudeCos += delta * 0.005;
                    amplitudeCos = Math.max(0.1, amplitudeCos); // Mindestamplitude
                    break;
                case 'sin_phase':
                    phaseSin += delta * 1.0;
                    phaseSin %= 360;
                    if (phaseSin < 0) phaseSin += 360;
                    break;
                case 'cos_phase':
                    phaseCos += delta * 1.0;
                    phaseCos %= 360;
                    if (phaseCos < 0) phaseCos += 360;
                    break;
                default:
                    break;
            }



            dragType = null;
        });

        // ============================
        // Kamerabewegung via Tastatur (Shooter-Stil)
        // ============================
        const moveSpeed = 10.0; // Geschwindigkeit der Kamera (Einheiten pro Sekunde)
        const moveFlags = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            up: false,
            down: false
        };

        const keyMappings = {
            'w': 'forward',
            'W': 'forward',
            's': 'backward',
            'S': 'backward',
            'a': 'left',
            'A': 'left',
            'd': 'right',
            'D': 'right',
            'q': 'down',
            'Q': 'down',
            'e': 'up',
            'E': 'up'
        };

        window.addEventListener('keydown', (event) => {
            const key = event.key;
            if (keyMappings[key] !== undefined) {
                moveFlags[keyMappings[key]] = true;
            }

            // 'F' Taste zum Zurücksetzen der Kamera-Perspektive
            if (event.key === 'f' || event.key === 'F') {
                resetCamera();
            }
        });

        window.addEventListener('keyup', (event) => {
            const key = event.key;
            if (keyMappings[key] !== undefined) {
                moveFlags[keyMappings[key]] = false;
            }
        });

        // ============================
        // Reset Funktion via Tastendruck 'F'
        // ============================
        function resetCamera() {
            // Setze die Kamera-Position zurück
            camera.position.set(0, 0, 15);
            camera.lookAt(centerOfMass);

            // Setze alle Parameter zurück
            frequencySin = defaultParams.frequencySin;
            amplitudeSin = defaultParams.amplitudeSin;
            phaseSin = defaultParams.phaseSin;
            frequencyCos = defaultParams.frequencyCos;
            amplitudeCos = defaultParams.amplitudeCos;
            phaseCos = defaultParams.phaseCos;

            // Setze die Startzeit zurück
            startTime = Date.now();

            // Leere den Trail
            trailIndex = 0;
            for (let i = 0; i < trailGeometry.attributes.position.array.length; i++) {
                trailGeometry.attributes.position.array[i] = 0;
                trailAlphas[i] = 0.0;
            }
            trailGeometry.attributes.position.needsUpdate = true;
            trailGeometry.attributes.alpha.needsUpdate = true;
        }

        // ============================
        // Center of Mass Berechnung
        // ============================
        let centerOfMass = new THREE.Vector3(0, 0, 0); // Initialer Schwerpunkt

        // ============================
        // Animation Loop
        // ============================
        const clockAnim = new THREE.Clock();
        let startTime = Date.now();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clockAnim.getDelta();

            // Kamera Bewegung basierend auf Tastatureingaben
            const moveDistance = moveSpeed * delta;

            // Richtung von der Kamera zum Objekt
            const direction = new THREE.Vector3();
            direction.subVectors(oscillator.position, camera.position).normalize();

            // Rechte Seite berechnen
            const right = new THREE.Vector3();
            right.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();

            // Up-Vektor
            const up = new THREE.Vector3(0, 1, 0);

            if (moveFlags.forward) {
                camera.position.add(direction.clone().multiplyScalar(moveDistance));
            }
            if (moveFlags.backward) {
                camera.position.sub(direction.clone().multiplyScalar(moveDistance));
            }
            if (moveFlags.left) {
                camera.position.sub(right.clone().multiplyScalar(moveDistance));
            }
            if (moveFlags.right) {
                camera.position.add(right.clone().multiplyScalar(moveDistance));
            }
            if (moveFlags.up) {
                camera.position.add(up.clone().multiplyScalar(moveDistance));
            }
            if (moveFlags.down) {
                camera.position.sub(up.clone().multiplyScalar(moveDistance));
            }

            // Berechne die Position basierend auf Sinus und Cosinus
            const elapsed = (Date.now() - startTime) / 1000; // Sekunden seit Start

            const radiansSin = THREE.Math.degToRad(phaseSin);
            const radiansCos = THREE.Math.degToRad(phaseCos);
            const xOsc = amplitudeSin * Math.sin(2 * Math.PI * frequencySin * elapsed + radiansSin);
            const yOsc = amplitudeCos * Math.cos(2 * Math.PI * frequencyCos * elapsed + radiansCos);

            // Setze die Position des Oszillators
            oscillator.position.set(xOsc, yOsc, 0);

            // Update Trail
            updateTrail(oscillator.position.clone());

            // Fade out the trail by reducing alpha values
            for (let i = 0; i < maxTrailPoints; i++) {
                trailAlphas[i] *= 0.99; // Dämpfungsfaktor für Alpha
                if (trailAlphas[i] < 0.01) {
                    trailAlphas[i] = 0.0;
                }
            }
            trailGeometry.attributes.alpha.needsUpdate = true;

            // Update Center of Mass mit einer laufenden Durchschnittsberechnung
            const alpha = 0.01; // Smoothing-Faktor (zwischen 0 und 1)
          //  centerOfMass.lerp(oscillator.position, alpha);

            // Kamera immer auf den Schwerpunkt richten
            camera.lookAt(centerOfMass);

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>
