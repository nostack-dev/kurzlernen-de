<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mogul P2P Sync</title>
    <!--
        FINALE VERSION: Mogul P2P Chef Sync
        Architektur: Zero-Trust, Serverless, Passkey (WebAuthn) & P2P (WebRTC)
        Session-Logik: Hybrid-Speicherung des UK im sessionStorage mit 30-Minuten Inaktivitäts-Timeout.
    -->
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.10/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <style>
        :root {
            font-family: 'Inter', sans-serif;
            --theme-bg: oklch(100% 0 0);
            --theme-text: oklch(0% 0 0);
        }
        html[data-theme="corporate"] {
            --theme-bg: oklch(100% 0 0);
            --theme-text: oklch(0% 0 0);
        }
        body {
            background-color: var(--theme-bg);
            color: var(--theme-text);
            min-height: 100vh;
        }
    </style>
</head>
<body data-theme="corporate">

    <div class="p-8 max-w-4xl mx-auto">
        <h1 class="text-3xl font-bold mb-4 flex items-center gap-2">
            Mogul P2P CHEF Sync 
            <span id="mogul-id-display" class="badge badge-lg badge-neutral text-sm">Lade...</span>
        </h1>
        
        <!-- Status & Device Management -->
        <div class="bg-base-200 p-6 rounded-lg shadow-xl mb-6">
            <h2 class="text-xl font-semibold mb-3">System-Status</h2>
            <div id="sync-status" class="text-lg font-mono text-success">Initialisierung...</div>

            <div class="mt-6">
                <h3 class="text-lg font-medium mb-2">Geräte-IDs (Whitelist)</h3>
                <div id="device-list" class="flex flex-wrap gap-2 mb-3 min-h-8">
                    <!-- Geräte-Badges werden hier eingefügt -->
                </div>
                <div class="flex gap-2">
                    <input type="text" id="new-device-id-input" placeholder="Neue Geräte-ID hinzufügen (z.B. Handy-ID)" class="input input-bordered w-full max-w-xs" />
                    <button id="add-device-btn" class="btn btn-primary">Hinzufügen</button>
                </div>
            </div>
        </div>

        <!-- P2P-Sync Button -->
        <div class="flex justify-center mb-6">
            <button id="p2p-modal-btn" class="btn btn-lg btn-secondary shadow-lg">
                P2P-Sync starten (Gerät koppeln)
            </button>
        </div>
        
        <!-- Log Bereich -->
        <div class="bg-base-200 p-6 rounded-lg shadow-xl">
            <h2 class="text-xl font-semibold mb-3">Aktivitäts-Protokoll </h2>
            <textarea id="log-output" class="textarea textarea-bordered w-full h-48 font-mono text-xs" readonly>Warte auf Passkey-Authentifizierung...</textarea>
        </div>
    </div>
    
    <!-- Modals -->

    <!-- 1. AUTH / PASSKEY Modal -->
    <dialog id="auth_modal" class="modal">
        <div class="modal-box">
            <h3 id="auth-title" class="font-bold text-xl mb-4">Anmeldung erforderlich</h3>
            <p id="auth-message" class="py-4">Bitte registrieren Sie sich oder melden Sie sich mit Ihrem Passkey an, um den Universal Key (UK) abzuleiten und die Synchronisation zu starten.</p>
            <div id="auth-view-register" class="flex flex-col gap-3">
                <input type="text" id="passkey-name" placeholder="Passkey-Name (z.B. 'Christian PC')" class="input input-bordered w-full" />
                <button id="register-btn" class="btn btn-success">Passkey registrieren</button>
            </div>
            <div id="auth-view-login" class="flex flex-col gap-3 hidden">
                <button id="login-btn" class="btn btn-primary">Mit Passkey anmelden</button>
            </div>
        </div>
        <form method="dialog" class="modal-backdrop">
            <button>schließen</button>
        </form>
    </dialog>

    <!-- 2. P2P-Sync Modal (Steve Jobs Style) -->
    <dialog id="p2p_modal" class="modal">
        <div class="modal-box w-11/12 max-w-2xl bg-white shadow-2xl rounded-xl">
            <h3 class="font-extrabold text-3xl mb-4 text-primary">Mogul P2P Sync. Einfach. Sofort.</h3>
            <p class="text-lg mb-6 text-gray-700">Wählen Sie, ob Sie Daten von diesem Gerät **senden** oder **empfangen** möchten.</p>

            <div role="tablist" class="tabs tabs-boxed bg-gray-100 p-1 rounded-lg mb-4">
                
                <!-- Tab 1: Senden (Offer) -->
                <input type="radio" name="p2p_tabs" role="tab" class="tab font-semibold" aria-label="Daten senden (Offer)" id="tab-offer" checked />
                <div role="tabpanel" class="tab-content bg-white border border-gray-200 rounded-box p-6 shadow-inner">
                    <h4 class="text-xl font-bold mb-3 text-secondary">Daten senden (Gerät A)</h4>
                    <p class="text-sm mb-4 text-gray-600">Dieses Gerät generiert den Start-Code (`Offer`).</p>
                    
                    <div class="space-y-4">
                        <div>
                            <span class="badge badge-info text-md font-bold">SCHRITT 1: OFFER ERSTELLEN</span>
                            <p class="text-xs mt-1 mb-2">Generieren Sie den geheimen Start-Code. Senden Sie ihn an Gerät B.</p>
                            <textarea id="p2p-offer-output" class="textarea textarea-bordered w-full h-24 font-mono text-sm" readonly placeholder="Offer Code wird hier generiert..."></textarea>
                            <button id="p2p-create-offer-btn" class="btn btn-sm btn-info w-full mt-2">Offer Code generieren</button>
                        </div>
                        
                        <div class="divider"></div>
                        
                        <div>
                            <span class="badge badge-success text-md font-bold">SCHRITT 2: ANTWORT AKZEPTIEREN</span>
                            <p class="text-xs mt-1 mb-2">Fügen Sie den Antwort-Code (`Answer`) von Gerät B hier ein, um den Sync zu starten.</p>
                            <textarea id="p2p-answer-input" class="textarea textarea-bordered w-full h-24 font-mono text-sm" placeholder="Fügen Sie den Answer Code hier ein..."></textarea>
                            <button id="p2p-accept-answer-btn" class="btn btn-sm btn-success w-full mt-2">Answer Code akzeptieren & SYNC STARTEN</button>
                        </div>
                    </div>
                </div>

                <!-- Tab 2: Empfangen (Answer) -->
                <input type="radio" name="p2p_tabs" role="tab" class="tab font-semibold" aria-label="Daten empfangen (Answer)" id="tab-answer" />
                <div role="tabpanel" class="tab-content bg-white border border-gray-200 rounded-box p-6 shadow-inner">
                    <h4 class="text-xl font-bold mb-3 text-secondary">Daten empfangen (Gerät B)</h4>
                    <p class="text-sm mb-4 text-gray-600">Dieses Gerät empfängt den Start-Code und antwortet mit dem Rück-Code (`Answer`).</p>

                    <div class="space-y-4">
                        <div>
                            <span class="badge badge-warning text-md font-bold">SCHRITT 1: OFFER CODE EINFÜGEN</span>
                            <p class="text-xs mt-1 mb-2">Fügen Sie den Start-Code (`Offer`) von Gerät A hier ein.</p>
                            <textarea id="p2p-offer-input" class="textarea textarea-bordered w-full h-24 font-mono text-sm" placeholder="Fügen Sie den Offer Code hier ein..."></textarea>
                            <button id="p2p-create-answer-btn" class="btn btn-sm btn-warning w-full mt-2">Answer Code generieren</button>
                        </div>
                        
                        <div class="divider"></div>
                        
                        <div>
                            <span class="badge badge-info text-md font-bold">SCHRITT 2: ANSWER CODE SENDEN</span>
                            <p class="text-xs mt-1 mb-2">Senden Sie den generierten Antwort-Code an Gerät A. Der Sync beginnt.</p>
                            <textarea id="p2p-answer-output" class="textarea textarea-bordered w-full h-24 font-mono text-sm" readonly placeholder="Answer Code wird hier generiert..."></textarea>
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal-action">
                <form method="dialog">
                    <button class="btn btn-ghost">Abbrechen</button>
                </form>
            </div>
        </div>
    </dialog>

    <script>
        // --- Globale Konstanten & Variablen ---
        
        const WRAPPED_UK_KEY = 'mogul_uk';           
        const PASSKEY_ID_KEY = 'mogul_passkey_id';   
        const DEVICE_LIST_KEY = 'mogul_device_list'; 
        const DB_HASH_KEY = 'mogul_db_hash';         
        
        const SESSION_TIMEOUT_MS = 30 * 60 * 1000;
        const SESSION_EXPIRY_KEY = 'mogul_session_expires';

        let currentUniversalKey = null; 
        let userId = 'MogulCHEF';      
        let deviceList = [];           
        let db = {
            data: 'Dies ist die initiale Datenbank. Alle vertraulichen Inhalte werden mit dem UK verschlüsselt.',
            version: 1
        }; 

        // DOM-Elemente
        const auth_modal = document.getElementById('auth_modal');
        const p2p_modal = document.getElementById('p2p_modal');
        const log_output = document.getElementById('log-output');
        const mogul_id_display = document.getElementById('mogul-id-display');
        const auth_title = document.getElementById('auth-title');
        const auth_message = document.getElementById('auth-message');
        
        // P2P State
        let p2pIsOffer = true; 

        // --- Hilfsfunktionen für Base64URL und ArrayBuffer ---

        function base64UrlToUint8Array(base64Url) {
            const padding = '='.repeat((4 - base64Url.length % 4) % 4);
            const base64 = (base64Url + padding)
                .replace(/\-/g, '+')
                .replace(/_/g, '/');
            const rawData = window.atob(base64);
            return Uint8Array.from(rawData.split('').map(char => char.charCodeAt(0)));
        }

        function arrayBufferToBase64Url(buffer) {
            const base64 = window.btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)));
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }

        function log(message, isError = false) {
            const timestamp = new Date().toLocaleTimeString('de-DE');
            const prefix = isError ? '[FEHLER] ' : '[INFO] ';
            log_output.value += `\n${timestamp} ${prefix} ${message}`;
            log_output.scrollTop = log_output.scrollHeight;
            if (isError) console.error(message);
        }

        function updateSyncStatus(message, isError = false) {
            const statusElement = document.getElementById('sync-status');
            statusElement.textContent = message;
            statusElement.className = isError 
                ? 'text-lg font-mono text-error' 
                : 'text-lg font-mono text-success';
        }

        // --- 1. Passkey / Zero-Trust Core Logik (WebAuthn) ---

        const HKDF_ALG = { 
            name: "HKDF", 
            hash: "SHA-256", 
            salt: new Uint8Array([0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07]), 
            info: new TextEncoder().encode("mogul-universal-key-derivation")
        };
        const UK_LENGTH = 32; 

        async function deriveUniversalKey(credentialId) {
            log('Leite Universal Key (UK) aus der Passkey-ID ab...');
            const masterKey = await crypto.subtle.importKey(
                "raw",
                base64UrlToUint8Array(credentialId).buffer, 
                HKDF_ALG.name,
                false,
                ["deriveKey"]
            );

            const derivedKey = await crypto.subtle.deriveKey(
                HKDF_ALG,
                masterKey,
                { name: "AES-GCM", length: 256 }, 
                true, 
                ["encrypt", "decrypt"]
            );
            
            const keyBytes = await crypto.subtle.exportKey("raw", derivedKey);
            log('UK-Ableitung erfolgreich. Länge: ' + keyBytes.byteLength + ' Bytes');
            return keyBytes;
        }


        async function startPasskeyRegistration() {
            try {
                const passkeyName = document.getElementById('passkey-name').value.trim();
                if (!passkeyName) {
                    auth_message.textContent = "Bitte geben Sie einen Namen für Ihren Passkey ein.";
                    return;
                }
                
                log('Starte Passkey Registrierung...');

                const challengeBytes = crypto.getRandomValues(new Uint8Array(32)); 
                const userIdBytes = crypto.getRandomValues(new Uint8Array(16));    

                const publicKeyCredentialCreationOptions = {
                    rp: { id: window.location.hostname, name: "Mogul P2P Sync" },
                    user: {
                        id: userIdBytes.buffer, 
                        name: passkeyName,
                        displayName: passkeyName
                    },
                    challenge: challengeBytes.buffer, 
                    pubKeyCredParams: [{ alg: -7, type: "public-key" }], 
                    timeout: 60000,
                    attestation: "direct",
                    authenticatorSelection: {
                        authenticatorAttachment: "cross-platform",
                        userVerification: "required",
                        residentKey: "required"
                    }
                };

                const credential = await navigator.credentials.create({ publicKey: publicKeyCredentialCreationOptions });
                
                const credentialId = arrayBufferToBase64Url(credential.rawId);
                localStorage.setItem(PASSKEY_ID_KEY, credentialId);
                log(`Passkey erfolgreich registriert. ID gespeichert in localStorage.`);

                const keyBytes = await deriveUniversalKey(credentialId);
                const universalKey = arrayBufferToBase64Url(keyBytes);
                
                currentUniversalKey = universalKey;
                
                sessionStorage.setItem(WRAPPED_UK_KEY, universalKey);
                sessionStorage.setItem(SESSION_EXPIRY_KEY, Date.now() + SESSION_TIMEOUT_MS);
                log('Universal Key in sessionStorage für die Sitzungsdauer gespeichert.');

                auth_modal.close();
                initializeSyncContinuation(false);

            } catch (e) {
                log('Passkey Registrierung fehlgeschlagen: ' + e.message, true);
                auth_message.textContent = `Registrierung fehlgeschlagen: ${e.message}. Versuchen Sie es erneut.`;
            }
        }

        async function startPasskeyAssertion() {
            try {
                const credentialId = localStorage.getItem(PASSKEY_ID_KEY);
                if (!credentialId) {
                    log('Keine Passkey-ID gefunden. Bitte zuerst registrieren.', true);
                    return;
                }

                log('Starte Passkey Anmeldung...');
                
                const challengeBytes = crypto.getRandomValues(new Uint8Array(32)); 

                const publicKeyCredentialRequestOptions = {
                    challenge: challengeBytes.buffer, 
                    allowCredentials: [{
                        id: base64UrlToUint8Array(credentialId).buffer, 
                        type: 'public-key',
                        transports: ['usb', 'nfc', 'ble', 'internal']
                    }],
                    userVerification: "required",
                    timeout: 60000
                };

                const credential = await navigator.credentials.get({ publicKey: publicKeyCredentialRequestOptions });
                
                const assertedId = arrayBufferToBase64Url(credential.rawId);
                if (assertedId !== credentialId) {
                    throw new Error("Asserted ID stimmt nicht mit gespeicherter ID überein.");
                }

                log('Passkey erfolgreich verifiziert.');

                const keyBytes = await deriveUniversalKey(credentialId);
                const universalKey = arrayBufferToBase64Url(keyBytes);

                currentUniversalKey = universalKey;
                
                sessionStorage.setItem(WRAPPED_UK_KEY, universalKey);
                sessionStorage.setItem(SESSION_EXPIRY_KEY, Date.now() + SESSION_TIMEOUT_MS);
                log('Universal Key in sessionStorage für die Sitzungsdauer gespeichert.');

                auth_modal.close();
                initializeSyncContinuation(false);

            } catch (e) {
                log('Passkey Anmeldung fehlgeschlagen: ' + e.message, true);
                auth_message.textContent = `Anmeldung fehlgeschlagen: ${e.message}. Versuchen Sie es erneut.`;
            }
        }

        // --- 2. Initialisierungs- & Status-Logik ---

        function loadState() {
            const storedDevices = localStorage.getItem(DEVICE_LIST_KEY);
            if (storedDevices) {
                deviceList = JSON.parse(storedDevices);
            }
            renderDeviceList();

            const storedDbHash = localStorage.getItem(DB_HASH_KEY);
            if (storedDbHash) {
                log(`Datenbank-Hash aus localStorage: ${storedDbHash}`);
            }
            
            mogul_id_display.textContent = userId;
        }

        function setupActivityMonitor() {
            setInterval(() => {
                const sessionExpires = Number(sessionStorage.getItem(SESSION_EXPIRY_KEY) || 0);
                if (sessionExpires > 0 && sessionExpires < Date.now()) {
                    sessionStorage.removeItem(WRAPPED_UK_KEY);
                    sessionStorage.removeItem(SESSION_EXPIRY_KEY);
                    
                    currentUniversalKey = null;
                    auth_modal.showModal(); 
                    auth_title.textContent = "Sitzung abgelaufen";
                    auth_message.textContent = "Ihre Sitzung ist aufgrund von Inaktivität abgelaufen. Bitte melden Sie sich erneut mit Ihrem Passkey an.";
                    document.getElementById('auth-view-login').classList.remove('hidden');
                    document.getElementById('auth-view-register').classList.add('hidden');
                    updateSyncStatus("Sitzung abgelaufen. Erneute Anmeldung erforderlich.", true);
                    log("Sitzung aufgrund von Inaktivität abgelaufen.", true);
                }
            }, 60000); 
            log("Inaktivitäts-Monitor gestartet (30 Min Timeout).");
        }


        async function initializePasskeyFlow() {
            const sessionUK = sessionStorage.getItem(WRAPPED_UK_KEY);
            const sessionExpires = Number(sessionStorage.getItem(SESSION_EXPIRY_KEY) || 0);

            if (sessionUK && sessionExpires > Date.now()) {
                currentUniversalKey = sessionUK;
                log('UK aus Session Storage geladen. Fortfahren ohne erneute Passkey-Assertion.');
                
                auth_modal.close(); 
                return initializeSyncContinuation(true);
            } 
            
            const passkeyId = localStorage.getItem(PASSKEY_ID_KEY);
            auth_modal.showModal();

            if (passkeyId) {
                auth_title.textContent = "Mit Passkey anmelden";
                auth_message.textContent = "Ihr Passkey ist bereits registriert. Bitte melden Sie sich an, um den Universal Key abzuleiten.";
                document.getElementById('auth-view-login').classList.remove('hidden');
                document.getElementById('auth-view-register').classList.add('hidden');
            } else {
                auth_title.textContent = "Passkey registrieren";
                auth_message.textContent = "Dies ist Ihre Erstanmeldung. Bitte registrieren Sie einen Passkey.";
                document.getElementById('auth-view-login').classList.add('hidden');
                document.getElementById('auth-view-register').classList.remove('hidden');
            }
        }
        
        async function initializeSyncContinuation(fromSessionStorage = false) {
            try {
                if (!currentUniversalKey) {
                    log('Fehler: Universal Key fehlt.', true);
                    return;
                }

                if (fromSessionStorage) {
                    sessionStorage.setItem(SESSION_EXPIRY_KEY, Date.now() + SESSION_TIMEOUT_MS);
                    log('Sitzung verlängert bis: ' + new Date(Date.now() + SESSION_TIMEOUT_MS).toLocaleTimeString('de-DE'));
                }
                
                updateSyncStatus("Zero-Trust Authentifiziert. System bereit.");
                log('System voll einsatzbereit. Verschlüsselungs-UK aktiv.');
                
            } catch (e) {
                log('Fehler bei der Initialisierung nach der Anmeldung: ' + e.message, true);
                updateSyncStatus("Initialisierungsfehler", true);
            }
        }


        // --- 3. Mock-Datenbank Logik (Speicherung/Löschung) ---

        function renderDeviceList() {
            const listEl = document.getElementById('device-list');
            listEl.innerHTML = '';
            if (deviceList.length === 0) {
                 listEl.innerHTML = '<span class="text-sm italic text-gray-500">Noch keine vertrauenswürdigen Geräte gespeichert.</span>';
                 return;
            }
            deviceList.forEach(id => {
                const badge = document.createElement('div');
                badge.className = 'badge badge-outline badge-lg';
                badge.textContent = id;
                const removeBtn = document.createElement('span');
                removeBtn.className = 'ml-2 cursor-pointer text-error';
                removeBtn.textContent = '×';
                removeBtn.onclick = () => removeDevice(id);
                badge.appendChild(removeBtn);
                listEl.appendChild(badge);
            });
        }
        
        function addDevice(newId) {
            if (!deviceList.includes(newId)) {
                deviceList.push(newId);
                localStorage.setItem(DEVICE_LIST_KEY, JSON.stringify(deviceList));
                renderDeviceList();
                log(`Geräte-ID "${newId}" zur Whitelist hinzugefügt.`);
            }
        }

        function removeDevice(idToRemove) {
            const newDeviceList = deviceList.filter(id => id !== idToRemove);
            if (newDeviceList.length !== deviceList.length) {
                deviceList = newDeviceList;
                localStorage.setItem(DEVICE_LIST_KEY, JSON.stringify(deviceList));
                renderDeviceList();
                log(`Geräte-ID "${idToRemove}" von der Whitelist entfernt.`);
            }
        }

        // --- 4. WebRTC (P2P) Logik (Vollständig implementiert) ---

        const RTC_CONFIG = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
            ]
        };
        const CHANNEL_NAME = 'mogul-sync-channel';

        let p2pConnection = null; 
        let p2pDataChannel = null; 

        function setupDataChannelListeners(channel) {
            channel.onopen = () => {
                log('P2P Verbindung erfolgreich hergestellt (Data Channel OPEN).');
                updateSyncStatus('P2P verbunden. Bereit zum verschlüsselten Datentransfer.');
                document.getElementById('p2p-offer-output').value = "P2P VERBUNDEN";
                document.getElementById('p2p-answer-output').value = "P2P VERBUNDEN";
                document.getElementById('p2p-answer-input').value = "P2P VERBUNDEN";
                document.getElementById('p2p-offer-input').value = "P2P VERBUNDEN";

                const mockEncryptedData = 'ENCRYPTED_DATA_WITH_UK_' + currentUniversalKey.substring(0, 10);
                channel.send(mockEncryptedData);
                log('Sende mock-verschlüsselte Daten: ' + mockEncryptedData.substring(0, 35) + '...');
                p2p_modal.close();
            };

            channel.onmessage = (event) => {
                const receivedData = event.data;
                log('Empfange Daten: ' + receivedData.substring(0, 35) + '...');
            };

            channel.onclose = () => {
                log('P2P Verbindung getrennt.', true);
                updateSyncStatus('System bereit (P2P getrennt).', false);
                p2pConnection = null;
                p2pDataChannel = null;
            };

            channel.onerror = (error) => {
                log('P2P Data Channel Fehler.', true);
            };
        }

        function combineSignalData(sdp, iceCandidates) {
            return JSON.stringify({ sdp: sdp, ice: iceCandidates });
        }

        function parseSignalData(signalString) {
            try {
                const data = JSON.parse(signalString);
                if (data && data.sdp && Array.isArray(data.ice)) return data;
                throw new Error("Ungültiges Signaling-Datenformat.");
            } catch (e) {
                log("Fehler beim Parsen der P2P-Signalisierung: Ungültiges JSON oder Format.", true);
                return null;
            }
        }

        function createPeerConnection(isOffer) {
            if (p2pConnection) p2pConnection.close();
            
            p2pConnection = new RTCPeerConnection(RTC_CONFIG);
            
            const iceCandidates = [];
            p2pConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    iceCandidates.push(event.candidate);
                }
            };
            
            p2pConnection.onconnectionstatechange = () => {
                log(`Verbindungsstatus: ${p2pConnection.connectionState}`);
                if (p2pConnection.connectionState === 'failed') {
                    p2pConnection.close();
                    log('P2P Verbindung fehlgeschlagen.', true);
                    updateSyncStatus('P2P Fehler: Verbindung fehlgeschlagen.', true);
                }
            };

            if (!isOffer) {
                p2pConnection.ondatachannel = (event) => {
                    p2pDataChannel = event.channel;
                    log('Data Channel von Offer-Gerät empfangen.');
                    setupDataChannelListeners(p2pDataChannel);
                };
            }
            
            return { connection: p2pConnection, iceCandidates: iceCandidates };
        }

        async function p2pCreateOffer() {
            if (!currentUniversalKey) {
                log("Fehler: UK ist für P2P erforderlich. Bitte zuerst anmelden.", true);
                return;
            }
            log("Erstelle P2P Offer...");
            updateSyncStatus('Erstelle P2P Offer...');

            try {
                const { connection, iceCandidates } = createPeerConnection(true);
                p2pDataChannel = connection.createDataChannel(CHANNEL_NAME);
                setupDataChannelListeners(p2pDataChannel);

                const offer = await connection.createOffer();
                await connection.setLocalDescription(offer);

                await new Promise(resolve => {
                    setTimeout(() => {
                        resolve();
                    }, 1500); 
                    connection.onicegatheringstatechange = () => {
                        if (connection.iceGatheringState === 'complete') resolve();
                    };
                });
                
                const signalData = combineSignalData(connection.localDescription.sdp, iceCandidates);
                document.getElementById('p2p-offer-output').value = signalData;
                log('Offer Code generiert (SDP + ICE). Bereit für Gerät B.');
                updateSyncStatus('Offer Code generiert. Warte auf Answer...');

            } catch (e) {
                log('Fehler beim Erstellen des Offers: ' + e.message, true);
            }
        }

        async function p2pAcceptAnswer(answerSignal) {
            if (!p2pConnection) {
                 log("Fehler: Zuerst Offer erstellen.", true);
                 return;
            }
            log("Akzeptiere P2P Answer und starte Verbindung...");
            updateSyncStatus('Verbinde mit Answer-Gerät...');

            try {
                const signalData = parseSignalData(answerSignal);
                if (!signalData) return;

                const remoteDesc = new RTCSessionDescription({
                    type: 'answer',
                    sdp: signalData.sdp
                });

                await p2pConnection.setRemoteDescription(remoteDesc);
                log('Remote Description (Answer) gesetzt.');
                
                for (const candidate of signalData.ice) {
                    await p2pConnection.addIceCandidate(new RTCIceCandidate(candidate));
                }
                log('ICE-Kandidaten vom Answer-Gerät hinzugefügt.');
                
                log('Verbindung wird nun automatisch hergestellt...');

            } catch (e) {
                log('Fehler beim Akzeptieren des Answers: ' + e.message, true);
            }
        }
        
        async function p2pCreateAnswer(offerSignal) {
             if (!currentUniversalKey) {
                log("Fehler: UK ist für P2P erforderlich. Bitte zuerst anmelden.", true);
                return;
            }
            log("Erstelle P2P Answer auf Offer...");
            updateSyncStatus('Erstelle P2P Answer...');

            try {
                const signalData = parseSignalData(offerSignal);
                if (!signalData) return;
                
                const { connection, iceCandidates } = createPeerConnection(false);

                const remoteDesc = new RTCSessionDescription({
                    type: 'offer',
                    sdp: signalData.sdp
                });

                await connection.setRemoteDescription(remoteDesc);
                log('Remote Description (Offer) gesetzt.');
                
                for (const candidate of signalData.ice) {
                    await connection.addIceCandidate(new RTCIceCandidate(candidate));
                }
                log('ICE-Kandidaten vom Offer-Gerät hinzugefügt.');

                const answer = await connection.createAnswer();
                await connection.setLocalDescription(answer);

                await new Promise(resolve => {
                    setTimeout(() => {
                        resolve();
                    }, 1500); 
                    connection.onicegatheringstatechange = () => {
                        if (connection.iceGatheringState === 'complete') resolve();
                    };
                });

                const signalDataAnswer = combineSignalData(connection.localDescription.sdp, iceCandidates);
                document.getElementById('p2p-answer-output').value = signalDataAnswer;
                log('Answer Code generiert (SDP + ICE). Senden Sie diesen an Gerät A.');
                updateSyncStatus('Answer Code generiert. Bereit zum Senden.');

            } catch (e) {
                log('Fehler beim Erstellen des Answers: ' + e.message, true);
            }
        }


        // --- 5. Event Listeners und Start ---

        window.onload = function () {
            loadState();
            
            setupActivityMonitor(); 

            initializePasskeyFlow();

            document.getElementById('register-btn').addEventListener('click', startPasskeyRegistration);
            document.getElementById('login-btn').addEventListener('click', startPasskeyAssertion);

            document.getElementById('add-device-btn').addEventListener('click', () => {
                const newId = document.getElementById('new-device-id-input').value.trim();
                if (newId) {
                    addDevice(newId);
                    document.getElementById('new-device-id-input').value = '';
                }
            });

            document.getElementById('p2p-modal-btn').addEventListener('click', () => {
                 if (!currentUniversalKey) {
                    auth_title.textContent = "Fehlende Anmeldung";
                    auth_message.textContent = "Bitte melden Sie sich zuerst mit Ihrem Passkey an, um P2P-Transfers zu starten.";
                    auth_modal.showModal();
                    return;
                }
                 p2p_modal.showModal();
            });
            
            document.getElementById('p2p-create-offer-btn').addEventListener('click', p2pCreateOffer);
            document.getElementById('p2p-accept-answer-btn').addEventListener('click', () => {
                const answer = document.getElementById('p2p-answer-input').value;
                if (answer) p2pAcceptAnswer(answer);
            });
            
            document.getElementById('p2p-create-answer-btn').addEventListener('click', () => {
                const offer = document.getElementById('p2p-offer-input').value;
                if (offer) p2pCreateAnswer(offer);
            });
            
            document.getElementById('tab-offer').addEventListener('change', () => p2pIsOffer = true);
            document.getElementById('tab-answer').addEventListener('change', () => p2pIsOffer = false);

            console.log('Mogul P2P-CHEF-Sync gestartet...');
        }
    </script>
</body>
</html>
