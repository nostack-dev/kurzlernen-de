<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>kurzlernen.de - 30-Minuten-Herausforderung</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Tailwind CSS und DaisyUI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@2.50.0/dist/full.css" rel="stylesheet" type="text/css" />

    <!-- Tesseract.js -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>

    <!-- JSZip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- FileSaver.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <!-- DaisyUI Theme Configuration -->
    <script>
        // Theme wechseln basierend auf den Systemeinstellungen
        document.addEventListener("DOMContentLoaded", () => {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.setAttribute('data-theme', 'dark');
            } else {
                document.documentElement.setAttribute('data-theme', 'light');
            }
        });
    </script>
</head>
<body class="bg-base-200 text-base-content">
    <!-- Header mit DaisyUI Navbar -->
    <header class="navbar bg-primary text-primary-content">
        <div class="flex-1">
            <a class="btn btn-ghost normal-case text-xl">30-Minuten-Herausforderung</a>
        </div>
        <div class="flex-none">
            <!-- Neues Set an Aufgaben Knopf -->
            <button class="btn btn-accent mr-4" onclick="confirmResetTasks()" id="newTasksBtn">üîÑ Neue Aufgaben</button>
            <!-- Farbschema Toggle -->
            <label class="swap swap-rotate">
                <input type="checkbox" id="theme-toggle" />
                <svg class="swap-on fill-current w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path d="M5.64 17.36A9 9 0 1118.36 6.64 9 9 0 015.64 17.36zM12 7a5 5 0 100 10 5 5 0 000-10z"/>
                </svg>
                <svg class="swap-off fill-current w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path d="M21 12.79A9 9 0 1111.21 3a7 7 0 109.79 9.79z"/>
                </svg>
            </label>
        </div>
    </header>

    <div class="mx-auto p-4 max-w-screen-md">
        <!-- Fortschrittsanzeige -->
        <div class="mt-6 text-center">
            <progress id="overallProgress" class="progress progress-info w-full" value="0" max="3"></progress>
            <p id="progressText" class="mt-2">0 von 3 Aufgaben abgeschlossen</p>
        </div>

        <!-- Aufgaben-Bereich -->
        <div id="tasks" class="mt-6 space-y-4">
            <!-- Aufgabe 1: Lesen -->
            <div id="task1" class="task card shadow-lg bg-base-100">
                <div class="card-body">
                    <!-- Titel, Timer und Start-Button in einer Zeile -->
                    <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center">
                        <div class="flex items-center">
                            <h3 class="card-title">üìñ Aufgabe 1: Lesen</h3>
                            <!-- Timer -->
                            <span id="timer1" class="countdown font-mono text-2xl ml-4">
                                <span id="timer1Minutes" style="--value:10;"></span>:
                                <span id="timer1Seconds" style="--value:00;"></span>
                            </span>
                        </div>
                        <div>
                            <button id="startTask1" class="btn btn-primary flex items-center" onclick="handleTask1ButtonClick()">
                                <span id="startIcon1" class="mr-2">‚ñ∂Ô∏è</span>
                                <span id="startText1">Starten</span>
                            </button>
                        </div>
                    </div>
                    <p id="readText" class="py-4 text-justify">
                        <!-- Platzhalter, wird durch JavaScript ersetzt -->
                    </p>
                    <!-- Fortschrittsbalken, initial verborgen -->
                    <div class="flex items-center justify-between mt-2 hidden" id="task1Progress">
                        <div>
                            <progress id="progress1" class="progress progress-primary w-56" value="100" max="100"></progress>
                        </div>
                    </div>
                    <div id="savedRecording" class="mt-4 hidden">
                        <audio id="audioPlayer" controls class="w-full"></audio>
                        <div class="flex items-center mt-2">
                            <span id="recordingName" class="ml-2">Aufnahme gespeichert</span>
                            <button class="btn btn-error btn-sm ml-auto" onclick="confirmDeleteRecording()">üóëÔ∏è L√∂schen</button>
                        </div>
                    </div>
                    <!-- Alternative Audio Upload -->
                    <div id="alternativeAudioUpload" class="mt-4 hidden">
                        <label for="audioFileUpload" class="btn btn-secondary w-full">üéß Alternativ: Audiodatei hochladen</label>
                        <input id="audioFileUpload" type="file" accept="audio/*" class="hidden" onchange="uploadAudioFile()" />
                    </div>
                    <!-- Abschlie√üen Button -->
                    <div class="mt-4">
                        <button class="btn btn-success w-full mb-2" onclick="confirmCompleteTask(1)">‚úÖ Aufgabe abschlie√üen</button>
                    </div>
                </div>
            </div>

            <!-- Aufgabe 2: Schreiben -->
            <div id="task2" class="task card shadow-lg bg-base-100 hidden">
                <div class="card-body">
                    <!-- Titel, Timer und Start-Button in einer Zeile -->
                    <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center">
                        <div class="flex items-center">
                            <h3 class="card-title">‚úçÔ∏è Aufgabe 2: Abschreiben</h3>
                            <!-- Timer -->
                            <span id="timer2" class="countdown font-mono text-2xl ml-4">
                                <span id="timer2Minutes" style="--value:10;"></span>:
                                <span id="timer2Seconds" style="--value:00;"></span>
                            </span>
                        </div>
                        <div>
                            <button id="startTask2" class="btn btn-primary" onclick="startTask(2)">‚ñ∂Ô∏è Starten</button>
                        </div>
                    </div>
                    <p id="writeText" class="py-4 text-justify">
                        <!-- Platzhalter, wird durch JavaScript ersetzt -->
                    </p>
                    <!-- Fortschrittsbalken, initial verborgen -->
                    <div class="flex items-center justify-between mt-2 hidden" id="task2Progress">
                        <div>
                            <progress id="progress2" class="progress progress-secondary w-56" value="100" max="100"></progress>
                        </div>
                    </div>
                    <p id="handwritingQuality" class="mt-2">Handschriftqualit√§t: <span id="qualityValue">0%</span></p>
                    <label for="proofUpload" class="btn btn-secondary mt-4 w-full">üì∑ Foto der Abschrift aufnehmen</label>
                    <input id="proofUpload" type="file" accept="image/*" capture="camera" class="hidden" onchange="uploadProof()" />
                    <div id="savedProof" class="mt-4 hidden">
                        <div class="flex items-center">
                            <span id="proofName" class="ml-2">Foto hochgeladen</span>
                            <a id="proofPreview" href="#" class="btn btn-info btn-sm ml-auto" target="_blank">üëÅÔ∏è Vorschau</a>
                            <button class="btn btn-error btn-sm ml-2" onclick="confirmDeleteProof()">üóëÔ∏è L√∂schen</button>
                        </div>
                    </div>
                    <!-- Abschlie√üen Button -->
                    <div class="mt-4">
                        <button class="btn btn-success w-full mb-2" onclick="confirmCompleteTask(2)">‚úÖ Aufgabe abschlie√üen</button>
                    </div>
                </div>
            </div>

            <!-- Aufgabe 3: Mathe -->
            <div id="task3" class="task card shadow-lg bg-base-100 hidden">
                <div class="card-body">
                    <!-- Titel, Timer und Start-Button in einer Zeile -->
                    <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center">
                        <div class="flex items-center">
                            <h3 class="card-title">‚ûó Aufgabe 3: Rechenaufgaben</h3>
                            <!-- Timer -->
                            <span id="timer3" class="countdown font-mono text-2xl ml-4">
                                <span id="timer3Minutes" style="--value:10;"></span>:
                                <span id="timer3Seconds" style="--value:00;"></span>
                            </span>
                        </div>
                        <div>
                            <button id="startTask3" class="btn btn-primary" onclick="startTask(3)">‚ñ∂Ô∏è Starten</button>
                        </div>
                    </div>
                    <div id="mathTasks" class="overflow-x-auto mt-4">
                        <!-- Rechenaufgaben werden hier eingef√ºgt -->
                    </div>
                    <!-- Fortschrittsbalken, initial verborgen -->
                    <div class="flex items-center justify-between mt-2 hidden" id="task3Progress">
                        <div>
                            <progress id="progress3" class="progress progress-accent w-56" value="100" max="100"></progress>
                        </div>
                    </div>
                    <!-- Abschlie√üen Button -->
                    <div class="mt-4">
                        <button class="btn btn-success w-full mb-2" onclick="confirmCompleteTask(3)">‚úÖ Aufgabe abschlie√üen</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- Abgabe-Button entfernt -->
    </div>

    <!-- Modale f√ºr Validierungen und Best√§tigungen -->
    <!-- Validierungsmodal -->
    <input type="checkbox" id="validationModal" class="modal-toggle" />
    <div class="modal">
        <div class="modal-box">
            <h3 class="font-bold text-lg" id="modalTitle">Hinweis</h3>
            <p id="validationMessage" class="py-4"></p>
            <div class="modal-action">
                <label for="validationModal" class="btn">Abbrechen</label>
                <button id="modalConfirmButton" class="btn btn-primary hidden">Best√§tigen</button>
            </div>
        </div>
    </div>

    <!-- Best√§tigungsmodal f√ºr das L√∂schen der Aufnahme -->
    <input type="checkbox" id="confirmDeleteRecordingModal" class="modal-toggle" />
    <div class="modal">
        <div class="modal-box">
            <h3 class="font-bold text-lg">Willst du deine Aufnahme wirklich l√∂schen?</h3>
            <p class="py-4">M√∂chtest du die Aufnahme wirklich l√∂schen?</p>
            <div class="modal-action">
                <button class="btn btn-error" onclick="deleteRecording()">Ja, l√∂schen</button>
                <label for="confirmDeleteRecordingModal" class="btn">Abbrechen</label>
            </div>
        </div>
    </div>

    <!-- Best√§tigungsmodal f√ºr das L√∂schen des Beweises -->
    <input type="checkbox" id="confirmDeleteProofModal" class="modal-toggle" />
    <div class="modal">
        <div class="modal-box">
            <h3 class="font-bold text-lg">Foto deiner Abschrift l√∂schen?</h3>
            <p class="py-4">Bist du sicher, dass du das hochgeladene Foto deiner Abschrift l√∂schen m√∂chtest?</p>
            <div class="modal-action">
                <button class="btn btn-error" onclick="deleteProof()">Ja, bitte l√∂schen</button>
                <label for="confirmDeleteProofModal" class="btn">Nein, behalten</label>
            </div>
        </div>
    </div>

    <!-- Best√§tigungsmodal f√ºr das Zur√ºcksetzen -->
    <input type="checkbox" id="confirmResetModal" class="modal-toggle" />
    <div class="modal">
        <div class="modal-box">
            <h3 class="font-bold text-lg">Aufgaben zur√ºcksetzen?</h3>
            <p class="py-4">M√∂chtest du wirklich alle Aufgaben zur√ºcksetzen? Deine bisherigen Fortschritte gehen dadurch verloren.</p>
            <div class="modal-action">
                <button class="btn btn-error" onclick="resetTasks()">Ja, zur√ºcksetzen</button>
                <label for="confirmResetModal" class="btn">Abbrechen</label>
            </div>
        </div>
    </div>

    <!-- Modal f√ºr Mikrofonprobleme -->
    <input type="checkbox" id="micErrorModal" class="modal-toggle" />
    <div class="modal">
        <div class="modal-box">
            <h3 class="font-bold text-lg">Mikrofonproblem</h3>
            <p class="py-4">Es gab ein Problem mit deinem Mikrofon oder es wurde nicht gefunden. Willst du die Aufgabe trotzdem starten und die Audioaufnahme √ºberspringen?</p>
            <div class="modal-action">
                <button class="btn btn-primary" onclick="proceedWithoutMic()">Ja, trotzdem starten</button>
                <label for="micErrorModal" class="btn">Abbrechen</label>
            </div>
        </div>
    </div>

    <!-- Modal f√ºr das Stoppen der Aufnahme -->
    <input type="checkbox" id="confirmStopRecordingModal" class="modal-toggle" />
    <div class="modal">
        <div class="modal-box">
            <h3 class="font-bold text-lg">Aufnahme abschlie√üen?</h3>
            <p class="py-4">Deine Aufnahme wird dann abgeschlossen und zur L√∂sung deiner Aufgabe als Anhang hinzugef√ºgt. M√∂chtest du deine Aufnahme abschlie√üen? </p>
            <div class="modal-action">
                <button class="btn btn-primary" onclick="stopRecording(1)">Ja, beenden</button>
                <label for="confirmStopRecordingModal" class="btn">Abbrechen</label>
            </div>
        </div>
    </div>

    <!-- Modal f√ºr das Neustarten der Aufnahme -->
    <input type="checkbox" id="confirmRestartRecordingModal" class="modal-toggle" />
    <div class="modal">
        <div class="modal-box">
            <h3 class="font-bold text-lg">Aufnahme neu starten?</h3>
            <p class="py-4">M√∂chtest du die Aufnahme neu starten? Deine aktuelle Aufnahme wird dadurch √ºberschrieben.</p>
            <div class="modal-action">
                <button class="btn btn-primary" onclick="restartRecording()">Ja, neu starten</button>
                <label for="confirmRestartRecordingModal" class="btn">Abbrechen</label>
            </div>
        </div>
    </div>

    <!-- Vielen Dank Seite -->
    <div id="thankYouPage" class="hidden">
        <div class="hero min-h-screen bg-base-200">
            <div class="hero-content text-center">
                <div class="max-w-md">
                    <h1 class="text-5xl font-bold">Danke dir!</h1>
                    <p class="py-6">Super! Du hast alle Aufgaben erfolgreich abgeschlossen und abgegeben. Wenn du magst, kannst du deine Aufgaben und deine L√∂sungen hier herunterladen.</p>
                    <button class="btn btn-primary" onclick="downloadZip()">üì• Ergebnisse herunterladen</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Skriptbereich -->
    <script>
        // Globale Variablen und Konstanten
        const taskTimersInitial = [600, 600, 600]; // 10 Minuten f√ºr jede Aufgabe
        let taskTimers = [...taskTimersInitial];
        let taskIntervals = [null, null, null];
        let currentTask = null;
        let currentTaskIndex = null; // Deklaration von currentTaskIndex
        let isRecording = false;
        let recorder;
        let recordedBlobs = [];
        let savedAudioURL = "";
        let savedProofURL = "";
        let storedTasks = {};
        let audioStream; // Variable zum Speichern des Media Streams
        let tasksCompleted = [false, false, false];
        let submitted = false; // Flag f√ºr die Abgabe
        const totalSteps = 3;

        document.addEventListener("DOMContentLoaded", () => {
            if (checkBrowserCompatibility()) {
                loadTasksFromLocalStorage();
            } else {
                console.log("Ihr Browser unterst√ºtzt nicht alle notwendigen Funktionen f√ºr diese Anwendung.");
            }

            // Theme Toggle
            const themeToggle = document.getElementById('theme-toggle');
            // Pr√ºfe das bevorzugte Farbschema des Benutzers
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.setAttribute('data-theme', 'dark');
                themeToggle.checked = true;
            } else {
                document.documentElement.setAttribute('data-theme', 'light');
                themeToggle.checked = false;
            }

            themeToggle.addEventListener('change', function() {
                if (this.checked) {
                    document.documentElement.setAttribute('data-theme', 'dark');
                } else {
                    document.documentElement.setAttribute('data-theme', 'light');
                }
            });

            // Initialisiere die Aufgaben, falls nicht vorhanden
            if (!storedTasks || Object.keys(storedTasks).length === 0) {
                initializeTasks();
            }
        });

        // **Neue Funktion zur Browserkompatibilit√§tspr√ºfung**
  function checkBrowserCompatibility() {
    // √úberpr√ºfen, ob getUserMedia und MediaRecorder verf√ºgbar sind
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        return false;
    }
    if (!window.MediaRecorder) {
        return false;
    }
    if (!window.JSZip) {
        return false;
    }
    return true;
}

        // Funktionen zum Laden, Speichern und Initialisieren der Aufgaben
async function saveTasksToLocalStorage() {
    // Nur die URL des Blobs speichern, nicht den Blob selbst
    if (storedTasks.task1.audioBlob) {
        storedTasks.task1.savedAudioURL = URL.createObjectURL(storedTasks.task1.audioBlob);
        delete storedTasks.task1.audioBlob; // Entfernen Sie den Blob aus dem Objekt
    }

    if (storedTasks.task2.proofDataURL) {
        storedTasks.task2.savedProofURL = URL.createObjectURL(storedTasks.task2.proofDataURL); // Erstellen einer URL f√ºr das Bild
        delete storedTasks.task2.proofDataURL; // Entfernen Sie das Bild-Blob aus dem Objekt
    }

    try {
        localStorage.setItem("tasks", JSON.stringify(storedTasks));
    } catch (error) {
        console.error("Speichern im localStorage fehlgeschlagen:", error);
        showValidationModal("Speichern fehlgeschlagen. Bitte pr√ºfe den verf√ºgbaren Speicherplatz.");
    }
}

        async function loadTasksFromLocalStorage() {
            try {
                const tasksData = localStorage.getItem("tasks");

                if (tasksData) {
                    storedTasks = JSON.parse(tasksData);
                    console.log("Loaded tasks from local storage:", storedTasks);

                    document.getElementById("readText").innerHTML = storedTasks.task1.readText;
                    document.getElementById("writeText").innerHTML = storedTasks.task2.writeText;
                    loadMathTasks(); // Load math tasks

                    tasksCompleted = storedTasks.tasksCompleted || [false, false, false];
                    submitted = storedTasks.submitted || false;
                    savedAudioURL = storedTasks.task1.savedAudioURL || "";
                    savedProofURL = storedTasks.task2.savedProofURL || "";

                    // Laden und Anzeigen der gespeicherten Aufnahme
                    if (savedAudioURL && savedAudioURL !== "") {
                        const audioPlayer = document.getElementById("audioPlayer");
                        audioPlayer.src = savedAudioURL;
                        document.getElementById("recordingName").innerText = "Aufnahme geladen";
                        document.getElementById("savedRecording").classList.remove("hidden");
                    }

                    // Laden und Anzeigen des gespeicherten Beweises
		   if (savedProofURL && savedProofURL !== "") {
                        document.getElementById("proofName").innerText = "Foto geladen";
                        const proofPreview = document.getElementById("proofPreview");
                        proofPreview.href = savedProofURL;
                        proofPreview.classList.remove("hidden");
                        document.getElementById("savedProof").classList.remove("hidden");
                    }

                    updateOverallProgress(); // Update progress display

                    if (submitted) {
                        console.log("Tasks already submitted. Disabling interactions.");
                        disableAllInteractions();
                        showFinalPage();
                    } else if (!tasksCompleted.every(Boolean)) {
                        console.log("Tasks not yet submitted. Displaying the next incomplete task.");
                        displayNextIncompleteTask();
                    }
                } else {
                    console.log("No tasks found in local storage. Initializing tasks.");
                    await initializeTasks();
                }
            } catch (error) {
                console.error("Error loading tasks from local storage:", error);
                await initializeTasks(); // Fallback to initialize tasks if an error occurs
            }
        }

        function initializeTasks() {
            // Aufgaben initialisieren
            const initialReadText = `
            <em>Das geheime Tagebuch</em><br><br>
            Als ich an diesem verregneten Nachmittag auf den Dachboden stieg, erwartete ich nicht, mein Leben f√ºr immer zu ver√§ndern. Zwischen staubigen alten Kisten und vergessenen Erinnerungsst√ºcken entdeckte ich ein ledergebundenes Buch. Es war alt, sehr alt, und der Einband trug keinen Titel. Neugierig √∂ffnete ich es und begann zu lesen.<br><br>
            Die Seiten waren mit handgeschriebenen Notizen gef√ºllt, die von Abenteuern, verborgenen Sch√§tzen und mysteri√∂sen Begegnungen erz√§hlten. Je mehr ich las, desto mehr f√ºhlte ich mich mit dem unbekannten Autor verbunden. War dies das Tagebuch eines meiner Vorfahren? Oder vielleicht das eines v√∂llig Fremden? Eines war sicher: Dies war kein gew√∂hnliches Tagebuch.<br><br>
            Pl√∂tzlich sp√ºrte ich eine leichte Brise, obwohl kein Fenster ge√∂ffnet war. Ein leises Fl√ºstern erf√ºllte den Raum: "Folge den Zeichen..." Mein Herz schlug schneller. Sollte ich dem R√§tsel folgen, das sich vor mir entfaltete? Mit klopfendem Herzen beschloss ich, mich auf das Abenteuer einzulassen.
            `;

            const initialWriteText = `
            <strong>Abschreibtext:</strong><br>
            "Ich konnte kaum glauben, was ich entdeckt hatte. Die Geheimnisse, die in diesem Tagebuch verborgen lagen, schienen √§lter zu sein als unsere Familie selbst. Jeder Satz, jede Zeichnung f√ºhrte mich tiefer in ein Mysterium, das darauf wartete, gel√ºftet zu werden. Mutig entschied ich mich, dem Pfad zu folgen, auch wenn ich nicht wusste, wohin er mich f√ºhren w√ºrde."
            `;

            const mathTasks = [];
            const operators = ["+", "-", "*", "/"];
            for (let i = 0; i < 20; i++) {
                const num1 = Math.floor(Math.random() * 50) + 1;
                let num2 = Math.floor(Math.random() * 50) + 1;
                if (operators[i % 4] === '/') {
                    while (num2 === 0) {
                        num2 = Math.floor(Math.random() * 50) + 1;
                    }
                }
                const operator = operators[i % 4];
                mathTasks.push({ num1, num2, operator, userAnswer: "" });
            }

            storedTasks = {
                task1: {
                    readText: initialReadText,
                    savedAudioURL: "",
                },
                task2: {
                    writeText: initialWriteText,
                    savedProofURL: "",
                },
                task3: {
                    mathTasks: mathTasks,
                },
                tasksCompleted: [false, false, false],
                submitted: false
            };
            saveTasksToLocalStorage();

            document.getElementById("readText").innerHTML = initialReadText;
            document.getElementById("writeText").innerHTML = initialWriteText;
            loadMathTasks();

            document.getElementById("task1").classList.remove("hidden");
            document.getElementById("task2").classList.add("hidden");
            document.getElementById("task3").classList.add("hidden");
        }

        function loadMathTasks() {
            const mathContainer = document.getElementById("mathTasks");
            mathContainer.innerHTML = ''; // Leeren des Containers f√ºr den Neuaufbau

            const mathTasks = storedTasks.task3.mathTasks; // Rechenaufgaben aus den gespeicherten Aufgaben abrufen

            const table = document.createElement("table");
            table.classList.add("table", "w-full", "table-zebra"); // Table-Klassen f√ºr Tailwind/DaisyUI Styling

            const tbody = document.createElement("tbody");

            mathTasks.forEach((task, index) => {
                const tr = document.createElement("tr");

                const tdIndex = document.createElement("td");
                tdIndex.textContent = index + 1;
                tdIndex.classList.add("font-bold");

                const tdTask = document.createElement("td");
                tdTask.textContent = `${task.num1} ${operatorToSymbol(task.operator)} ${task.num2} =`;

                const tdInput = document.createElement("td");
                const input = document.createElement("input");
                input.type = "text";
                input.classList.add("input", "input-bordered", "w-full", "max-w-xs");
                input.dataset.index = index;
                input.value = task.userAnswer || "";
                input.addEventListener('input', function() {
                    if (submitted) return;
                    this.value = this.value.replace(/[^0-9\.\-]/g, ''); // Filtert nicht-numerische Eingaben
                    storedTasks.task3.mathTasks[this.dataset.index].userAnswer = this.value; // Speichern der Benutzerantwort
                    saveTasksToLocalStorage();
                    checkAllTasksCompleted(); // √úberpr√ºfung, ob alle Aufgaben gel√∂st sind
                });
                input.disabled = submitted ? true : false;
                tdInput.appendChild(input);

                tr.appendChild(tdIndex);
                tr.appendChild(tdTask);
                tr.appendChild(tdInput);

                tbody.appendChild(tr);
            });

            table.appendChild(tbody);
            mathContainer.appendChild(table);
        }

        function operatorToSymbol(operator) {
            switch (operator) {
                case '+':
                    return '+';
                case '-':
                    return '‚àí';
                case '*':
                    return '√ó';
                case '/':
                    return '√∑';
                default:
                    return operator;
            }
        }

        // Start- und Stop-Logik f√ºr Aufgabe 1

        function handleTask1ButtonClick() {
            if (isRecording) {
                // Wenn Aufnahme l√§uft, soll Aufnahme gestoppt werden
                confirmStopRecording();
            } else {
                // Wenn keine Aufnahme l√§uft, Aufnahme starten
                startTask(1);
            }
        }

        function startTask(taskIndex) {
            if (submitted) {
                showValidationModal("Aufgaben wurden bereits abgegeben und k√∂nnen nicht mehr gestartet werden.");
                return;
            }

            if (currentTask !== null && currentTask !== taskIndex) {
                showValidationModal("Bitte schlie√üe die aktuelle Aufgabe ab, bevor du eine neue beginnst.");
                return;
            }

            currentTask = taskIndex;

            if (taskIndex === 1) {
                if (savedAudioURL !== "") {
                    document.getElementById("confirmRestartRecordingModal").checked = true;
                    return;
                }

                startRecordingProcess();
            } else if (taskIndex === 2 || taskIndex === 3) {
                const startButton = document.getElementById(`startTask${taskIndex}`);
                startButton.disabled = true;
                startButton.innerText = "‚úÖ L√§uft";

                const progressDiv = document.getElementById(`task${taskIndex}Progress`);
                if (progressDiv) {
                    progressDiv.classList.remove("hidden");
                }

                startTimer(taskIndex); // Timer starten
            }
        }

        function startRecordingProcess() {
            const startButton = document.getElementById("startTask1");
            const startIcon = document.getElementById("startIcon1");
            const startText = document.getElementById("startText1");

            if (!startText) {
                console.error("Element mit ID 'startText1' nicht gefunden.");
                showValidationModal("Interner Fehler: Start-Text nicht gefunden.");
                return;
            }

            startText.innerText = "Aufnahme l√§uft...";
            startIcon.textContent = "‚èπÔ∏è";
            isRecording = true; // Aufnahme l√§uft jetzt

            startRecording().then(() => {
                                     document.getElementById("task1Progress").classList.remove("hidden");
                                     startTimer(1); // Timer starten
            }).catch((error) => {
                startText.innerText = "Starten";
                startIcon.textContent = "‚ñ∂Ô∏è";
                isRecording = false; // Aufnahme nicht gestartet
                if (error.message.includes("Mikrofon")) {
                    document.getElementById("micErrorModal").checked = true;
                } else {
                    showValidationModal("Fehler beim Starten der Aufnahme: " + error.message);
                    currentTask = null;
                }
            });
        }
async function startRecording() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error("Audioaufnahme nicht m√∂glich. Ihr Ger√§t oder Browser unterst√ºtzt diese Funktion nicht.");
    }

    try {
        const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });

        const mimeType = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : 'audio/mp4';
        const mediaRecorder = new MediaRecorder(audioStream, { mimeType });

        const audioChunks = [];
        mediaRecorder.ondataavailable = event => audioChunks.push(event.data);

        mediaRecorder.start();
        isRecording = true;

        // R√ºckgabewert des Recorders setzen
        recorder = {
            mediaRecorder,
            audioStream,
            stopRecording: () => new Promise(resolve => {
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    resolve(audioBlob);
                };
                mediaRecorder.stop();
            })
        };
        
        return Promise.resolve(); // Indikator f√ºr erfolgreichen Start der Aufnahme

    } catch (error) {
        throw new Error("Audioaufnahme nicht m√∂glich. Bitte Mikrofonzugriff erlauben.");
    }
}



        function confirmStopRecording() {
            document.getElementById("confirmStopRecordingModal").checked = true;
        }

async function stopRecording(taskIndex) {
    document.getElementById("confirmStopRecordingModal").checked = false;

    if (taskIndex === 1 && recorder && isRecording) {
        try {
            const blob = await recorder.stopRecording();

            if (!blob || blob.size === 0) {
                console.error("Blob wurde nicht erstellt oder ist leer.");
                showValidationModal("Fehler bei der Erstellung der Aufnahme. Bitte versuche  es erneut.");
                return;
            }

            recordedBlobs = [blob];

            try {
                const combinedBlob = new Blob(recordedBlobs, { type: 'audio/wav' });
                savedAudioURL = URL.createObjectURL(combinedBlob);
                storedTasks.task1.savedAudioURL = savedAudioURL;

                if (!savedAudioURL || !savedAudioURL.startsWith("blob:")) {
                    throw new Error("Erstellung der Blob-URL fehlgeschlagen.");
                }
            } catch (error) {
                console.error("Fehler bei der Erstellung der Blob-URL:", error);
                showValidationModal("Fehler beim Laden der Aufnahme. Bitte versuchef es erneut.");
                return;
            }

            const audioPlayer = document.getElementById("audioPlayer");
            audioPlayer.src = savedAudioURL;
            document.getElementById("recordingName").innerText = "Aufnahme gespeichert";
            document.getElementById("savedRecording").classList.remove("hidden");

            isRecording = false;
            console.log("Recording stopped.");

            if (recorder.audioStream) {
                recorder.audioStream.getTracks().forEach(track => track.stop());
                recorder.audioStream = null;
            }

            await saveTasksToLocalStorage();
            checkAllTasksCompleted();
        } catch (error) {
            console.error("Fehler beim Stoppen der Aufnahme:", error);
            showValidationModal("Aufnahme konnte nicht gestoppt werden. Bitte versuche es erneut.");
        }
    } else {
        console.error("Aufnahme wurde nicht gestartet oder Recorder ist nicht initialisiert.");
        showValidationModal("Aufnahme wurde nicht gestartet.");
    }

    if (taskIntervals[taskIndex - 1]) {
        clearInterval(taskIntervals[taskIndex - 1]);
        taskIntervals[taskIndex - 1] = null;
    }
    currentTask = null;

    const startButton = document.getElementById("startTask1");
    const startIcon = document.getElementById("startIcon1");
    const startText = document.getElementById("startText1");
    startText.innerText = "Starten";
    startIcon.textContent = "‚ñ∂";
}

        // Timer-Funktionen

        function updateTimerDisplays() {
            for (let i = 1; i <= 3; i++) {
                const minutes = Math.floor(taskTimersInitial[i - 1] / 60);
                const seconds = taskTimersInitial[i - 1] % 60;

                const timerMinutesElement = document.getElementById(`timer${i}Minutes`);
                const timerSecondsElement = document.getElementById(`timer${i}Seconds`);

                timerMinutesElement.style.setProperty('--value', minutes);
                timerSecondsElement.style.setProperty('--value', seconds < 10 ? '0' + seconds : seconds);

                const progressElement = document.getElementById(`progress${i}`);
                if (progressElement) {
                    progressElement.value = 100;
                }
            }
        }

        function updateTaskTimer(taskIndex) {
            let timeLeft = taskTimers[taskIndex - 1];

            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;

            const timerMinutesElement = document.getElementById(`timer${taskIndex}Minutes`);
            const timerSecondsElement = document.getElementById(`timer${taskIndex}Seconds`);
            const progressElement = document.getElementById(`progress${taskIndex}`);

            if (timeLeft >= 0) {
                taskTimers[taskIndex - 1]--;

                timerMinutesElement.style.setProperty('--value', minutes);
                timerSecondsElement.style.setProperty('--value', seconds < 10 ? '0' + seconds : seconds);

                const progressValue = (taskTimers[taskIndex - 1] / taskTimersInitial[taskIndex - 1]) * 100;
                if (progressElement) {
                    progressElement.value = progressValue;
                }
            } else {
                timerMinutesElement.style.setProperty('--value', '0');
                timerSecondsElement.style.setProperty('--value', '00');

                if (taskIndex === 1) {
                    stopRecording(taskIndex);
                } else {
                    if (taskIntervals[taskIndex - 1]) {
                        clearInterval(taskIntervals[taskIndex - 1]);
                        taskIntervals[taskIndex - 1] = null;
                    }
                    currentTask = null;

                    const startButton = document.getElementById(`startTask${taskIndex}`);
                    if (startButton) {
                        startButton.disabled = false;
                        startButton.innerText = "‚ñ∂Ô∏è Starten";
                    }
                }

                taskTimers[taskIndex - 1] = taskTimersInitial[taskIndex - 1];
                if (progressElement) {
                    progressElement.value = 100;
                }
                showValidationModal(`Zeit f√ºr Aufgabe üïí${taskIndex} abgelaufen`);

                if (taskIndex === 3) {
                    showMonologue();
                }
            }
        }

        function startTimer(taskIndex) {
            const startButton = document.getElementById(`startTask${taskIndex}`);
            if(taskIndex != 1)
                startButton.disabled = true;
            const progressDiv = document.getElementById(`task${taskIndex}Progress`);
            if (progressDiv) {
                progressDiv.classList.remove("hidden");
            }

            taskIntervals[taskIndex - 1] = setInterval(() => updateTaskTimer(taskIndex), 1000);
        }

        // Weitere Funktionen

        function showValidationModal(message) {
            document.getElementById("validationMessage").innerHTML = message;
            const confirmButton = document.getElementById("modalConfirmButton");
            confirmButton.classList.add("hidden");
            document.getElementById("validationModal").checked = true;
        }

        function confirmDeleteRecording() {
            document.getElementById("confirmDeleteRecordingModal").checked = true;
        }
function deleteRecording() {
    if (savedAudioURL) {
        URL.revokeObjectURL(savedAudioURL); // Blob-URL freigeben
    }
    document.getElementById("savedRecording").classList.add("hidden");
    document.getElementById("audioPlayer").src = "";
    savedAudioURL = "";
    recordedBlobs = [];
    storedTasks.task1.savedAudioURL = null; // URL entfernen
    checkAllTasksCompleted();
    saveTasksToLocalStorage();
    document.getElementById("confirmDeleteRecordingModal").checked = false;
}

        function confirmDeleteProof() {
            document.getElementById("confirmDeleteProofModal").checked = true;
        }

function deleteProof() {
    if (savedProofURL) {
        URL.revokeObjectURL(savedProofURL); // Blob-URL freigeben
    }
    document.getElementById("savedProof").classList.add("hidden");
    document.getElementById("proofName").innerText = "";
    document.getElementById("proofPreview").classList.add("hidden");
    savedProofURL = "";
    storedTasks.task2.savedProofURL = null; // URL entfernen
    document.getElementById("qualityValue").innerText = "0%";
    checkAllTasksCompleted();
    saveTasksToLocalStorage();
    document.getElementById("confirmDeleteProofModal").checked = false;
}

        function confirmResetTasks() {
            document.getElementById("confirmResetModal").checked = true;
        }

        async function resetTasks() {
            // Aufgaben zur√ºcksetzen
            taskTimers = [...taskTimersInitial];
            taskIntervals.forEach(interval => clearInterval(interval));
            taskIntervals = [null, null, null];
            currentTask = null;
            currentTaskIndex = null; // Zur√ºcksetzen von currentTaskIndex
            tasksCompleted = [false, false, false];
            submitted = false;
            savedAudioURL = "";
            savedProofURL = "";
            recordedBlobs = [];

            // Reset der UI-Elemente
            for (let i = 1; i <= totalSteps; i++) {
                const taskDiv = document.getElementById(`task${i}`);
                if (taskDiv) {
                    taskDiv.classList.add("hidden");
                }

                const startButton = document.getElementById(`startTask${i}`);
                if (startButton) {
                    startButton.classList.remove("hidden");
                    startButton.disabled = false;
                    startButton.classList.remove("btn-success");
                    startButton.classList.add("btn-primary");
                    if (i === 1) {
                        startButton.innerHTML = '<span id="startIcon1" class="mr-2">‚ñ∂Ô∏è</span><span id="startText1">Starten</span>';
                    } else {
                        startButton.innerText = "‚ñ∂Ô∏è Starten";
                    }
                }

                if (i === 1) {
                    // Aufgabe 1 spezifische Resets
                    document.getElementById("savedRecording").classList.add("hidden");
                    document.getElementById("audioPlayer").src = "";
                    document.getElementById("recordingName").innerText = "";
                    document.getElementById("alternativeAudioUpload").classList.add("hidden");
                    recordedBlobs = [];
                } else if (i === 2) {
                    // Aufgabe 2 spezifische Resets
                    document.getElementById("proofName").innerText = "";
                    document.getElementById("proofPreview").href = "#";
                    document.getElementById("proofPreview").classList.add("hidden");
                    document.getElementById("savedProof").classList.add("hidden");
                    document.getElementById("qualityValue").innerText = "0%";
                }
            }

            updateTimerDisplays();
            localStorage.removeItem("tasks");
            await initializeTasks();
            updateOverallProgress();
		
            document.getElementById("confirmResetModal").checked = false;
            location.reload();

        }

        function updateOverallProgress() {
            const completedCount = tasksCompleted.filter(Boolean).length;
            document.getElementById("overallProgress").value = completedCount;
            document.getElementById("progressText").innerText = `${completedCount} von 3 Aufgaben abgeschlossen`;
        }

        function checkAllTasksCompleted() {
   		      tasksCompleted[0] = savedAudioURL && savedAudioURL !== "";
   			     tasksCompleted[1] = savedProofURL && savedProofURL !== "";
   			     tasksCompleted[2] = storedTasks.task3.mathTasks.every(task => task.userAnswer.trim() !== "");

            updateOverallProgress();
            saveTasksToLocalStorage();

            if (tasksCompleted.every(Boolean)) {
                showFinalPage();
            }
        }

        // Funktionen f√ºr den Upload und die Verarbeitung von Dateien

        function uploadAudioFile() {
            const fileInput = document.getElementById("audioFileUpload");
            const file = fileInput.files[0];
            if (file) {
                const audioURL = URL.createObjectURL(file);
                savedAudioURL = audioURL;
                recordedBlobs = [file];
                storedTasks.task1.audioBlob = file; // Blob speichern
                const audioPlayer = document.getElementById("audioPlayer");
                audioPlayer.src = audioURL;
                document.getElementById("recordingName").innerText = "Audiodatei hochgeladen";
                document.getElementById("savedRecording").classList.remove("hidden");
                document.getElementById("alternativeAudioUpload").classList.add("hidden");

                checkAllTasksCompleted();
            } else {
                showValidationModal("Fehler beim Laden der Audiodatei. Bitte versuche es erneut.");
            }
            fileInput.value = "";
        }

        function uploadProof() {
            const fileInput = document.getElementById("proofUpload");
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById("proofName").innerText = file.name;
                    const proofPreview = document.getElementById("proofPreview");
                    proofPreview.href = e.target.result;
                    proofPreview.classList.remove("hidden");
                    document.getElementById("savedProof").classList.remove("hidden");
                    savedProofURL = e.target.result;
                    storedTasks.task2.proofDataURL = e.target.result; // Bild speichern

                    checkAllTasksCompleted();
                };
                reader.readAsDataURL(file);
            }
            fileInput.value = "";
        }

        function confirmCompleteTask(taskIndex) {
            document.getElementById("validationMessage").innerHTML = "M√∂chtest du die Aufgabe wirklich abschlie√üen?";
            const confirmButton = document.getElementById("modalConfirmButton");

            // Entferne vorherige Event-Listener, um Mehrfachausl√∂sungen zu vermeiden
            confirmButton.removeEventListener('click', handleTaskCompletion);

            // Neuer Event-Listener f√ºr den Abschluss der Aufgabe
            confirmButton.addEventListener('click', () => handleTaskCompletion(taskIndex));

            confirmButton.classList.remove("hidden");
            document.getElementById("validationModal").checked = true;
        }

        function handleTaskCompletion(taskIndex) {
            // Mark task as completed
            tasksCompleted[taskIndex - 1] = true;
            saveTasksToLocalStorage();

            console.log(`Task ${taskIndex} marked as complete.`);
            document.getElementById("validationModal").checked = false;
            currentTask = null; // Reset current task

            // Move to the next task
            displayNextIncompleteTask();
        }

        function displayNextIncompleteTask() {
            // Finde den Index der n√§chsten unvollst√§ndigen Aufgabe, falls vorhanden
            const nextTaskIndex = tasksCompleted.findIndex(completed => !completed);

            // Pr√ºfe, ob eine unvollst√§ndige Aufgabe gefunden wurde und der Index innerhalb der Grenzen liegt
            if (nextTaskIndex >= 0 && nextTaskIndex < totalSteps) {
                currentTaskIndex = nextTaskIndex + 1; // Da `nextTaskIndex` 0-basiert ist
                console.log(`Displaying the next incomplete task: Task ${currentTaskIndex}`);
                showNextTask(currentTaskIndex);
            } else {
                console.log("No incomplete tasks found. All tasks are completed.");
                console.log("currentTaskIndex: " + currentTaskIndex);
                showFinalPage(); // Zeige die "Vielen Dank"-Seite
            }
        }

        function showNextTask(taskIndex = currentTaskIndex) {
            console.log("Attempting to show the next task...");

            // Check if all tasks are completed or if taskIndex is invalid
            if (tasksCompleted.every(Boolean) || taskIndex < 1 || taskIndex > totalSteps) {
                console.log("All tasks completed - exiting showNextTask.");
                showFinalPage(); // Show final completion modal or message
                return;
            }

            // Hide all tasks
            for (let i = 1; i <= totalSteps; i++) {
                document.getElementById(`task${i}`).classList.add("hidden");
            }

            // Show the specified task if it exists
            const currentTaskElement = document.getElementById(`task${taskIndex}`);
            if (currentTaskElement) {
                currentTaskElement.classList.remove("hidden");
                console.log(`Displaying task ${taskIndex}`);
            } else {
                console.error(`Task ${taskIndex} does not exist in the DOM.`);
            }
        }

        function showFinalPage() {
            document.getElementById("tasks").classList.add("hidden");
            document.getElementById("thankYouPage").classList.remove("hidden");
            submitted = true;
            saveTasksToLocalStorage();
        }

        function disableAllInteractions() {
document.querySelectorAll('#task1 .btn-primary, #task1 .btn-secondary, #task1 .btn-success, #task1 .btn-error, #task1 .btn-warning, ' +
                         '#task2 .btn-primary, #task2 .btn-secondary, #task2 .btn-success, #task2 .btn-error, #task2 .btn-warning, ' +
                         '#task3 .btn-primary, #task3 .btn-secondary, #task3 .btn-success, #task3 .btn-error, #task3 .btn-warning')
        .forEach(btn => {
            btn.disabled = true;
        });

            document.querySelectorAll('#task2 input[type="file"]').forEach(input => {
                input.disabled = true;
            });

            document.querySelectorAll("#mathTasks input").forEach(input => {
                input.disabled = true;
            });
        }

        function proceedWithoutMic() {
            document.getElementById("micErrorModal").checked = false;
            startTimer(1); // Timer starten
        }

        function showMonologue() {
            document.getElementById("monologueModal").checked = true;
        }

        function restartRecording() {
            document.getElementById("confirmRestartRecordingModal").checked = false;
            deleteRecording();
            startRecordingProcess();
        }

        // Funktion zum Erstellen und Herunterladen der ZIP-Datei
        async function downloadZip() {
            const zip = new JSZip();

            // Aufgabe 1: Aufnahme hinzuf√ºgen
            if (storedTasks.task1.audioBlob) {
                zip.file("Aufnahme.wav", storedTasks.task1.audioBlob);
            }

            // Aufgabe 2: Foto der Abschrift hinzuf√ºgen
            if (storedTasks.task2.proofDataURL) {
                const imgData = storedTasks.task2.proofDataURL.split(',')[1];
                zip.file("Abschrift.png", imgData, { base64: true });
            }

            // Aufgabe 3: Rechenaufgaben inklusive L√∂sungen
            const mathContent = generateMathContent();
            zip.file("Rechenaufgaben.txt", mathContent);

            // Aufgabentexte hinzuf√ºgen
            zip.file("Lesetext.html", storedTasks.task1.readText);
            zip.file("Abschreibtext.html", storedTasks.task2.writeText);

            // ZIP-Datei generieren und herunterladen
            zip.generateAsync({ type: "blob" })
                .then(function(content) {
                    saveAs(content, "Ergebnisse.zip");
                });
        }

        function generateMathContent() {
            let content = "Rechenaufgaben und L√∂sungen:\n\n";
            storedTasks.task3.mathTasks.forEach((task, index) => {
                const userAnswer = task.userAnswer.trim();
                const correctAnswer = calculateAnswer(task.num1, task.num2, task.operator);
                content += `${index + 1}. ${task.num1} ${operatorToSymbol(task.operator)} ${task.num2} = ${userAnswer} (Korrekte Antwort: ${correctAnswer})\n`;
            });
            return content;
        }

        function calculateAnswer(num1, num2, operator) {
            switch (operator) {
                case '+':
                    return num1 + num2;
                case '-':
                    return num1 - num2;
                case '*':
                    return num1 * num2;
                case '/':
                    return (num1 / num2).toFixed(2);
                default:
                    return 'Unbekannter Operator';
            }
        }

        // Initiale Timer-Anzeige aktualisieren
        updateTimerDisplays();
    </script>
</body>
</html>
