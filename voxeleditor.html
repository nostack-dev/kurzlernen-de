<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Voxel-Editor – funktionierender STL-Export</title>
<style>
body{margin:0;overflow:hidden;font-family:sans-serif;display:flex;flex-direction:column;height:100vh;background:#282c34;color:#e0e0e0}
#controls{padding:14px;background:#3a3f47;border-bottom:1px solid #4a4f57;display:flex;flex-wrap:wrap;gap:12px;justify-content:center;align-items:center}
#controls button,#controls label{padding:8px 18px;border:none;border-radius:5px;font-size:1em;background:#555c66;color:#e0e0e0;cursor:pointer}
#controls button:hover{background:#6a727f}
#grid-size-display,#current-mode{font-weight:700;color:#90caf9}
#current-mode{color:#81c784}
#container{flex:1;position:relative}
canvas{width:100%;height:100%}
.info-box{position:absolute;bottom:18px;left:18px;padding:12px;border-radius:8px;font-size:.85em;background:rgba(0,0,0,.6);pointer-events:none}
.info-box strong{color:#90caf9}
#fileInput{display:none}
</style>
</head>
<body>
<div id="controls">
 <label>Gitter:</label><span id="grid-size-display">10×10×10</span>
 <button id="modeToggle">Modus wechseln</button><span id="current-mode">Modus: Hinzufügen</span>
 <button id="clearBtn">Alles löschen</button>
 <button id="saveBtn">Projekt speichern</button>
 <button id="loadBtn">Projekt laden</button>
 <button id="exportStlBtn">STL Export</button>
</div>

<div id="container">
 <canvas id="voxelCanvas"></canvas>
 <div class="info-box">
  <strong>Steuerung</strong><br>
  Rechte MT gehalten + Maus → Kamera drehen<br>
  WASD / E / Q → bewegen<br>
  Linke MT → Voxel hinzuf./löschen<br>
  Mausrad → Speed
 </div>
 <input type="file" id="fileInput" accept=".json">
</div>

<!-- Three.js r128 -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128/build/three.min.js"></script>
<!-- BufferGeometryUtils & STLExporter (Originale) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/exporters/STLExporter.js"></script>

<script>
/* ---------- Konstanten ---------- */
const GRID=10, VS=1, HALF=VS*0.5;

/* ---------- globale Variablen ---------- */
let scene, cam, ren, gridHelper, boxHelper;
const voxels=new Map();          // key = "x,y,z" (Mittelpunkt)

/* ---------- Materialien ---------- */
const matVoxel  = new THREE.MeshLambertMaterial({color:0xffffff});
const matShadow = new THREE.MeshBasicMaterial({color:0x000000,transparent:true,opacity:0.3,side:THREE.BackSide});

/* ---------- Initialisierung ---------- */
window.onload=() =>{
 const cont=document.getElementById('container');
 const cvs=document.getElementById('voxelCanvas');

 scene=new THREE.Scene();
 scene.background=new THREE.Color(0x282c34);

 cam=new THREE.PerspectiveCamera(75,cont.clientWidth/cont.clientHeight,0.1,1000);
 cam.position.set(GRID*0.6,GRID*0.7,GRID*0.8);
 cam.lookAt(GRID/2,GRID/2,GRID/2);

 ren=new THREE.WebGLRenderer({canvas:cvs,antialias:true});
 ren.setSize(cont.clientWidth,cont.clientHeight);
 ren.setPixelRatio(window.devicePixelRatio);

 /* Licht */
 scene.add(new THREE.AmbientLight(0x404040));
 const d1=new THREE.DirectionalLight(0xffffff,0.8); d1.position.set(1,1,1).normalize(); scene.add(d1);
 const d2=new THREE.DirectionalLight(0xffffff,0.5); d2.position.set(-1,-1,-1).normalize(); scene.add(d2);

 rebuildHelpers();
 window.addEventListener('resize',onResize);

 /* Steuerung */
 let addMode=true, rotate=false, keys={}, moveSpeed=0.1, rotSpeed=0.002;
 let euler=new THREE.Euler().setFromQuaternion(cam.quaternion,'YXZ');

 const setMode=()=>{ const m=document.getElementById('current-mode');
   m.textContent=`Modus: ${addMode?'Hinzufügen':'Löschen'}`;
   m.style.color=addMode?'#81c784':'#ef5350';};
 setMode();

 document.getElementById('modeToggle').onclick=()=>{addMode=!addMode; setMode();};
 document.getElementById('clearBtn').onclick = clearAll;
 document.getElementById('saveBtn').onclick  = saveJSON;
 document.getElementById('loadBtn').onclick  = ()=>document.getElementById('fileInput').click();
 document.getElementById('fileInput').onchange = loadJSON;
 document.getElementById('exportStlBtn').onclick = exportSTL;

 cvs.oncontextmenu=e=>e.preventDefault();

cvs.onpointerdown=e=>{
   if(e.button===2){rotate=true; cvs.requestPointerLock(); return;}
   if(e.button!==0) return;
   /* Raycast */
   const rect=cvs.getBoundingClientRect();
   const mouse=new THREE.Vector2(((e.clientX-rect.left)/rect.width)*2-1,
                                 -((e.clientY-rect.top)/rect.height)*2+1);
   const ray=new THREE.Raycaster(); ray.setFromCamera(mouse,cam);
   const objs=[...voxels.values()].map(v=>v.mesh);
   const hits=ray.intersectObjects(objs);
   
   if(addMode){
     if(hits.length){
       // Berechnung der Gitterkoordinaten des neuen Voxels basierend auf dem getroffenen Voxel und der Normalen
       const hitVoxel = voxels.get(key(
         Math.round(hits[0].object.position.x / VS - HALF), // Konvertiere Mittelpunkt zurück zu gx
         Math.round(hits[0].object.position.y / VS - HALF), // Konvertiere Mittelpunkt zurück zu gy
         Math.round(hits[0].object.position.z / VS - HALF)  // Konvertiere Mittelpunkt zurück zu gz
       ));
       const normal = hits[0].face.normal;
       const newGx = hitVoxel.gx + normal.x;
       const newGy = hitVoxel.gy + normal.y;
       const newGz = hitVoxel.gz + normal.z;
       addVoxel(newGx,newGy,newGz);
     }else{
       // Wenn keine Voxel getroffen wurden (z.B. erster Klick auf die Grundebene)
       const plane=new THREE.Plane(new THREE.Vector3(0,1,0),0), p=new THREE.Vector3();
       if(ray.ray.intersectPlane(plane,p)){
         const gx = Math.floor(p.x / VS); // Bodenzellen-Koordinate
         const gy = 0; // Auf der Grundebene
         const gz = Math.floor(p.z / VS); // Bodenzellen-Koordinate
         addVoxel(gx,gy,gz);
       }
     }
   }else if(hits.length){
     const p=hits[0].object.position;
     // Um Voxel zu entfernen, den Mittelpunkt zurück in Gitterkoordinaten umwandeln
     const gx = Math.round(p.x / VS - HALF);
     const gy = Math.round(p.y / VS - HALF);
     const gz = Math.round(p.z / VS - HALF);
     removeVoxel(gx,gy,gz);
   }
};
 cvs.onpointermove=e=>{
   if(!rotate)return;
   euler.y-=e.movementX*rotSpeed;
   euler.x-=e.movementY*rotSpeed;
   euler.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,euler.x));
   cam.quaternion.setFromEuler(euler);
 };
 cvs.onpointerup=e=>{
   if(e.button===2){rotate=false; document.exitPointerLock();}
 };
 cvs.addEventListener('wheel',e=>{
   e.preventDefault();
   moveSpeed*= e.deltaY<0?1.1:0.9;
   moveSpeed=Math.max(0.01,Math.min(10,moveSpeed));
 },{passive:false});

 window.onkeydown=e=>keys[e.code]=true;
 window.onkeyup  =e=>keys[e.code]=false;

 /* Render-Loop */
 (function loop(){
   requestAnimationFrame(loop);
   const dir=new THREE.Vector3(); cam.getWorldDirection(dir);
   const right=new THREE.Vector3().crossVectors(dir,cam.up);
   if(keys.KeyW) cam.position.addScaledVector(dir, moveSpeed);
   if(keys.KeyS) cam.position.addScaledVector(dir,-moveSpeed);
   if(keys.KeyA) cam.position.addScaledVector(right,-moveSpeed);
   if(keys.KeyD) cam.position.addScaledVector(right, moveSpeed);
   if(keys.KeyE) cam.position.y+=moveSpeed;
   if(keys.KeyQ) cam.position.y-=moveSpeed;
   ren.render(scene,cam);
 })();
};

/* ---------- Hilfsfunktionen ---------- */
function onResize(){
 const c=document.getElementById('container');
 cam.aspect=c.clientWidth/c.clientHeight; cam.updateProjectionMatrix();
 ren.setSize(c.clientWidth,c.clientHeight);
}

function rebuildHelpers(){
 if(gridHelper) scene.remove(gridHelper);
 if(boxHelper)  scene.remove(boxHelper);
 const size=GRID*VS;
 gridHelper=new THREE.GridHelper(size,GRID,0xaaaaaa,0xcccccc);
 gridHelper.position.set(size/2,0,size/2); scene.add(gridHelper);
 const edges=new THREE.EdgesGeometry(new THREE.BoxGeometry(size,size,size));
 boxHelper=new THREE.LineSegments(edges,new THREE.LineBasicMaterial({color:0x00ffff}));
 boxHelper.position.set(size/2,size/2,size/2); scene.add(boxHelper);
}

function key(cx,cy,cz){return `${cx},${cy},${cz}`;}
/* ---------- Voxel-Operationen ---------- */
function addVoxel(gx,gy,gz){ // Akzeptiert jetzt Gitterkoordinaten
 const id=key(gx,gy,gz); // Schlüssel basiert auf Gitterkoordinaten
 if(gx<0||gx>=GRID||gy<0||gy>=GRID||gz<0||gz>=GRID) return;
 if(voxels.has(id)) return;

 // Berechne den Mittelpunkt (cx, cy, cz) aus den Gitterkoordinaten
 const cx = (gx + HALF) * VS;
 const cy = (gy + HALF) * VS;
 const cz = (gz + HALF) * VS;

 const mesh=new THREE.Mesh(new THREE.BoxGeometry(VS,VS,VS),matVoxel);
 mesh.position.set(cx,cy,cz); scene.add(mesh);
 const shadow=new THREE.Mesh(new THREE.BoxGeometry(VS*1.01,VS*1.01,VS*1.01),matShadow);
 shadow.position.copy(mesh.position); scene.add(shadow);

 voxels.set(id,{mesh, shadow, gx,gy,gz}); // Speichere gx, gy, gz
}

function removeVoxel(gx,gy,gz){ // Akzeptiert jetzt Gitterkoordinaten
 const id=key(gx,gy,gz); // Schlüssel basiert auf Gitterkoordinaten
 if(!voxels.has(id)) return;
 const {mesh, shadow}=voxels.get(id);
 scene.remove(mesh);
 scene.remove(shadow);
 mesh.geometry.dispose();
 shadow.geometry.dispose();
 voxels.delete(id);
}
function clearAll(){
 voxels.forEach(v=>{
    scene.remove(v.mesh);
    scene.remove(v.shadow); // Auch Schatten entfernen
    v.mesh.geometry.dispose();
    v.shadow.geometry.dispose(); // Geometrie entsorgen
  });
 voxels.clear();
}
/* ---------- JSON-I/O ---------- */
function saveJSON(){
 const data=[...voxels.values()].map(v=>({gx:v.gx,gy:v.gy,gz:v.gz}));
 const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
 const url=URL.createObjectURL(blob), a=document.createElement('a');
 a.href=url; a.download='voxel_model.json'; a.click(); URL.revokeObjectURL(url);
}

function loadJSON(e){
 const f=e.target.files[0]; if(!f) return;
 const r=new FileReader();
 r.onload=ev=>{
   try{ const arr=JSON.parse(ev.target.result); clearAll();
     arr.forEach(o=>addVoxel((o.gx+0.5)*VS,(o.gy+0.5)*VS,(o.gz+0.5)*VS));
   }catch(err){alert('Ungültige JSON');}
 };
 r.readAsText(f); e.target.value='';
}

/* ---------- STL-Export ---------- */
function exportSTL(){
 if(voxels.size===0){alert('Keine Voxel'); return;}

 /* 1. Liste gefüllter Zellen */
 const filled=new Set();
 voxels.forEach(v=>filled.add(`${v.gx},${v.gy},${v.gz}`));

 /* 2. Außenflächen erzeugen */
 const pos=[], norm=[];
 const faces=[
  {n:[ 1, 0, 0], v:[[ HALF,-HALF,-HALF],[ HALF,-HALF, HALF],[ HALF, HALF, HALF],[ HALF, HALF,-HALF]]},
  {n:[-1, 0, 0], v:[[-HALF,-HALF, HALF],[-HALF,-HALF,-HALF],[-HALF, HALF,-HALF],[-HALF, HALF, HALF]]},
  {n:[ 0, 1, 0], v:[[-HALF, HALF,-HALF],[ HALF, HALF,-HALF],[ HALF, HALF, HALF],[-HALF, HALF, HALF]]},
  {n:[ 0,-1, 0], v:[[-HALF,-HALF, HALF],[ HALF,-HALF, HALF],[ HALF,-HALF,-HALF],[-HALF,-HALF,-HALF]]},
  {n:[ 0, 0, 1], v:[[-HALF,-HALF, HALF],[-HALF, HALF, HALF],[ HALF, HALF, HALF],[ HALF,-HALF, HALF]]},
  {n:[ 0, 0,-1], v:[[ HALF,-HALF,-HALF],[ HALF, HALF,-HALF],[-HALF, HALF,-HALF],[-HALF,-HALF,-HALF]]}
 ];
 const idx=[0,1,2,0,2,3];

 voxels.forEach(v=>{
   faces.forEach(f=>{
     const ng=[v.gx+f.n[0],v.gy+f.n[1],v.gz+f.n[2]];
     if(filled.has(`${ng[0]},${ng[1]},${ng[2]}`)) return; // Innenseite
     idx.forEach(i=>{
       const vert=f.v[i];
       pos.push((v.gx+0.5+vert[0])*VS,
                (v.gy+0.5+vert[1])*VS,
                (v.gz+0.5+vert[2])*VS);
       norm.push(...f.n);
     });
   });
 });

 /* 3. Geometry + Mesh-Wrapper */
 const geo=new THREE.BufferGeometry();
 geo.setAttribute('position',new THREE.BufferAttribute(new Float32Array(pos),3));
 geo.setAttribute('normal',  new THREE.BufferAttribute(new Float32Array(norm),3));
 const mesh=new THREE.Mesh(geo,new THREE.MeshNormalMaterial()); // unsichtbar, nur für Export

 /* 4. STL erzeugen */
 const exporter=new THREE.STLExporter();
 const stlBuffer=exporter.parse(mesh,{binary:true}); // <- Mesh statt Geometry!

 /* 5. Download */
 const blob=new Blob([stlBuffer],{type:'application/octet-stream'});
 const url=URL.createObjectURL(blob);
 const a=document.createElement('a'); a.href=url; a.download='voxel_model.stl'; a.click();
 URL.revokeObjectURL(url);
}
</script>
</body>
</html>
