<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Voxel-Editor – Verbesserter Export & Rendering</title>
<style>
/* Reset and Base Styles */
body {
    margin: 0;
    overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* More modern font */
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: #282c34;
    color: #e0e0e0;
    font-size: 13.5px; /* Slightly smaller default font size */
}

/* Controls Container - Adjusted for single row, minimal height */
#controls {
    padding: 6px 10px; /* Reduced padding for minimal height */
    background: #3a3f47;
    border-bottom: 1px solid #4a4f57;
    display: flex;
    flex-wrap: wrap; /* Allow wrapping if window is too small, though we aim for one line */
    gap: 12px; /* Reduced gap between control groups */
    align-items: center; /* Vertically center items in the row */
    justify-content: flex-start; /* Align items to the start */
    box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Subtle shadow for depth */
    min-height: 45px; /* Ensure a minimum height for buttons */
}

/* Control Panel Style - Adjusted to act as horizontal groups */
.control-panel {
    background: #2f333a; /* Darker background for groups */
    border: 1px solid #4a4f57;
    border-radius: 8px; /* Softer corners */
    padding: 6px 10px; /* Reduced padding inside panels for compactness */
    margin: 0; /* No external margin */
    display: flex; /* Use flexbox for items within the panel */
    flex-direction: row; /* Arrange items horizontally */
    gap: 10px; /* Reduced gap between items inside a group */
    align-items: center; /* Vertically center items in the group */
    box-shadow: inset 0 0 5px rgba(0,0,0,0.1); /* Inner shadow for depth */
    flex-shrink: 0; /* Prevent panels from shrinking */
}

.control-panel h3 {
    color: #90caf9; /* Header color */
    font-size: 1.05em; /* Slightly smaller header font */
    margin: 0; /* Remove margins */
    padding: 0 8px 0 0; /* Reduced padding to separate from controls */
    border-right: 1px solid #4a4f57; /* Vertical separator */
    white-space: nowrap; /* Prevent wrapping */
}

/* Common Button and Label Styles */
#controls button,
.control-group label {
    padding: 7px 15px; /* Slightly adjusted padding for buttons */
    border: none;
    border-radius: 6px; /* Slightly larger border-radius for softer look */
    font-size: 0.9em; /* Slightly smaller font for compactness */
    background: #555c66;
    color: #e0e0e0;
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.1s ease; /* Smooth transitions */
    white-space: nowrap; /* Prevent text wrapping inside buttons */
    display: inline-flex; /* Use flexbox for button content */
    align-items: center; /* Center text vertically */
    justify-content: center; /* Center text horizontally */
}

/* Button Hover and Active States - Adjusted for "normal" look */
#controls button:hover {
    background: #6a727f;
    transform: translateY(-1px); /* Subtle lift on hover */
    box-shadow: none; /* No shadow on hover */
}

#controls button:active {
    transform: translateY(0); /* Return to normal on click */
    background-color: #4a4f57; /* Darker on active */
    box-shadow: none; /* No shadow on active */
}

/* Remove default focus outline for a cleaner look */
#controls button:focus,
input:focus {
    outline: none; /* Remove default blue outline */
    box-shadow: 0 0 0 2px rgba(144, 202, 249, 0.5); /* Custom subtle focus ring */
}


/* Grid Size Display */
#grid-size-display {
    font-weight: 700;
    color: #90caf9;
    min-width: 70px; /* Slightly smaller consistent width */
    text-align: center;
    background: #4a4f57; /* Darker background for distinction */
    padding: 7px 8px; /* Reduced padding */
    border-radius: 6px;
    font-size: 0.9em; /* Match button font size */
}

/* Current Mode Display - Subtle border/highlight */
#current-mode {
    font-weight: 700;
    color: #81c784; /* Default green */
    padding: 7px 12px; /* Reduced padding */
    border-radius: 6px;
    background: #4a4f57; /* Darker background for distinction */
    display: inline-block;
    min-width: 110px; /* Slightly smaller consistent width */
    text-align: center;
    border: 1px solid #90caf9; /* Thinner border for subtle highlight */
    box-shadow: 0 0 4px rgba(144, 202, 249, 0.3); /* Subtle glow for highlight */
    transition: all 0.2s ease;
    font-size: 0.9em; /* Match button font size */
}
/* Specific colors for modes - make sure these override the default #81c784 above when set by JS */
#current-mode[data-mode="Hinzufügen"] { color: #81c784; border-color: #81c784; box-shadow: 0 0 4px rgba(129, 199, 132, 0.3); }
#current-mode[data-mode="Löschen"] { color: #ef5350; border-color: #ef5350; box-shadow: 0 0 4px rgba(239, 83, 80, 0.3); }
#current-mode[data-mode="Zeichnen"] { color: #ffa726; border-color: #ffa726; box-shadow: 0 0 4px rgba(255, 167, 38, 0.3); }


/* Main Container for Canvas and Info Box */
#container {
    flex: 1;
    position: relative;
    overflow: hidden; /* Ensure nothing spills out */
    border: 3px solid transparent; /* Default transparent border */
    transition: border-color 0.3s ease-in-out; /* Smooth transition */
}
/* Border styles for different modes - NOW APPLIED TO ALL SIDES */
#container[data-mode="Hinzufügen"] { border-color: rgba(129, 199, 132, 0.6); } /* Green, slightly transparent */
#container[data-mode="Löschen"] { border-color: rgba(239, 83, 80, 0.6); } /* Red, slightly transparent */
#container[data-mode="Zeichnen"] { border-color: rgba(255, 167, 38, 0.6); } /* Orange, slightly transparent */


canvas {
    width: 100%;
    height: 100%;
    display: block; /* Remove extra space below canvas */
}

/* Info Box */
.info-box {
    position: absolute;
    bottom: 20px; /* Increased bottom spacing */
    left: 20px; /* Increased left spacing */
    padding: 15px; /* More padding */
    border-radius: 10px; /* Softer corners */
    font-size: 0.8em; /* Slightly smaller font for less obtrusiveness */
    background: rgba(0, 0, 0, 0.7); /* Slightly darker background */
    color: #f0f0f0; /* Lighter text for contrast */
    pointer-events: none;
    line-height: 1.6; /* Better readability */
    max-width: 350px; /* Limit width */
    box-shadow: 0 4px 10px rgba(0,0,0,0.3); /* Clearer shadow */
    display: none; /* Controlled by JS */
}

.info-box strong {
    color: #90caf9;
    font-weight: bold;
    margin-bottom: 5px; /* Spacing below title */
    display: block;
}

#fileInput {
    display: none;
}

/* Slider Style */
input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 140px; /* Slightly narrower */
    height: 9px; /* Slightly thinner track */
    background: #4a4f57;
    border-radius: 5px;
    outline: none;
    opacity: 0.9; /* Slightly less opaque */
    transition: opacity .2s, background-color .2s;
    margin-left: 6px; /* Reduced margin */
    margin-right: 6px; /* Reduced margin */
}

input[type="range"]:hover {
    opacity: 1;
    background-color: #555c66; /* Darker on hover */
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px; /* Slightly smaller thumb */
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); /* Subtle shadow on thumb */
    transition: background-color 0.2s ease, transform 0.1s ease;
}
input[type="range"]::-webkit-slider-thumb:hover {
    background: #6faee5; /* Lighter blue on hover */
    transform: scale(1.05);
}
input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    transition: background-color 0.2s ease, transform 0.1s ease;
}
input[type="range"]::-moz-range-thumb:hover {
    background: #6faee5;
    transform: scale(1.05);
}

/* Color Picker Styling - MADE ROUND */
input[type="color"] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 36px; /* Slightly smaller */
    height: 36px;
    border: none;
    border-radius: 50%; /* Made round */
    background-color: transparent;
    cursor: pointer;
    padding: 0;
    vertical-align: middle;
    box-shadow: 0 0 0 2px #555c66; /* Border as shadow for cleaner look */
    transition: box-shadow 0.2s ease;
}
input[type="color"]:hover {
    box-shadow: 0 0 0 3px #90caf9; /* Blue hover border */
}
input[type="color"]::-webkit-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-webkit-color-swatch {
    border: none; /* No internal border */
    border-radius: 50%; /* Made round */
}
input[type="color"]::-moz-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-moz-color-swatch {
    border: none;
    border-radius: 50%; /* Made round */
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    align-items: center;
    justify-content: center;
}

.modal-content {
    background-color: #3a3f47;
    margin: auto;
    padding: 30px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); /* Stronger shadow */
    max-width: 450px; /* Slightly wider modal */
    color: #e0e0e0;
}

.modal-content h3 {
    margin-top: 0;
    margin-bottom: 15px;
    color: #90caf9;
    font-size: 1.3em;
}

.modal-content p {
    font-size: 1.05em;
    line-height: 1.5;
}

.modal-buttons {
    margin-top: 25px;
    display: flex;
    justify-content: center; /* Center buttons */
    gap: 15px; /* More space between buttons */
}

.modal-buttons button {
    padding: 12px 25px; /* Larger buttons */
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1.05em;
    flex-grow: 0; /* Don't force growth */
    min-width: 120px; /* Minimum width for consistency */
    transition: background-color 0.2s ease, transform 0.1s ease;
}

.modal-buttons button.confirm-save {
    background-color: #4CAF50; /* Green */
    color: white;
}
.modal-buttons button.confirm-save:hover {
    background-color: #45a049;
    transform: translateY(-1px);
}

.modal-buttons button.confirm-no-save {
    background-color: #f44336; /* Red */
    color: white;
}
.modal-buttons button.confirm-no-save:hover {
    background-color: #da190b;
    transform: translateY(-1px);
}

.modal-buttons button.cancel {
    background-color: #555c66; /* Grey */
    color: #e0e0e0;
}
.modal-buttons button.cancel:hover {
    background-color: #6a727f;
    transform: translateY(-1px);
}


/* Style for the preset color boxes - KEPT RECTANGULAR */
.color-preset-box {
    width: 34px; /* Slightly smaller */
    height: 34px;
    border-radius: 5px; /* Kept rectangular */
    border: 2px solid #555c66;
    cursor: pointer;
    display: inline-block;
    vertical-align: middle;
    box-sizing: border-box;
    transition: transform 0.1s ease-in-out, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.color-preset-box:hover {
    transform: scale(1.1);
}
.color-preset-box.active {
    border-color: #90caf9;
    box-shadow: 0 0 8px rgba(144, 202, 249, 0.7);
}

/* Grouping for better organization */
.control-group {
    display: flex;
    align-items: center;
    gap: 8px; /* Reduced space between items in a group */
    flex-shrink: 0; /* Prevent individual groups from shrinking */
}

/* Adjust labels to align with inputs */
.control-group label {
    margin-right: -5px; /* Pull label closer to input */
}

</style>
</head>
<body>
<div id="controls">
    <div class="control-panel">
        <h3>Gitter & Größe</h3>
        <div class="control-group">
            <label for="grid-size-slider">Gittergröße:</label>
            <input type="range" id="grid-size-slider" min="5" max="30" value="10">
            <span id="grid-size-display">10×10×10</span>
        </div>
        <button id="fillLevelBtn">Ebene füllen</button>
    </div>

    <div class="control-panel">
        <h3>Farbe & Modus</h3>
        <div class="control-group">
            <label for="color-picker">Farbe:</label>
            <input type="color" id="color-picker" value="#ffffff">
        </div>
        <div class="control-group">
            <div id="color-preset-1" class="color-preset-box"></div>
            <div id="color-preset-2" class="color-preset-box"></div>
            <div id="color-preset-3" class="color-preset-box"></div>
        </div>
        <button id="modeToggle">Modus wechseln</button>
        <span id="current-mode" data-mode="Hinzufügen">Modus: Hinzufügen</span>
    </div>

    <div class="control-panel">
        <h3>Projekt Operationen</h3>
        <button id="saveBtn">Projekt speichern</button>
        <button id="loadBtn">Projekt laden</button>
        <button id="exportStlBtn">STL Export</button>
        <button id="clearBtn">Alles löschen</button>
    </div>

    <div class="control-panel">
        <h3>Hilfe</h3>
        <button id="helpToggleBtn">Hilfe anzeigen/ausblenden</button>
    </div>
</div>

<div id="container">
    <canvas id="voxelCanvas"></canvas>
    <div class="info-box" id="infoBox"> <strong>Steuerung</strong><br>
    Rechte MT gehalten + Maus → Kamera drehen (Fly Mode)<br>
    WASD / E / Q → bewegen<br>
    Linke MT → Voxel hinzuf./löschen/zeichnen<br>
    **Alt + Mausrad → Zeichenebene Y hoch/runter (Gitter folgt)**<br>
    **Alt + Shift + Mausrad → Zeichenebene Z hoch/runter (Gitter folgt)**<br>
    **Alt + Control + Mausrad → Zeichenebene X hoch/runter (Gitter folgt)**<br>
    **Shift + Linke MT gedrückt + Maus ziehen → Voxel Aktion auf aktiver Ebene (Hinzufügen / Löschen / Zeichnen)**<br>
    **Control + Linke MT gedrückt + Maus ziehen → Voxel ziehen zum Hinzufügen (Stapeln, nur im Hinzufügen-Modus)**<br>
    Mausrad → Kamera Geschwindigkeit anpassen<br>
    **Tab → Modus wechseln (Hinzufügen / Löschen / Zeichnen)**<br>
    **1, 2, 3 → Voreingestellte Farbe wählen**<br>
    **Strg + Z → Rückgängig (Undo)**<br>
    **Strg + Y oder Strg + Shift + Z → Wiederholen (Redo)**
    </div>
    <input type="file" id="fileInput" accept=".json">
</div>

<div id="clearConfirmationModal" class="modal">
    <div class="modal-content">
        <h3>Projekt löschen</h3>
        <p>Möchten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel löschen?</p>
        <div class="modal-buttons">
            <button id="saveAndClearBtn" class="confirm-save">Speichern & Löschen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save">Ohne Speichern löschen</button>
            <button id="cancelClearBtn" class="cancel">Abbrechen</button>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>

<script>
/* ---------- Konstanten ---------- */
const VS = 1, HALF = VS * 0.5;
const MIN_GRID_SIZE_ABSOLUTE = 5; // Absolute minimum grid size

/* ---------- globale Variablen ---------- */
let scene, cam, ren, gridHelper, boxHelper;
const voxels = new Map();
let cvs;
let activeDrawingLevel = { x: 0, y: 0, z: 0 }; // Objekt für aktive Ebenen
let currentDrawingAxis = 'y'; // Aktuelle Achse für Alt+Mausrad
let currentShiftDragLevel = null; // Speichert die Ebene für den aktuellen Shift-Drag-Vorgang
// Lade die Farbe aus dem Local Storage oder nutze Weiß als Standard
let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
// Lade die Gittergröße aus dem Local Storage oder nutze 10 als Standard
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize')) || 10;

// Preset colors - NEW, more natural colors
const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#8B4513', // Erdton (SaddleBrown)
    localStorage.getItem('voxelPresetColor2') || '#708237', // Grasgrün (OliveDrab)
    localStorage.getItem('voxelPresetColor3') || '#6495ED'  // Wasserblau (CornflowerBlue)
];
let activePresetIndex = -1; // -1 means no preset is "active" initially, 0 for the first preset, etc.
let presetBoxes = []; // Global array to store references to preset color boxes

// Referenzen für Lichter, die Schatten werfen, um sie später anpassen zu können
let mainDirectionalLight;

// Globale Variablen für Dragging-Status
let isShiftDragging = false;
let isControlDragging = false;
let rotate = false; // Moved to global as it's used across handlers

// Modus-Enum
const Modes = {
    ADD: 'Hinzufügen',
    DELETE: 'Löschen',
    DRAW: 'Zeichnen'
};
let currentMode = Modes.ADD; // Standardmodus

// Undo/Redo History
const history = [];
let historyPointer = -1;
const MAX_HISTORY_SIZE = 100; // Limit history to prevent excessive memory usage

// Referenz zum Container, um den Viewport-Rand zu steuern
let container;

// Highlight mesh for hovered face
let highlightMesh;
const highlightMaterial = new THREE.MeshBasicMaterial({ color: 0x90caf9, transparent: true, opacity: 0.3, depthTest: false }); // Subtle blue, translucent


/* ---------- Initialisierung ---------- */
window.onload = () => {
    container = document.getElementById('container'); // Get container reference here
    cvs = document.getElementById('voxelCanvas');

    // Make sure THREE is defined here before using it
    if (typeof THREE === 'undefined') {
        console.error("THREE ist nicht definiert. Es gab ein Problem beim Laden der Three.js-Bibliothek. Überprüfen Sie die CDN-Links oder Ihre Internetverbindung.");
        alert("Fehler: Die Kern-3D-Bibliothek konnte nicht geladen werden. Bitte versuchen Sie es erneut oder überprüfen Sie Ihre Internetverbindung.");
        return; // Stop execution if THREE is not available
    }
    // Also check for BufferGeometryUtils and STLExporter
    if (typeof THREE.BufferGeometryUtils === 'undefined') {
        console.warn("WARNUNG: THREE.BufferGeometryUtils ist nicht definiert. Der STL Export könnte fehlschlagen, wenn diese Utility benötigt wird.");
    }
    if (typeof THREE.STLExporter === 'undefined') {
        console.warn("WARNUNG: THREE.STLExporter ist nicht definiert. Der STL Export wird fehlschlagen.");
    }


    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x282c34);

    cam = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    // Kameraposition an die Gittergröße anpassen
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5);
    cam.lookAt(GRID / 2, GRID / 2, GRID / 2);

    ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
    ren.setSize(container.clientWidth, container.clientHeight);
    ren.setPixelRatio(window.devicePixelRatio);
    ren.shadowMap.enabled = true;
    ren.shadowMap.type = THREE.PCFSoftShadowMap; // Weichere Schatten

    /* Licht */
    // Verbesserte Beleuchtung, Intensität reduziert
    scene.add(new THREE.HemisphereLight(0xaaaaaa, 0x444444, 0.3)); // Himmel- und Bodenlicht, Intensität 0.3

    mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.7); // Intensität reduziert auf 0.7
    mainDirectionalLight.position.set(5, 10, 7).normalize().multiplyScalar(50);
    mainDirectionalLight.castShadow = true;
    mainDirectionalLight.shadow.mapSize.width = 1024;
    mainDirectionalLight.shadow.mapSize.height = 1024;
    mainDirectionalLight.shadow.camera.near = 0.5;
    mainDirectionalLight.shadow.camera.far = 50;
    const d = GRID * VS * 0.7;
    mainDirectionalLight.shadow.camera.left = -d;
    mainDirectionalLight.shadow.camera.right = d;
    mainDirectionalLight.shadow.camera.top = d;
    mainDirectionalLight.shadow.camera.bottom = -d;
    mainDirectionalLight.shadow.camera.updateProjectionMatrix();
    scene.add(mainDirectionalLight);

    const d2 = new THREE.DirectionalLight(0xffffff, 0.15); d2.position.set(-5, -5, -7).normalize(); scene.add(d2); // Intensität reduziert auf 0.15

    rebuildHelpers(); // Erstellt Grid und Box initial
    window.addEventListener('resize', onResize);
    onResize(); // Initial call to set size
    updateGridHelperPosition();

    // Initialize highlight mesh
    const planeGeometry = new THREE.PlaneGeometry(VS, VS);
    highlightMesh = new THREE.Mesh(planeGeometry, highlightMaterial);
    highlightMesh.renderOrder = 999; // Render on top of other objects
    // Do not add to scene initially, add when a face is highlighted

    /* Steuerung */
    let keys = {}, moveSpeed = 0.1, rotSpeed = 0.002;
    let euler = new THREE.Euler().setFromQuaternion(cam.quaternion, 'YXZ');
    
    const setModeDisplay = () => {
        const m = document.getElementById('current-mode');
        m.textContent = `Modus: ${currentMode}`;
        m.setAttribute('data-mode', currentMode); // Set data-mode attribute for CSS styling

        // Update container border based on mode
        container.setAttribute('data-mode', currentMode);
    };
    setModeDisplay();

    document.getElementById('modeToggle').onclick = () => {
        cycleMode();
        setModeDisplay();
    };

    // MODAL-HANDLING FÜR "ALLES LÖSCHEN"
    const clearConfirmationModal = document.getElementById('clearConfirmationModal');
    document.getElementById('clearBtn').onclick = () => {
        clearConfirmationModal.style.display = 'flex'; // Show modal
    };

    document.getElementById('saveAndClearBtn').onclick = () => {
        saveJSON(); // Save first
        clearAll(); // Then clear
        clearConfirmationModal.style.display = 'none'; // Hide modal
    };

    document.getElementById('clearWithoutSaveBtn').onclick = () => {
        clearAll(); // Clear directly
        clearConfirmationModal.style.display = 'none'; // Hide modal
    };

    document.getElementById('cancelClearBtn').onclick = () => {
        clearConfirmationModal.style.display = 'none'; // Hide modal
    };
    // ENDE MODAL-HANDLING

    document.getElementById('fillLevelBtn').onclick = fillActiveLevel;
    document.getElementById('saveBtn').onclick = saveJSON;
    document.getElementById('loadBtn').onclick = () => document.getElementById('fileInput').click();
    document.getElementById('fileInput').onchange = loadJSON;
    document.getElementById('exportStlBtn').onclick = exportSTL;

    // Gittergröße Slider Event Listener
    const gridSizeSlider = document.getElementById('grid-size-slider');
    const gridSizeDisplay = document.getElementById('grid-size-display');
    gridSizeSlider.value = GRID;
    gridSizeDisplay.textContent = `${GRID}×${GRID}×${GRID}`;

    // Set initial min slider value
    updateGridSliderMin(); // Call initially to set the correct min based on current voxels
    
    gridSizeSlider.oninput = (e) => {
        let newGridSize = parseInt(e.target.value, 10);
        const minAllowedGridSize = calculateMinGridSize();

        // Clamp the newGridSize to ensure it's not smaller than the minimum required
        if (newGridSize < minAllowedGridSize) {
            newGridSize = minAllowedGridSize;
            gridSizeSlider.value = newGridSize; // Update slider position
        }

        if (newGridSize !== GRID) {
            GRID = newGridSize;
            gridSizeDisplay.textContent = `${GRID}×${GRID}×${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
            rebuildHelpers();
            updateGridHelperPosition();

            // Kameraposition und Blickrichtung anpassen
            cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5);
            cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
            // Auch Schattenkamera anpassen
            const d_shadow = GRID * VS * 0.7; // Renamed to avoid conflict with 'd' in loop
            mainDirectionalLight.shadow.camera.left = -d_shadow;
            mainDirectionalLight.shadow.camera.right = d_shadow;
            mainDirectionalLight.shadow.camera.top = d_shadow;
            mainDirectionalLight.shadow.camera.bottom = -d_shadow;
            mainDirectionalLight.shadow.camera.updateProjectionMatrix();
        }
    };

    // Farbauswahl Event Listener
    const colorPicker = document.getElementById('color-picker');
    colorPicker.value = currentColor;
    colorPicker.oninput = (e) => {
        currentColor = e.target.value;
        localStorage.setItem('voxelEditorColor', currentColor);
        // Update the active preset color if one is active
        if (activePresetIndex !== -1) {
            presetColors[activePresetIndex] = currentColor;
            document.getElementById(`color-preset-${activePresetIndex + 1}`).style.backgroundColor = currentColor;
            localStorage.setItem(`voxelPresetColor${activePresetIndex + 1}`, currentColor);
        }
    };

    // Initialize preset color boxes and set initial active preset
    for (let i = 1; i <= 3; i++) {
        const presetBox = document.getElementById(`color-preset-${i}`);
        presetBox.style.backgroundColor = presetColors[i - 1]; // Set initial color
        presetBox.onclick = () => {
            setActivePreset(i - 1); // Set this preset as active
        };
        // Allow changing preset colors with the color picker context menu or double click
        presetBox.oncontextmenu = (e) => {
            e.preventDefault(); // Prevent default right-click menu
            // Temporarily set the color picker to the preset color's value for editing
            colorPicker.value = presetColors[i - 1];
            colorPicker.click(); // Open the color picker
            // When the color picker changes, its oninput handler will save the new color.
            // We need to specifically update the preset color too.
            const tempInputHandler = (event) => {
                presetColors[i - 1] = event.target.value;
                presetBox.style.backgroundColor = presetColors[i - 1];
                localStorage.setItem(`voxelPresetColor${i}`, presetColors[i - 1]);
                colorPicker.removeEventListener('input', tempInputHandler); // Clean up
                // After changing a preset, make sure the global currentColor and picker reflect it
                currentColor = presetColors[i - 1];
                colorPicker.value = currentColor;
                localStorage.setItem('voxelEditorColor', currentColor);
            };
            colorPicker.addEventListener('input', tempInputHandler);
        };
        presetBoxes.push(presetBox);
    }

    // Set the initial current color based on local storage, and then activate the corresponding preset if it matches.
    // This ensures the correct color is active if the user previously selected a preset and it was saved.
    const savedColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
    let matchedPreset = false;
    for(let i = 0; i < presetColors.length; i++) {
        // Compare hex codes (normalize to uppercase if needed for consistency)
        if (presetColors[i].toUpperCase() === savedColor.toUpperCase()) {
            setActivePreset(i);
            matchedPreset = true;
            break;
        }
    }
    if (!matchedPreset) {
        // If the saved color doesn't match any preset, ensure no preset is marked active.
        presetBoxes.forEach(box => box.classList.remove('active'));
        activePresetIndex = -1;
    }
    colorPicker.value = savedColor;
    currentColor = savedColor;


    // Help Toggle Button and Local Storage
    const infoBox = document.getElementById('infoBox');
    const helpToggleBtn = document.getElementById('helpToggleBtn');

    // Load initial visibility state from Local Storage
    // Default to 'false' (hidden) if not found in Local Storage
    // FIX: Corrected localStorage.Item to localStorage.getItem
    const helpVisible = localStorage.getItem('voxelEditorHelpVisible');
    if (helpVisible === 'true') {
        infoBox.style.display = 'block';
    } else {
        infoBox.style.display = 'none';
    }

    helpToggleBtn.onclick = () => {
        if (infoBox.style.display === 'none') {
            infoBox.style.display = 'block';
            localStorage.setItem('voxelEditorHelpVisible', 'true');
        } else {
            infoBox.style.display = 'none';
            localStorage.setItem('voxelEditorHelpVisible', 'false');
        }
    };

    cvs.oncontextmenu = e => e.preventDefault();

    cvs.onpointerdown = e => {
        if (e.button === 2) { // Right mouse button
            rotate = true;
            cvs.requestPointerLock();
            return;
        }
        if (e.button !== 0) return; // Only proceed if it's the left mouse button

        // Hide highlight mesh on click
        scene.remove(highlightMesh);

        // Set drag flags
        isShiftDragging = e.shiftKey;
        isControlDragging = e.ctrlKey || e.metaKey;

        // If it's a simple click (no shift/control)
        if (!isShiftDragging && !isControlDragging) {
            handleVoxelAction(e.clientX, e.clientY, currentMode, false, false); // Single placement
        } else if (isShiftDragging) {
            // Determine the fixed level based on hit or current drawing level
            const rect = cvs.getBoundingClientRect();
            const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1,
                -((e.clientY - rect.top) / rect.height) * 2 + 1);
            const ray = new THREE.Raycaster(); ray.setFromCamera(mouse, cam);
            const objs = [...voxels.values()].map(v => v.mesh);
            const hits = ray.intersectObjects(objs);

            // Determine the axis and initial fixed level
            if (e.altKey && e.shiftKey) { // Alt+Shift (Z-Achse)
                currentDrawingAxis = 'z';
                currentShiftDragLevel = hits.length > 0 ? Math.round(hits[0].object.position.z / VS - HALF) : activeDrawingLevel.z;
            } else if (e.altKey && (e.ctrlKey || e.metaKey)) { // Alt+Control (X-Achse)
                currentDrawingAxis = 'x';
                currentShiftDragLevel = hits.length > 0 ? Math.round(hits[0].object.position.x / VS - HALF) : activeDrawingLevel.x;
            } else { // Shift only (Y-Achse) - default
                currentDrawingAxis = 'y';
                currentShiftDragLevel = hits.length > 0 ? Math.round(hits[0].object.position.y / VS - HALF) : activeDrawingLevel.y;
            }
            // Clamp the initial fixed level to grid boundaries
            currentShiftDragLevel = Math.max(0, Math.min(GRID - 1, currentShiftDragLevel));

            // Perform the initial action on drag start for Shift-dragging
            handleVoxelAction(e.clientX, e.clientY, currentMode, true, false, currentShiftDragLevel, currentDrawingAxis);
        }
    };

    cvs.onpointermove = e => {
        if (rotate) { // Camera rotation with Right Mouse Button
            euler.y -= e.movementX * rotSpeed;
            euler.x -= e.movementY * rotSpeed;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            cam.quaternion.setFromEuler(euler);
        } else {
            // Face highlighting logic
            const rect = cvs.getBoundingClientRect();
            const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1,
                                            -((e.clientY - rect.top) / rect.height) * 2 + 1);
            const ray = new THREE.Raycaster();
            ray.setFromCamera(mouse, cam);
            
            const objs = [...voxels.values()].map(v => v.mesh);
            const hits = ray.intersectObjects(objs);

            if (hits.length > 0) {
                const hit = hits[0];
                const faceNormal = hit.face.normal;
                const voxelPosition = hit.object.position;

                // Calculate the position of the center of the hit face
                const faceCenter = new THREE.Vector3()
                    .copy(voxelPosition)
                    .add(faceNormal.multiplyScalar(HALF * VS));

                // Position the highlight mesh
                highlightMesh.position.copy(faceCenter);

                // Orient the highlight mesh to align with the face normal
                // Create a quaternion to represent the rotation from Z-axis to the face normal
                const quaternion = new THREE.Quaternion();
                // Ensure the plane is initially aligned with XY, then rotate it to face the normal
                // Face normals are unit vectors. This aligns the Z-axis of the plane (which is its normal) with the face normal.
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), faceNormal);
                highlightMesh.quaternion.copy(quaternion);

                // Add to scene if not already there
                if (!highlightMesh.parent) {
                    scene.add(highlightMesh);
                }
            } else {
                // No voxel hit, remove highlight
                if (highlightMesh.parent) {
                    scene.remove(highlightMesh);
                }
            }
        }

        if (e.buttons & 1) { // Left mouse button is down (for dragging actions)
            if (isShiftDragging && currentShiftDragLevel !== null) {
                // Shift-Drag: Apply action on the fixed level (for ADD, DELETE, DRAW)
                handleVoxelAction(e.clientX, e.clientY, currentMode, true, false, currentShiftDragLevel, currentDrawingAxis);
            } else if (isControlDragging && currentMode === Modes.ADD) {
                // Control-Drag (stacking add) - only in ADD mode
                handleVoxelAction(e.clientX, e.clientY, currentMode, true, true);
            }
            // Note: Normal left-click (single placement) does not trigger on move
        }
    };

    cvs.onpointerup = e => {
        if (e.button === 2) {
            rotate = false;
            document.exitPointerLock();
        }
        isShiftDragging = false;
        isControlDragging = false;
        currentShiftDragLevel = null; // Reset fixed level
        currentDrawingAxis = 'y'; // Reset drawing axis to default

        // Hide highlight mesh on mouse up
        if (highlightMesh.parent) {
            scene.remove(highlightMesh);
        }
    };

    cvs.addEventListener('wheel', e => {
        e.preventDefault();
        const step = e.deltaY > 0 ? -1 : 1;

        if (e.altKey) {
            if (e.shiftKey) {
                currentDrawingAxis = 'z';
                activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z + step));
            } else if (e.ctrlKey || e.metaKey) {
                currentDrawingAxis = 'x';
                activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x + step));
            } else {
                currentDrawingAxis = 'y';
                activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y + step));
            }
            updateGridHelperPosition();
        } else {
            // Adjusted sensitivity for camera speed
            moveSpeed *= e.deltaY < 0 ? 1.05 : 0.95; // Smaller steps for finer control
            moveSpeed = Math.max(0.005, Math.min(2, moveSpeed)); // Tighter min/max range
        }
    }, { passive: false });

    window.onkeydown = e => {
        keys[e.code] = true;
        if (e.code === 'Tab') {
            cycleMode();
            setModeDisplay();
            e.preventDefault();
        } else if (e.ctrlKey || e.metaKey) { // Check for Ctrl or Cmd key
            // Universal Undo/Redo using e.key (character output)
            if (e.key === 'z' || e.key === 'Z') { // Ctrl+Z or Ctrl+Shift+Z (for Z character)
                if (e.shiftKey) { // Ctrl+Shift+Z for Redo
                    redo();
                } else { // Ctrl+Z for Undo
                    undo();
                }
                e.preventDefault(); // Prevent browser undo/redo
            } else if (e.key === 'y' || e.key === 'Y') { // Ctrl+Y for Redo
                redo();
                e.preventDefault(); // Prevent browser undo/redo
            }
        } else if (e.code === 'Digit1') {
            setActivePreset(0);
        } else if (e.code === 'Digit2') {
            setActivePreset(1);
        } else if (e.code === 'Digit3') {
            setActivePreset(2);
        }
    };
    window.onkeyup = e => keys[e.code] = false;

    // Remove highlight mesh when mouse leaves the canvas
    cvs.onpointerleave = () => {
        if (highlightMesh.parent) {
            scene.remove(highlightMesh);
        }
    };

    /* Render-Loop */
    (function loop() {
        requestAnimationFrame(loop);
        const dir = new THREE.Vector3(); cam.getWorldDirection(dir);
        const right = new THREE.Vector3().crossVectors(dir, cam.up);
        const up = new THREE.Vector3().copy(cam.up); // Get the camera's up direction

        if (keys.KeyW) cam.position.addScaledVector(dir, moveSpeed);
        if (keys.KeyS) cam.position.addScaledVector(dir, -moveSpeed);
        if (keys.KeyA) cam.position.addScaledVector(right, -moveSpeed);
        if (keys.KeyD) cam.position.addScaledVector(right, moveSpeed);
        if (keys.KeyE) cam.position.addScaledVector(up, moveSpeed); // Move along camera's local up
        if (keys.KeyQ) cam.position.addScaledVector(up, -moveSpeed); // Move along camera's local down
        ren.render(scene, cam);
    })();
};

/* ---------- Hilfsfunktionen ---------- */
function onResize() {
    // Use the global 'container' variable here
    cam.aspect = container.clientWidth / container.clientHeight; cam.updateProjectionMatrix();
    ren.setSize(container.clientWidth, container.clientHeight);
}

function rebuildHelpers() {
    // Check if THREE is defined before using it in helper functions
    if (typeof THREE === 'undefined') {
        console.error("THREE is not defined in rebuildHelpers. Cannot rebuild helpers.");
        return;
    }

    if (gridHelper) scene.remove(gridHelper);
    if (boxHelper) scene.remove(boxHelper);

    const size = GRID * VS;

    if (currentDrawingAxis === 'y') {
        gridHelper = new THREE.GridHelper(size, GRID, 0xaaaaaa, 0xcccccc);
        gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else if (currentDrawingAxis === 'x') {
        gridHelper = new THREE.GridHelper(size, GRID, 0xaaaaaa, 0xcccccc);
        gridHelper.rotation.z = Math.PI / 2;
        gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
    } else if (currentDrawingAxis === 'z') {
        gridHelper = new THREE.GridHelper(size, GRID, 0xaaaaaa, 0xcccccc);
        gridHelper.rotation.x = Math.PI / 2;
        gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
    }
    scene.add(gridHelper);

    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2); scene.add(boxHelper);
}

function updateGridHelperPosition() {
    rebuildHelpers();
}

function key(cx, cy, cz) { return `${cx},${cy},${cz}`; }

function cycleMode() {
    switch (currentMode) {
        case Modes.ADD: currentMode = Modes.DELETE; break;
        case Modes.DELETE: currentMode = Modes.DRAW; break;
        case Modes.DRAW: currentMode = Modes.ADD; break;
    }
}

function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = presetColors[index];
        document.getElementById('color-picker').value = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor); // Save as current selected color

        // Update active class for visual feedback
        presetBoxes.forEach((box, i) => {
            if (i === index) {
                box.classList.add('active');
            } else {
                box.classList.remove('active');
            }
        });
        activePresetIndex = index; // Store which preset is active
    }
}

function addCommand(type, gx, gy, gz, oldColor = null, newColor = null, oldState = null, newState = null) {
    // Clear redo history
    if (historyPointer < history.length - 1) {
        history.splice(historyPointer + 1);
    }

    history.push({ type, gx, gy, gz, oldColor, newColor, oldState, newState });
    historyPointer++;

    // Limit history size
    if (history.length > MAX_HISTORY_SIZE) {
        history.shift();
        historyPointer--;
    }
    updateGridSliderMin(); // Re-evaluate min grid size after any voxel addition/deletion
}

function executeCommand(command, reverse = false) {
    const { type, gx, gy, gz, oldColor, newColor, oldState, newState } = command;
    
    switch (type) {
        case 'add':
            if (reverse) {
                removeVoxel(gx, gy, gz, true); // true to prevent re-adding to history
            } else {
                addVoxel(gx, gy, gz, newColor, true); // true to prevent re-adding to history
            }
            break;
        case 'delete':
            if (reverse) {
                addVoxel(gx, gy, gz, oldColor, true); // Re-add with original color
            } else {
                removeVoxel(gx, gy, gz, true);
            }
            break;
        case 'recolor':
            if (reverse) {
                recolorVoxel(gx, gy, gz, oldColor, true);
            } else {
                recolorVoxel(gx, gy, gz, newColor, true);
            }
            break;
        case 'clearAll':
            if (reverse) {
                // Restore old state from command's oldState
                clearAllInternal(true); // Clear current state first without history
                oldState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            } else {
                clearAllInternal(true); // Clear directly without history
            }
            break;
        case 'fillLevel':
            // For fillLevel, 'oldState' contains an array of voxels before fill, 'newState' after
            if (reverse) {
                // Restore state before the fill operation
                // To restore the state, we first remove all voxels that are in the newState
                // and then add back all voxels that were in the oldState.
                newState.forEach(v => {
                    removeVoxel(v.gx, v.gy, v.gz, true); // Remove voxels that were part of the 'new state' (the fill)
                });
                oldState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true)); // Add back voxels from the 'old state'
            } else {
                // Apply the fill operation (forward)
                // To apply the forward state, we clear current voxels that are not in newState
                // and then add/recolor according to newState.
                const currentVoxelKeys = new Set([...voxels.values()].map(v => key(v.gx, v.gy, v.gz)));
                const newStateKeys = new Set(newState.map(v => key(v.gx, v.gy, v.gz)));
                
                // Remove voxels that are currently present but not in the newState
                currentVoxelKeys.forEach(id => {
                    if (!newStateKeys.has(id)) {
                        const { gx, gy, gz } = voxels.get(id);
                        removeVoxel(gx, gy, gz, true);
                    }
                });

                // Add or recolor voxels as per newState
                newState.forEach(v => {
                    const existing = voxels.get(key(v.gx, v.gy, v.gz));
                    if (existing) {
                        recolorVoxel(v.gx, v.gy, v.gz, v.color, true);
                    } else {
                        addVoxel(v.gx, v.gy, v.gz, v.color, true);
                    }
                });
            }
            break;
    }
    updateGridSliderMin(); // Re-evaluate min grid size after any undo/redo operation
}

function undo() {
    if (historyPointer >= 0) {
        executeCommand(history[historyPointer], true); // Execute in reverse
        historyPointer--;
    }
}

function redo() {
    if (historyPointer < history.length - 1) {
        historyPointer++;
        executeCommand(history[historyPointer], false); // Execute forward
    }
}


function calculateMinGridSize() {
    if (voxels.size === 0) {
        return MIN_GRID_SIZE_ABSOLUTE;
    }
    let maxX = 0, maxY = 0, maxZ = 0;
    voxels.forEach(v => {
        maxX = Math.max(maxX, v.gx);
        maxY = Math.max(maxY, v.gy);
        maxZ = Math.max(maxZ, v.gz);
    });
    // The grid size needs to be 1 more than the max coordinate to contain it
    return Math.max(MIN_GRID_SIZE_ABSOLUTE, maxX + 1, maxY + 1, maxZ + 1);
}

function updateGridSliderMin() {
    const gridSizeSlider = document.getElementById('grid-size-slider');
    const minAllowedGridSize = calculateMinGridSize();
    gridSizeSlider.min = minAllowedGridSize;
    
    // If the current GRID value is less than the new min, update it
    if (GRID < minAllowedGridSize) {
        GRID = minAllowedGridSize;
        gridSizeSlider.value = GRID;
        document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
        localStorage.setItem('voxelEditorGridSize', GRID);
        rebuildHelpers();
        updateGridHelperPosition();

        // Adjust camera and shadow camera if grid size changed
        cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5);
        cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
        const d_shadow = GRID * VS * 0.7;
        mainDirectionalLight.shadow.camera.left = -d_shadow;
        mainDirectionalLight.shadow.camera.right = d_shadow;
        mainDirectionalLight.shadow.camera.top = d_shadow;
        mainDirectionalLight.shadow.camera.bottom = -d_shadow;
        mainDirectionalLight.shadow.camera.updateProjectionMatrix();
    }
}


function handleVoxelAction(clientX, clientY, mode, isDragging, isControlDown, fixedLevel = null, fixedAxis = null) {
    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
        -((clientY - rect.top) / rect.height) * 2 + 1);
    const ray = new THREE.Raycaster(); ray.setFromCamera(mouse, cam);
    const objs = [...voxels.values()].map(v => v.mesh);
    const hits = ray.intersectObjects(objs);

    let targetGx, targetGy, targetGz;

    if (fixedLevel !== null && fixedAxis !== null) { // Shift-Drag: actions confined to a fixed plane
        let planeNormal = new THREE.Vector3();
        let planeConstant;

        // Define the plane based on fixedAxis and fixedLevel
        if (fixedAxis === 'y') {
            planeNormal.set(0, 1, 0);
            planeConstant = - (fixedLevel * VS); // Y-level in world coordinates
        } else if (fixedAxis === 'x') {
            planeNormal.set(1, 0, 0);
            planeConstant = - (fixedLevel * VS); // X-level in world coordinates
        } else if (fixedAxis === 'z') {
            planeNormal.set(0, 0, 1);
            planeConstant = - (fixedLevel * VS); // Z-level in world coordinates
        }

        const fixedPlane = new THREE.Plane(planeNormal, planeConstant);
        const intersectionPoint = new THREE.Vector3();

        if (ray.ray.intersectPlane(fixedPlane, intersectionPoint)) {
            // Convert intersection point to grid coordinates, applying half-voxel offset for centering
            targetGx = Math.round(intersectionPoint.x / VS - HALF);
            targetGy = Math.round(intersectionPoint.y / VS - HALF);
            targetGz = Math.round(intersectionPoint.z / VS - HALF);

            // Correct the coordinate that defines the fixed plane
            if (fixedAxis === 'y') targetGy = fixedLevel;
            else if (fixedAxis === 'x') targetGx = fixedLevel;
            else if (fixedAxis === 'z') targetGz = fixedLevel;

            // Clamp coordinates to grid boundaries (always apply after calculation)
            targetGx = Math.max(0, Math.min(GRID - 1, targetGx));
            targetGy = Math.max(0, Math.min(GRID - 1, targetGy));
            targetGz = Math.max(0, Math.min(GRID - 1, targetGz));

            const voxelAtTarget = voxels.get(key(targetGx, targetGy, targetGz));

            if (mode === Modes.ADD) {
                if (voxelAtTarget) {
                    if (voxelAtTarget.color !== currentColor) {
                        recolorVoxel(targetGx, targetGy, targetGz, currentColor);
                    }
                } else {
                    addVoxel(targetGx, targetGy, targetGz);
                }
            } else if (mode === Modes.DELETE) {
                if (voxelAtTarget) {
                    removeVoxel(targetGx, targetGy, targetGz);
                }
            } else if (mode === Modes.DRAW) {
                if (voxelAtTarget && voxelAtTarget.color !== currentColor) {
                    recolorVoxel(targetGx, targetGy, targetGz, currentColor);
                }
            }
        } else {
            return; // Ray did not intersect the fixed plane
        }

    } else if (isControlDown && isDragging && mode === Modes.ADD) { // Control-Drag (stacking add)
        if (hits.length) {
            const hitVoxelGx = Math.round(hits[0].object.position.x / VS - HALF);
            const hitVoxelGy = Math.round(hits[0].object.position.y / VS - HALF);
            const hitVoxelGz = Math.round(hits[0].object.position.z / VS - HALF);
            const normal = hits[0].face.normal;

            targetGx = hitVoxelGx + normal.x;
            targetGy = hitVoxelGy + normal.y;
            targetGz = hitVoxelGz + normal.z;
        } else {
            // If control-dragging on empty space, treat as adding to layer 0
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0), p = new THREE.Vector3();
            if (ray.ray.intersectPlane(plane, p)) {
                targetGx = Math.round(p.x / VS - HALF);
                targetGy = 0; // Fixed at Y=0
                targetGz = Math.round(p.z / VS - HALF);
            } else {
                return;
            }
        }
        // Clamp coordinates to grid boundaries
        targetGx = Math.max(0, Math.min(GRID - 1, targetGx));
        targetGy = Math.max(0, Math.min(GRID - 1, targetGy));
        targetGz = Math.max(0, Math.min(GRID - 1, targetGz));

        // Only add if the target position is empty or color is different
        const voxelAtTarget = voxels.get(key(targetGx, targetGy, targetGz));
        if (voxelAtTarget) {
            if (voxelAtTarget.color !== currentColor) {
                recolorVoxel(targetGx, targetGy, targetGz, currentColor);
            }
        } else {
            addVoxel(targetGx, targetGy, targetGz);
        }

    } else { // Default action (non-shift, non-control click or drag) - operate freely in 3D
        if (hits.length) {
            const p = hits[0].object.position;
            targetGx = Math.round(p.x / VS - HALF);
            targetGy = Math.round(p.y / VS - HALF);
            targetGz = Math.round(p.z / VS - HALF);

            if (mode === Modes.ADD) {
                const normal = hits[0].face.normal;
                targetGx = targetGx + normal.x;
                targetGy = targetGy + normal.y;
                targetGz = targetGz + normal.z;
            }
            // Clamp coordinates to grid boundaries
            targetGx = Math.max(0, Math.min(GRID - 1, targetGx));
            targetGy = Math.max(0, Math.min(GRID - 1, targetGy));
            targetGz = Math.max(0, Math.min(GRID - 1, targetGz));

            if (mode === Modes.ADD) {
                const voxelAtTarget = voxels.get(key(targetGx, targetGy, targetGz));
                if (voxelAtTarget) {
                    if (voxelAtTarget.color !== currentColor) {
                        recolorVoxel(targetGx, targetGy, targetGz, currentColor);
                    }
                } else {
                    addVoxel(targetGx, targetGy, targetGz);
                }
            } else if (mode === Modes.DELETE) {
                if (voxels.has(key(targetGx, targetGy, targetGz))) {
                    removeVoxel(targetGx, targetGy, targetGz);
                }
            } else if (mode === Modes.DRAW) {
                if (voxels.has(key(targetGx, targetGy, targetGz))) {
                    const existingVoxel = voxels.get(key(targetGx, targetGy, targetGz));
                    if (existingVoxel.color !== currentColor) {
                        recolorVoxel(targetGx, targetGy, targetGz, currentColor);
                    }
                }
            }
        } else {
            // If nothing is hit, and it's ADD mode, default to layer 0 for single clicks/drags without shift/ctrl
            if (mode === Modes.ADD) {
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0), p = new THREE.Vector3();
                if (ray.ray.intersectPlane(plane, p)) {
                    targetGx = Math.round(p.x / VS - HALF);
                    targetGy = 0; // Fixed at Y=0
                    targetGz = Math.round(p.z / VS - HALF);

                    // Clamp coordinates to grid boundaries
                    targetGx = Math.max(0, Math.min(GRID - 1, targetGx));
                    targetGy = Math.max(0, Math.min(GRID - 1, targetGy));
                    targetGz = Math.max(0, Math.min(GRID - 1, targetGz));

                    const voxelAtTarget = voxels.get(key(targetGx, targetGy, targetGz));
                    if (voxelAtTarget) {
                        if (voxelAtTarget.color !== currentColor) {
                            recolorVoxel(targetGx, targetGy, targetGz, currentColor);
                        }
                    } else {
                        addVoxel(targetGx, targetGy, targetGz);
                    }
                } else {
                    return; // Ray did not intersect the default plane (e.g., looking too far up)
                }
            } else { // For DELETE and DRAW, if nothing is hit, do nothing
                return;
            }
        }
    }
}


/* ---------- Voxel-Operationen ---------- */
// The `fromHistory` parameter prevents adding operations triggered by undo/redo to the history again
function addVoxel(gx, gy, gz, color = currentColor, fromHistory = false) {
    const id = key(gx, gy, gz);
    if (gx < 0 || gx >= GRID || gy < 0 || gy >= GRID || gz < 0 || gz >= GRID) return;

    if (voxels.has(id)) {
        // If voxel already exists, recolor it instead of re-adding
        recolorVoxel(gx, gy, gz, color, fromHistory);
        return;
    }

    const cx = (gx + HALF) * VS;
    const cy = (gy + HALF) * VS;
    const cz = (gz + HALF) * VS;

    const material = new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.9,
        metalness: 0.0
    });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(VS, VS, VS), material);
    mesh.position.set(cx, cy, cz);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);

    voxels.set(id, { mesh, gx, gy, gz, color });

    if (!fromHistory) {
        addCommand('add', gx, gy, gz, null, color);
    }
}

function recolorVoxel(gx, gy, gz, newColor, fromHistory = false) {
    const id = key(gx, gy, gz);
    if (!voxels.has(id)) {
        return;
    }
    const voxel = voxels.get(id);
    const oldColor = voxel.color;
    if (oldColor === newColor) return; // No change, no history entry

    voxel.mesh.material.color.set(newColor);
    voxel.color = newColor; // Update color in voxel data

    if (!fromHistory) {
        addCommand('recolor', gx, gy, gz, oldColor, newColor);
    }
}


function removeVoxel(gx, gy, gz, fromHistory = false) {
    const id = key(gx, gy, gz);
    if (!voxels.has(id)) return;

    const { mesh, color } = voxels.get(id);
    scene.remove(mesh);
    mesh.geometry.dispose();
    if (mesh.material) {
        mesh.material.dispose();
    }
    voxels.delete(id);

    if (!fromHistory) {
        addCommand('delete', gx, gy, gz, color); // Store color for redo/undo
    }
}

// Internal function for clearing, used by undo/redo and the confirmation dialog
function clearAllInternal(fromHistory = false) {
    voxels.forEach(v => {
        scene.remove(v.mesh);
        v.mesh.geometry.dispose();
        if (v.mesh.material) {
            v.mesh.material.dispose();
        }
    });
    voxels.clear();

    if (!fromHistory) { // Only update slider min if not part of history operation
        updateGridSliderMin();
    }
}

// Public function that triggers the confirmation or directly clears if fromHistory
function clearAll(fromHistory = false) {
    if (!fromHistory) {
        const oldState = [...voxels.values()].map(v => ({ gx: v.gx, gy: v.gy, gz: v.gz, color: v.color }));
        addCommand('clearAll', null, null, null, null, null, oldState);
    }
    clearAllInternal(fromHistory); // Call the internal function to do the actual clearing
}

function fillActiveLevel(fromHistory = false) {
    // Capture the state before the fill operation for undo
    const oldState = [...voxels.values()].map(v => ({ gx: v.gx, gy: v.gy, gz: v.gz, color: v.color }));

    const voxelsToProcess = []; // Store operations (add or recolor)

    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let gx, gy, gz;
            if (currentDrawingAxis === 'y') {
                gx = x; gy = activeDrawingLevel.y; gz = z;
            } else if (currentDrawingAxis === 'x') {
                gx = activeDrawingLevel.x; gy = x; gz = z; // x becomes fixed, y and z iterate
            } else if (currentDrawingAxis === 'z') {
                gx = x; gy = z; gz = activeDrawingLevel.z; // z becomes fixed, x and y iterate
            }

            const id = key(gx, gy, gz);
            const existingVoxel = voxels.get(id);

            if (existingVoxel) {
                if (existingVoxel.color !== currentColor) {
                    voxelsToProcess.push({ type: 'recolor', gx, gy, gz, newColor: currentColor });
                }
            } else {
                voxelsToProcess.push({ type: 'add', gx, gy, gz, newColor: currentColor });
            }
        }
    }

    // Now apply changes for the current "fill" action
    voxelsToProcess.forEach(op => {
        if (op.type === 'add') {
            addVoxel(op.gx, op.gy, op.gz, op.newColor, true); // True for fromHistory
        } else if (op.type === 'recolor') {
            recolorVoxel(op.gx, op.gy, op.gz, op.newColor, true); // True for fromHistory
        }
    });

    // Capture the state *after* the fill operation for redo
    const newState = [...voxels.values()].map(v => ({ gx: v.gx, gy: v.gy, gz: v.gz, color: v.color }));

    if (!fromHistory) {
        addCommand('fillLevel', null, null, null, null, null, oldState, newState);
    }
}


function saveJSON() {
    const data = {
        gridSize: GRID,
        voxels: []
    };
    voxels.forEach(v => {
        data.voxels.push({ gx: v.gx, gy: v.gy, gz: v.gz, color: v.color });
    });
    const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'voxel_project.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function loadJSON(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            if (data.gridSize && data.voxels) {
                // Clear current scene and history before loading new project
                clearAll(true); // Clear without adding to history
                history.length = 0; // Clear undo/redo history completely
                historyPointer = -1;

                GRID = data.gridSize;
                // Clamp loaded GRID to ensure it's at least MIN_GRID_SIZE_ABSOLUTE
                if (GRID < MIN_GRID_SIZE_ABSOLUTE) {
                    GRID = MIN_GRID_SIZE_ABSOLUTE;
                }
                
                document.getElementById('grid-size-slider').value = GRID;
                document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
                localStorage.setItem('voxelEditorGridSize', GRID);
                
                // Add voxels first, then update min slider, then potentially adjust GRID again if needed
                data.voxels.forEach(v => {
                    addVoxel(v.gx, v.gy, v.gz, v.color, true); // Add without history, so addCommand doesn't update min here
                });

                // After all voxels are loaded, calculate and set the slider's minimum
                updateGridSliderMin(); 
                
                // Ensure GRID is large enough for loaded voxels (in case loaded grid was too small)
                const minRequiredGridSize = calculateMinGridSize();
                if (GRID < minRequiredGridSize) {
                    GRID = minRequiredGridSize;
                    document.getElementById('grid-size-slider').value = GRID;
                    document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
                    localStorage.setItem('voxelEditorGridSize', GRID);
                }


                rebuildHelpers(); // Rebuild helpers with new grid size
                updateGridHelperPosition();

                // Adjust camera for new grid size
                cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5);
                cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
                const d_shadow = GRID * VS * 0.7;
                mainDirectionalLight.shadow.camera.left = -d_shadow;
                mainDirectionalLight.shadow.camera.right = d_shadow;
                mainDirectionalLight.shadow.camera.top = d_shadow;
                mainDirectionalLight.shadow.camera.bottom = -d_shadow;
                mainDirectionalLight.shadow.camera.updateProjectionMatrix();


                console.log('Projekt erfolgreich geladen!');
            } else {
                alert('Ungültiges Dateiformat. Die JSON-Datei muss "gridSize" und "voxels" enthalten.');
            }
        } catch (error) {
            console.error('Fehler beim Laden der JSON-Datei:', error);
            alert('Fehler beim Laden der Datei. Stellen Sie sicher, dass es eine gültige JSON-Datei ist.');
        }
    };
    reader.readAsText(file);
}

function exportSTL() {
    if (voxels.size === 0) {
        alert('Keine Voxel zum Exportieren vorhanden!');
        return;
    }

    // Ensure STLExporter is available. It should be if scripts are loaded correctly.
    if (typeof THREE.STLExporter === 'undefined') {
        console.error("THREE.STLExporter ist nicht definiert. Der STL Export ist nicht möglich.");
        alert("Fehler: STLExporter konnte nicht geladen werden. Der Export ist nicht möglich.");
        return;
    }

    const exporter = new THREE.STLExporter(); // Use THREE.STLExporter as it's attached to THREE

    const geometries = [];

    voxels.forEach(v => {
        // Create a temporary mesh for each voxel to get its geometry and transform
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(VS, VS, VS));
        mesh.position.copy(v.mesh.position);
        mesh.updateMatrixWorld(true); // Ensure matrix is up-to-date
        geometries.push(mesh.geometry.clone().applyMatrix4(mesh.matrixWorld));
    });

    let mergedGeometry;
    if (geometries.length > 0) {
        // Ensure BufferGeometryUtils is available.
        if (typeof THREE.BufferGeometryUtils === 'undefined') {
            console.error("THREE.BufferGeometryUtils ist nicht definiert. Der Export ist nicht möglich.");
            alert("Fehler: BufferGeometryUtils konnte nicht geladen werden. Der Export ist nicht möglich.");
            return;
        }
        mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
    } else {
        alert('Keine Voxel zum Exportieren vorhanden!');
        return;
    }

    const dummyMesh = new THREE.Mesh(mergedGeometry);
    const stlString = exporter.parse(dummyMesh);

    const blob = new Blob([stlString], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'voxel_model.stl';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
</script>
</body>
</html>
