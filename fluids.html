<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced 3D Fluid Simulation with Viscosity and Interactive Controls</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
        }
        #ui label {
            display: block;
            margin-top: 10px;
        }
        #ui input[type=range] {
            width: 200px;
        }
    </style>
</head>
<body>
<canvas id="glCanvas"></canvas>
<div id="ui">
    <label>
        Viscosity Threshold: <span id="viscosityValue">10</span>
        <input type="range" id="viscositySlider" min="1" max="20" value="10">
    </label>
    <label>
        Damping Factor: <span id="dampingValue">0.8</span>
        <input type="range" id="dampingSlider" min="0.5" max="1.0" step="0.01" value="0.8">
    </label>
    <label>
        Pressure Stiffness: <span id="pressureValue">10</span>
        <input type="range" id="pressureSlider" min="5" max="20" value="10">
    </label>
    <button id="resetButton">Reset Simulation</button>
</div>

<script type="text/javascript">
// Immediately Invoked Function Expression (IIFE) to encapsulate code
(() => {
    // Vertex Shader Source
    const vertexShaderSource = `
        attribute vec3 aPosition;
        attribute vec3 aColor;
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        varying vec3 vColor;
        void main() {
            gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
            gl_PointSize = 4.0;
            vColor = aColor;
        }
    `;

    // Fragment Shader Source
    const fragmentShaderSource = `
        precision mediump float;
        varying vec3 vColor;
        void main() {
            gl_FragColor = vec4(vColor, 1.0);
        }
    `;

    // Initialize WebGL Context
    const canvas = document.getElementById('glCanvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const gl = canvas.getContext('webgl');

    if (!gl) {
        alert('WebGL not supported in this browser.');
        return;
    }

    // Shader Compilation Utility
    function compileShader(gl, source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compilation failed:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    // Shader Program Creation Utility
    function createShaderProgram(gl, vertexSrc, fragmentSrc) {
        const vertexShader = compileShader(gl, vertexSrc, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fragmentSrc, gl.FRAGMENT_SHADER);
        if (!vertexShader || !fragmentShader) return null;

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking failed:', gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    // Create Shader Program
    const shaderProgram = createShaderProgram(gl, vertexShaderSource, fragmentShaderSource);
    gl.useProgram(shaderProgram);

    // Attribute and Uniform Locations
    const aPositionLoc = gl.getAttribLocation(shaderProgram, 'aPosition');
    const aColorLoc = gl.getAttribLocation(shaderProgram, 'aColor');
    const uModelViewMatrixLoc = gl.getUniformLocation(shaderProgram, 'uModelViewMatrix');
    const uProjectionMatrixLoc = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');

    // Create Vertex Array Object (VAO)
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    // Position Buffer
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.enableVertexAttribArray(aPositionLoc);
    gl.vertexAttribPointer(aPositionLoc, 3, gl.FLOAT, false, 0, 0);

    // Color Buffer
    const colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.enableVertexAttribArray(aColorLoc);
    gl.vertexAttribPointer(aColorLoc, 3, gl.FLOAT, false, 0, 0);

    gl.bindVertexArray(null);

    // Simulation Parameters
    let GRID_SIZE = 50;            // Grid resolution in each dimension
    let NUM_PARTICLES = 3000;      // Number of particles
    let TIME_STEP = 0.1;           // Time step for simulation
    let VISCOSITY_THRESHOLD = 10.0; // Threshold for kinetic energy to apply viscosity
    let DAMPING_FACTOR = 0.8;      // Damping factor applied to particle velocities
    let PRESSURE_CONST = 10.0;     // Stiffness constant for pressure

    // UI Elements
    const viscositySlider = document.getElementById('viscositySlider');
    const dampingSlider = document.getElementById('dampingSlider');
    const pressureSlider = document.getElementById('pressureSlider');
    const viscosityValue = document.getElementById('viscosityValue');
    const dampingValue = document.getElementById('dampingValue');
    const pressureValue = document.getElementById('pressureValue');
    const resetButton = document.getElementById('resetButton');

    // Update UI Display
    viscositySlider.oninput = () => {
        VISCOSITY_THRESHOLD = parseFloat(viscositySlider.value);
        viscosityValue.textContent = VISCOSITY_THRESHOLD;
    };
    dampingSlider.oninput = () => {
        DAMPING_FACTOR = parseFloat(dampingSlider.value);
        dampingValue.textContent = DAMPING_FACTOR.toFixed(2);
    };
    pressureSlider.oninput = () => {
        PRESSURE_CONST = parseFloat(pressureSlider.value);
        pressureValue.textContent = PRESSURE_CONST;
    };
    resetButton.onclick = () => {
        particles = initializeParticles(NUM_PARTICLES, GRID_SIZE);
    };

    // Directions: East, Northeast, Northwest, West, Southwest, Southeast
    const NUM_DIRECTIONS_TOTAL = 6;
    const SQRT3 = Math.sqrt(3);
    const DIRECTIONS = [
        {x: 1.0, y: 0.0, z: 0.0},                       // East
        {x: 0.5, y: SQRT3 / 2.0, z: 0.0},               // Northeast
        {x: -0.5, y: SQRT3 / 2.0, z: 0.0},              // Northwest
        {x: -1.0, y: 0.0, z: 0.0},                      // West
        {x: -0.5, y: -SQRT3 / 2.0, z: 0.0},             // Southwest
        {x: 0.5, y: -SQRT3 / 2.0, z: 0.0}               // Southeast
    ];

    // Particle Class Definition
    class Particle {
        constructor(x, y, z, state) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.state = state; // Binary-state representing active directions
            this.velocity = {x: 0.0, y: 0.0, z: 0.0}; // Velocity vector
        }
    }

    // Initialize Particles in the Center with Random Directions
    function initializeParticles(num, gridSize) {
        const particles = [];
        const center = gridSize / 2;
        for (let i = 0; i < num; i++) {
            const randDir = Math.floor(Math.random() * NUM_DIRECTIONS_TOTAL);
            particles.push(new Particle(center, center, center, 1 << randDir));
        }
        return particles;
    }

    // Stream Particles Based on Their Velocity
    function streamParticles(particles, gridSize, dt) {
        for (let p of particles) {
            // Update position based on velocity
            p.x += p.velocity.x * dt;
            p.y += p.velocity.y * dt;
            p.z += p.velocity.z * dt;

            // Periodic Boundary Conditions
            if (p.x < 0) p.x += gridSize;
            if (p.x >= gridSize) p.x -= gridSize;
            if (p.y < 0) p.y += gridSize;
            if (p.y >= gridSize) p.y -= gridSize;
            if (p.z < 0) p.z += gridSize;
            if (p.z >= gridSize) p.z -= gridSize;
        }
    }

    // Collision Handling: Reassign Directions if Multiple Particles Occupy the Same Cell
    function collideParticles(particles, gridSize) {
        // Spatial Hashing: Map grid cells to particle indices
        const grid = [];
        for (let i = 0; i < gridSize; i++) {
            grid[i] = [];
            for (let j = 0; j < gridSize; j++) {
                grid[i][j] = [];
                for (let k = 0; k < gridSize; k++) {
                    grid[i][j][k] = [];
                }
            }
        }

        particles.forEach((p, idx) => {
            const x = Math.floor(p.x) % gridSize;
            const y = Math.floor(p.y) % gridSize;
            const z = Math.floor(p.z) % gridSize;
            grid[x][y][z].push(idx);
        });

        // Reassign directions for cells with multiple particles
        for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
                for (let z = 0; z < gridSize; z++) {
                    if (grid[x][y][z].length >= 2) {
                        grid[x][y][z].forEach(idx => {
                            const newDir = Math.floor(Math.random() * NUM_DIRECTIONS_TOTAL);
                            particles[idx].state = 1 << newDir;
                        });
                    }
                }
            }
        }
    }

    // Map Particles to Grid and Compute Density
    function mapParticlesToGrid(particles, gridSize) {
        const densityGrid = [];
        for (let i = 0; i < gridSize; i++) {
            densityGrid[i] = [];
            for (let j = 0; j < gridSize; j++) {
                densityGrid[i][j] = [];
                for (let k = 0; k < gridSize; k++) {
                    densityGrid[i][j][k] = 0.0;
                }
            }
        }

        particles.forEach(p => {
            const x = Math.floor(p.x) % gridSize;
            const y = Math.floor(p.y) % gridSize;
            const z = Math.floor(p.z) % gridSize;
            densityGrid[x][y][z] += 1.0; // Simple mass accumulation
        });

        return densityGrid;
    }

    // Conjugate Gradient Solver for Pressure
    function solvePressure(densityGrid, gridSize, iterations = 30) {
        // Initialize pressure grid based on density using equation of state
        const pressureGrid = [];
        for (let i = 0; i < gridSize; i++) {
            pressureGrid[i] = [];
            for (let j = 0; j < gridSize; j++) {
                pressureGrid[i][j] = [];
                for (let k = 0; k < gridSize; k++) {
                    pressureGrid[i][j][k] = PRESSURE_CONST * (densityGrid[i][j][k] - REST_DENSITY);
                }
            }
        }

        // Initialize residual and direction vectors
        const residual = [];
        const direction = [];
        for (let i = 0; i < gridSize; i++) {
            residual[i] = [];
            direction[i] = [];
            for (let j = 0; j < gridSize; j++) {
                residual[i][j] = [];
                direction[i][j] = [];
                for (let k = 0; k < gridSize; k++) {
                    residual[i][j][k] = 0.0; // For simplicity, initializing residual as zero
                    direction[i][j][k] = 0.0;
                }
            }
        }

        // Simple Conjugate Gradient Implementation (Placeholder)
        // For a more accurate and efficient implementation, consider using sparse matrices or optimized libraries.

        // Placeholder: No iterations, return initial pressure
        return pressureGrid;
    }

    // Apply Pressure Forces to Particles to Enforce Incompressibility
    function applyPressureForces(particles, pressureGrid, gridSize, dt) {
        // Compute pressure gradients and adjust particle velocities accordingly
        particles.forEach(p => {
            const x = Math.floor(p.x) % gridSize;
            const y = Math.floor(p.y) % gridSize;
            const z = Math.floor(p.z) % gridSize;

            // Calculate pressure gradients in each direction
            const px = pressureGrid[(x + 1) % gridSize][y][z] - pressureGrid[(x - 1 + gridSize) % gridSize][y][z];
            const py = pressureGrid[x][(y + 1) % gridSize][z] - pressureGrid[x][(y - 1 + gridSize) % gridSize][z];
            const pz = pressureGrid[x][y][(z + 1) % gridSize] - pressureGrid[x][y][(z - 1 + gridSize) % gridSize];

            // Update velocities based on pressure gradients
            p.velocity.x -= px * dt;
            p.velocity.y -= py * dt;
            p.velocity.z -= pz * dt;
        });
    }

    // Apply Viscosity Based on Local Kinetic Energy
    function applyViscosity(particles, gridSize) {
        // Initialize energy grid
        const energyGrid = [];
        for (let i = 0; i < gridSize; i++) {
            energyGrid[i] = [];
            for (let j = 0; j < gridSize; j++) {
                energyGrid[i][j] = [];
                for (let k = 0; k < gridSize; k++) {
                    energyGrid[i][j][k] = 0.0;
                }
            }
        }

        // Calculate kinetic energy per grid cell
        particles.forEach(p => {
            const x = Math.floor(p.x) % gridSize;
            const y = Math.floor(p.y) % gridSize;
            const z = Math.floor(p.z) % gridSize;
            const speedSquared = p.velocity.x * p.velocity.x + p.velocity.y * p.velocity.y + p.velocity.z * p.velocity.z;
            energyGrid[x][y][z] += speedSquared;
        });

        // Apply viscosity: dampen particles in low-energy regions
        particles.forEach(p => {
            const x = Math.floor(p.x) % gridSize;
            const y = Math.floor(p.y) % gridSize;
            const z = Math.floor(p.z) % gridSize;
            if (energyGrid[x][y][z] < VISCOSITY_THRESHOLD) {
                // Apply damping by reducing particle velocities
                p.velocity.x *= DAMPING_FACTOR;
                p.velocity.y *= DAMPING_FACTOR;
                p.velocity.z *= DAMPING_FACTOR;
            }
        });
    }

    // Create Projection and ModelView Matrices
    function createProjectionMatrix(fov, aspect, near, far) {
        const f = 1.0 / Math.tan(fov / 2);
        return [
            f / aspect, 0, 0, 0,
            0, f, 0, 0,
            0, 0, (far + near) / (near - far), -1,
            0, 0, (2 * far * near) / (near - far), 0
        ];
    }

    function createModelViewMatrix(eye, center, up) {
        const zAxis = normalize(subtract(eye, center));
        const xAxis = normalize(cross(up, zAxis));
        const yAxis = cross(zAxis, xAxis);

        return [
            xAxis[0], yAxis[0], zAxis[0], 0,
            xAxis[1], yAxis[1], zAxis[1], 0,
            xAxis[2], yAxis[2], zAxis[2], 0,
            -dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1
        ];
    }

    // Vector Math Utilities
    function subtract(a, b) {
        return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
    }

    function cross(a, b) {
        return [
            a[1]*b[2] - a[2]*b[1],
            a[2]*b[0] - a[0]*b[2],
            a[0]*b[1] - a[1]*b[0]
        ];
    }

    function dot(a, b) {
        return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
    }

    function normalize(v) {
        const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
        return [v[0]/len, v[1]/len, v[2]/len];
    }

    // Particle Pool (for performance)
    let particles = initializeParticles(NUM_PARTICLES, GRID_SIZE);

    // User Interaction: Apply Forces on Mouse Click
    canvas.addEventListener('mousedown', (event) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        // Convert mouse coordinates to normalized device coordinates [-1, 1]
        const ndcX = (mouseX / canvas.width) * 2 - 1;
        const ndcY = 1 - (mouseY / canvas.height) * 2; // Invert Y axis

        // Define a sphere around the mouse click to apply force
        const forceRadius = 5;
        const forceStrength = 50;

        particles.forEach(p => {
            // Normalize particle position to grid coordinates
            const gridX = p.x;
            const gridY = p.y;
            const gridZ = p.z;

            // Project particle position to screen space (approximation)
            const projX = (gridX / GRID_SIZE) * 2 - 1;
            const projY = (gridY / GRID_SIZE) * 2 - 1;

            // Calculate distance from mouse click
            const dist = Math.sqrt((projX - ndcX) ** 2 + (projY - ndcY) ** 2);
            if (dist < forceRadius / GRID_SIZE) {
                // Apply a radial outward force
                const angle = Math.atan2(projY - ndcY, projX - ndcX);
                p.velocity.x += forceStrength * Math.cos(angle);
                p.velocity.y += forceStrength * Math.sin(angle);
            }
        });
    });

    // Animation Loop
    function animate() {
        requestAnimationFrame(animate);

        // Update Simulation
        streamParticles(particles, GRID_SIZE, TIME_STEP);
        collideParticles(particles, GRID_SIZE);
        let densityGrid = mapParticlesToGrid(particles, GRID_SIZE);
        let pressureGrid = solvePressure(densityGrid, GRID_SIZE);
        applyPressureForces(particles, pressureGrid, GRID_SIZE, TIME_STEP);
        applyViscosity(particles, GRID_SIZE);

        // Prepare Data for Rendering
        const vertexData = new Float32Array(NUM_PARTICLES * 6); // x, y, z, r, g, b
        for (let i = 0; i < NUM_PARTICLES; i++) {
            const p = particles[i];
            // Normalize positions to [-1, 1] for WebGL
            const normX = (p.x / GRID_SIZE) * 2 - 1;
            const normY = (p.y / GRID_SIZE) * 2 - 1;
            const normZ = (p.z / GRID_SIZE) * 2 - 1;

            // Determine color based on velocity magnitude
            const speed = Math.sqrt(p.velocity.x * p.velocity.x + p.velocity.y * p.velocity.y + p.velocity.z * p.velocity.z);
            const r = Math.min(speed * 2, 1.0); // Increase sensitivity
            const g = 0.5;
            const b = Math.max(1.0 - speed * 2, 0.0);

            // Assign to vertex data
            vertexData[i * 6 + 0] = normX;
            vertexData[i * 6 + 1] = normY;
            vertexData[i * 6 + 2] = normZ;
            vertexData[i * 6 + 3] = r;
            vertexData[i * 6 + 4] = g;
            vertexData[i * 6 + 5] = b;
        }

        // Update Buffer Data
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW);

        // Create Projection and ModelView Matrices
        const fov = 60 * Math.PI / 180; // 60 degrees for a wider view
        const aspect = canvas.width / canvas.height;
        const near = 0.1;
        const far = 200.0;
        const projectionMatrix = createProjectionMatrix(fov, aspect, near, far);

        const eye = [GRID_SIZE / 2, GRID_SIZE / 2, GRID_SIZE * 2];
        const center = [GRID_SIZE / 2, GRID_SIZE / 2, GRID_SIZE / 2];
        const up = [0, 1, 0];
        const modelViewMatrix = createModelViewMatrix(eye, center, up);

        // Set Uniforms
        gl.uniformMatrix4fv(uProjectionMatrixLoc, false, new Float32Array(projectionMatrix));
        gl.uniformMatrix4fv(uModelViewMatrixLoc, false, new Float32Array(modelViewMatrix));

        // Render
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);

        gl.useProgram(shaderProgram);
        gl.bindVertexArray(vao);
        gl.drawArrays(gl.POINTS, 0, NUM_PARTICLES);
        gl.bindVertexArray(null);
    }

    // Start Animation
    animate();

    // Handle Window Resize
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    });
})();
</script>
</body>
</html>
