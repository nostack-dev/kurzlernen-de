<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Minimalist SVG Drawing Tool with Vanishing Points</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0; 
      padding: 0; 
      height: 100%; 
      overflow: hidden;
      user-select: none;
      touch-action: none; /* Prevent default touch actions */
    }
    svg {
      width: 100%;
      height: 100%;
      background: #fff;
      touch-action: none;
    }
    .circle {
      fill: rgba(0, 0, 255, 0.2);
      stroke: #000;
      stroke-width: 2;
      cursor: move;
    }
    .line {
      stroke: #000;
      stroke-width: 2;
      cursor: move;
    }
    /* Highlight lines associated with a vanishing point */
    .line.associated-line {
      stroke: purple;
      stroke-width: 2.5;
    }
    /* Vanishing Point Markers */
    .vanishing-point {
      fill: rgba(255, 165, 0, 0.6); /* Semi-transparent orange */
      stroke: #ff4500; /* OrangeRed */
      stroke-width: 2;
      r: 6;
      cursor: grab;
      transition: transform 0.2s;
    }
    .vanishing-point:hover {
      transform: scale(1.2);
    }
    /* Vanishing Lines */
    .vanishing-line {
      stroke: rgba(0, 128, 0, 0.5); /* Semi-transparent green */
      stroke-dasharray: 5,5;
      stroke-width: 1.5;
      pointer-events: none;
    }
    /* Points: small black dot, but large invisible stroke for easy interaction */
    .point {
      fill: #000;
      stroke: transparent;
      stroke-width: 24;
      pointer-events: stroke;
      cursor: pointer;
      r: 4;
      transition: fill 0.15s, r 0.15s, transform 0.15s;
    }
    .point.highlighted {
      fill: red;
      r: 6;
      filter: drop-shadow(0 0 5px red);
    }
    /* Line Labels */
    .line-label {
      fill: #333;
      font-size: 12px;
      pointer-events: none; /* so it doesn't block clicks */
      user-select: none;
    }
    /* Hidden Control Panel for Future Use (Optional) */
    /* You can remove this if not needed */
    #controlPanel {
      display: none;
    }
  </style>
</head>
<body>
<svg id="svgCanvas">
  <g id="panLayer">
    <defs>
      <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
        <path d="M 50 0 L 0 0 0 50" fill="none" stroke="gray" stroke-width="0.5"/>
      </pattern>
    </defs>
    <rect width="100%" height="100%" fill="url(#grid)"/>
    <g id="shapes"></g>
  </g>
</svg>

<script>
  // ==================== CONFIG =======================
  let highlightThreshold = 25; 
  let snapThreshold      = 20;
  let vanishingTolerance = 5; // degrees for detecting nearly parallel lines

  // Undo / Redo
  const shapes   = document.getElementById('shapes');
  let undoStack  = [];
  let redoStack  = [];

  function saveState() {
    redoStack.length = 0;
    undoStack.push(shapes.innerHTML);
  }
  function undo() {
    if (undoStack.length > 1) {
      redoStack.push(undoStack.pop());
      shapes.innerHTML = undoStack[undoStack.length - 1];
      rebindAllEventListeners();
    }
  }
  function redo() {
    if (redoStack.length > 0) {
      const state = redoStack.pop();
      undoStack.push(state);
      shapes.innerHTML = state;
      rebindAllEventListeners();
    }
  }
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.key === 'z') {
      e.preventDefault();
      undo();
    } else if (e.ctrlKey && e.key === 'y') {
      e.preventDefault();
      redo();
    }
  });

  // ============= VARIABLES & EVENT TARGETS ============
  const svg      = document.getElementById('svgCanvas');
  const panLayer = document.getElementById('panLayer');

  let circleIdCounter = 0;
  let lineIdCounter   = 0;
  let pointIdCounter  = 0;
  let vpIdCounter     = 0; // Vanishing Point ID counter

  let drawing      = false;
  let currentShape = null;
  let startX, startY;
  let mouseMoved   = false;

  // Panning and Zooming
  let panning    = false;
  let panStart   = {x:0,y:0};
  let panOffset  = {x:0,y:0};
  let scale      = 1;

  // Move shapes
  let selectedElement = null;
  let offsetX, offsetY;

  // Vanishing Points Data Structure
  let vanishingPoints = []; // Array of objects: {id, x, y, lines: [lineIds]}
  let vanishingLines = [];  // Array of SVG line elements connecting lines to vanishing points

  // Prevent context menu on right/middle
  window.addEventListener('contextmenu', e => e.preventDefault());
  window.addEventListener('auxclick', e => {
    if (e.button === 1) e.preventDefault();
  });

  // Debounce function to limit how often a function can fire
  function debounce(func, delay) {
    let debounceTimer;
    return function() {
      const context = this;
      const args = arguments;
          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(() => func.apply(context, args), delay);
    }
  }

  // =================== HELPER FUNCTIONS =======================
  
  // Calculate the Angle of a Line in Degrees
  function calculateLineAngle(line) {
    const x1 = parseFloat(line.getAttribute('x1'));
    const y1 = parseFloat(line.getAttribute('y1'));
    const x2 = parseFloat(line.getAttribute('x2'));
    const y2 = parseFloat(line.getAttribute('y2'));
    const angleRad = Math.atan2(y2 - y1, x2 - x1);
    const angleDeg = angleRad * (180 / Math.PI);
    return (angleDeg + 360) % 360; // Normalize angle between 0-360
  }

  // Calculate Intersection Point of Two Lines
  function calculateIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
    const denom = (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4);
    if(denom === 0) return null; // Parallel lines
    const Px = ((x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4)) / denom;
    const Py = ((x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4)) / denom;
    return {x: Px, y: Py};
  }

  // Find Vanishing Point at Given Coordinates (within threshold)
  function findVanishingPointAt(x, y, threshold) {
    return vanishingPoints.find(vp => Math.hypot(x - vp.x, y - vp.y) <= threshold);
  }

  // Create a Vanishing Point Marker
  function createVanishingPoint(x, y) {
    const vp = document.createElementNS("http://www.w3.org/2000/svg","circle");
    vp.classList.add('vanishing-point');
    vp.setAttribute('cx', x);
    vp.setAttribute('cy', y);
    vp.setAttribute('r', 6);
    vp.id = 'vp-'+(vpIdCounter++);
    shapes.appendChild(vp);
    vanishingPoints.push({id: vp.id, x, y, lines: []});
    rebindVanishingPointEventListeners();
    return vp.id;
  }

  // Associate a Line with a Vanishing Point
  function associateLineWithVanishingPoint(line, vpId) {
    if(!vpId) return;
    // Find the vanishing point in the array
    const vp = vanishingPoints.find(vp => vp.id === vpId);
    if(vp) {
      if(!vp.lines.includes(line.id)) {
        vp.lines.push(line.id);
        // Add visual association
        line.classList.add('associated-line');
        // Draw a vanishing line from the midpoint of the line to the vanishing point
        drawVanishingLine(line, vp);
      }
    }
  }

  // Draw a Vanishing Line Connecting a Line to its Vanishing Point
  function drawVanishingLine(line, vp) {
    // Remove existing vanishing lines for this line
    shapes.querySelectorAll(`.vanishing-line[data-line="${line.id}"]`).forEach(l => l.remove());

    const vanishingLine = document.createElementNS("http://www.w3.org/2000/svg","line");
    vanishingLine.classList.add('vanishing-line');
    // Connect from the midpoint of the line to the vanishing point
    const x1 = parseFloat(line.getAttribute('x1'));
    const y1 = parseFloat(line.getAttribute('y1'));
    const x2 = parseFloat(line.getAttribute('x2'));
    const y2 = parseFloat(line.getAttribute('y2'));
    const midX = (x1 + x2) / 2;
    const midY = (y1 + y2) / 2;
    vanishingLine.setAttribute('x1', midX);
    vanishingLine.setAttribute('y1', midY);
    vanishingLine.setAttribute('x2', vp.x);
    vanishingLine.setAttribute('y2', vp.y);
    vanishingLine.dataset.line = line.id;
    shapes.appendChild(vanishingLine);
    vanishingLines.push(vanishingLine);
  }

  // Remove All Existing Vanishing Points and Lines
  function clearVanishingPoints() {
    vanishingPoints.forEach(vp => {
      const vpElement = document.getElementById(vp.id);
      if (vpElement) vpElement.remove();
    });
    vanishingPoints = [];
    shapes.querySelectorAll('.vanishing-line').forEach(vl => vl.remove());
    vanishingLines = [];
  }

  // =================== LINE LABELING =======================
  /** 
   * Store text on a small <text> near the midpoint: 
   * "123.4 mm, 67.8°" 
   */
  function updateLineLabel(line) {
    const x1= parseFloat(line.getAttribute('x1'));
    const y1= parseFloat(line.getAttribute('y1'));
    const x2= parseFloat(line.getAttribute('x2'));
    const y2= parseFloat(line.getAttribute('y2'));

    const dx= x2 - x1;
    const dy= y2 - y1;
    const lengthPx= Math.hypot(dx,dy); 
    const angleDeg= Math.atan2(dy,dx)*(180/Math.PI);

    const lengthMm= lengthPx; // 1px=1mm assumption
    const midX= (x1 + x2)*0.5;
    const midY= (y1 + y2)*0.5;
    const labelText= `${lengthMm.toFixed(1)} mm, ${angleDeg.toFixed(1)}°`;

    // Store or get text element for this line
    const labelId= line.id + '-label';
    let label= document.getElementById(labelId);
    if(!label) {
      label= document.createElementNS("http://www.w3.org/2000/svg","text");
      label.classList.add('line-label');
      label.id= labelId;
      shapes.appendChild(label);
    }
    label.textContent= labelText;
    label.setAttribute('x', midX);
    label.setAttribute('y', midY);
  }

  // =================== VANISHING POINT DETECTION ===================
  // Intelligent Detection: Suggest vanishing points without being intrusive
  function detectVanishingPoints() {
    const allLines = Array.from(shapes.querySelectorAll('.line'));
    
    // Clear existing vanishing points and lines
    clearVanishingPoints();

    // Group lines by their angles within the vanishing tolerance
    const angleGroups = [];
    
    allLines.forEach(line => {
      const angle = calculateLineAngle(line);
      let foundGroup = false;
      
      for(let group of angleGroups) {
        const diff = Math.abs(angle - group.angle);
        const adjustedDiff = diff > 180 ? 360 - diff : diff;
        if(adjustedDiff < vanishingTolerance) {
          group.lines.push(line);
          foundGroup = true;
          break;
        }
      }
      
      if(!foundGroup) {
        angleGroups.push({ angle: angle, lines: [line] });
      }
    });
    
    // For each group with two or more lines, calculate vanishing point
    angleGroups.forEach(group => {
      if(group.lines.length >= 2) {
        // Calculate intersection of the first two lines
        const line1 = group.lines[0];
        const line2 = group.lines[1];
        const vp = calculateIntersection(
          parseFloat(line1.getAttribute('x1')), parseFloat(line1.getAttribute('y1')),
          parseFloat(line1.getAttribute('x2')), parseFloat(line1.getAttribute('y2')),
          parseFloat(line2.getAttribute('x1')), parseFloat(line2.getAttribute('y1')),
          parseFloat(line2.getAttribute('x2')), parseFloat(line2.getAttribute('y2'))
        );
        if(vp) {
          // Check if a vanishing point already exists near the intersection
          let existingVP = findVanishingPointAt(vp.x, vp.y, snapThreshold);
          if(!existingVP) {
            // Create a new vanishing point
            existingVP = createVanishingPoint(vp.x, vp.y);
          }
          // Associate all lines in the group with this vanishing point
          group.lines.forEach(line => {
            associateLineWithVanishingPoint(line, existingVP.id);
          });
        }
      }
    });
  }

  // Debounced version of detectVanishingPoints to improve performance
  const debouncedDetectVP = debounce(detectVanishingPoints, 300);

  // =================== MOUSE AND TOUCH EVENTS FOR DRAWING =======================
  // Unified event handlers for mouse and touch
  function getEventPoint(e) {
    if (e.type.startsWith('touch')) {
      const touch = e.touches[0] || e.changedTouches[0];
      return { x: touch.clientX, y: touch.clientY };
    } else {
      return { x: e.clientX, y: e.clientY };
    }
  }

  function preventDefault(e) {
    e.preventDefault();
  }

  // Start Drawing
  function startDrawing(e) {
    if (e.type === 'touchstart' && e.touches.length > 2) return; // Limit to single or two-finger touches
    e.preventDefault();
    const { x, y } = getEventPoint(e);
    const pt = getSVGPoint(x, y);

    startX = pt.x;
    startY = pt.y;
    drawing = true;
    mouseMoved = false;

    if(isDrawingCircle(e)) {
      currentShape = document.createElementNS("http://www.w3.org/2000/svg","circle");
      currentShape.setAttribute('cx', startX);
      currentShape.setAttribute('cy', startY);
      currentShape.setAttribute('r', 0);
      currentShape.classList.add('circle');
      currentShape.id= 'circle-'+(circleIdCounter++);
      shapes.appendChild(currentShape);
    }
    else {
      currentShape = document.createElementNS("http://www.w3.org/2000/svg","line");
      currentShape.setAttribute('x1', startX);
      currentShape.setAttribute('y1', startY);
      currentShape.setAttribute('x2', startX);
      currentShape.setAttribute('y2', startY);
      currentShape.classList.add('line');
      currentShape.id= 'line-'+(lineIdCounter++);
      shapes.appendChild(currentShape);
    }
  }

  // Determine if the current drawing action should create a circle
  function isDrawingCircle(e) {
    if (e.type.startsWith('touch')) {
      return e.touches.length === 2;
    } else {
      return e.shiftKey;
    }
  }

  // Drawing in Progress
  function drawingInProgress(e) {
    if(!drawing) return;
    if(isDrawingCircle(e) !== (currentShape.classList.contains('circle'))) return; // Prevent mode switch during drawing
    const { x, y } = getEventPoint(e);
    const pt = getSVGPoint(x, y);
    const currentX = pt.x;
    const currentY = pt.y;

    mouseMoved = true;

    // Determine snapping
    let snapTo = null;
    if(currentShape.classList.contains('circle')) {
      // Snap to center points
      const spoints= getAllSnapPointsInArea(currentX, currentY, highlightThreshold, ['center']);
      const cSnap= findClosestSnapPoint(currentX, currentY, spoints, highlightThreshold);
      if(cSnap) {
        snapTo = cSnap;
      }
      const dx= snapTo ? (snapTo.x - startX) : (currentX - startX);
      const dy= snapTo ? (snapTo.y - startY) : (currentY - startY);
      const r= Math.hypot(dx, dy);
      currentShape.setAttribute('r', r);
    }
    else {
      // Snap to various points
      const spoints= getAllSnapPointsInArea(currentX, currentY, highlightThreshold, ['center','line-end','circumference']);
      const cSnap= findClosestSnapPoint(currentX, currentY, spoints, highlightThreshold);
      if(cSnap) {
        snapTo = cSnap;
      }
      currentShape.setAttribute('x2', snapTo ? snapTo.x : currentX);
      currentShape.setAttribute('y2', snapTo ? snapTo.y : currentY);
    }
  }

  // Finish Drawing
  function finishDrawing(e) {
    if(!drawing) return;
    drawing = false;
    const { x, y } = getEventPoint(e);
    const pt = getSVGPoint(x, y);
    const endX = pt.x;
    const endY = pt.y;

    if(currentShape.classList.contains('circle')) {
      // Finalize circle
      const cx= parseFloat(currentShape.getAttribute('cx'));
      const cy= parseFloat(currentShape.getAttribute('cy'));
      const r = parseFloat(currentShape.getAttribute('r'));

      // Snap to center if within threshold
      const centerCandidates= getAllSnapPointsInArea(cx, cy, snapThreshold, ['center']);
      const cSnap= findClosestSnapPoint(cx, cy, centerCandidates, snapThreshold);
      if(cSnap) {
        currentShape.setAttribute('cx', cSnap.x);
        currentShape.setAttribute('cy', cSnap.y);
      }
      addCircumferenceSnapPoints(currentShape);
    }
    else {
      // Finalize line
      const x2= parseFloat(currentShape.getAttribute('x2'));
      const y2= parseFloat(currentShape.getAttribute('y2'));

      const spoints= getAllSnapPointsInArea(x2, y2, snapThreshold, ['center','line-end','circumference']);
      const cSnap= findClosestSnapPoint(x2, y2, spoints, snapThreshold);
      if(cSnap) {
        currentShape.setAttribute('x2', cSnap.x);
        currentShape.setAttribute('y2', cSnap.y);
        const p2= findOrCreatePoint(cSnap.x, cSnap.y, cSnap.type);
        if(p2) currentShape.setAttribute('data-point2', p2.id);
      }

      // Place line label
      updateLineLabel(currentShape);
      ensureLineSnapped(currentShape,null,null);

      // After creating the line, detect vanishing points
      debouncedDetectVP();
    }

    currentShape = null;
    saveState();
  }

  // =================== MOVE ELEMENTS =======================
  function moveElementStart(e) {
    if(e.type.startsWith('touch') && e.touches.length > 1) return; // Ignore multi-touch for moving elements
    e.preventDefault();
    const { x, y } = getEventPoint(e);
    const pt = getSVGPoint(x, y);

    const target= e.target;
    if(target.classList.contains('circle') || target.classList.contains('line') || target.classList.contains('vanishing-point')) {
      selectedElement= target;
      if(target.classList.contains('circle')) {
        offsetX= pt.x - parseFloat(target.getAttribute('cx'));
        offsetY= pt.y - parseFloat(target.getAttribute('cy'));
      }
      else if(target.classList.contains('line')) {
        const x1= parseFloat(target.getAttribute('x1'));
        const y1= parseFloat(target.getAttribute('y1'));
        const x2= parseFloat(target.getAttribute('x2'));
        const y2= parseFloat(target.getAttribute('y2'));
        const distS= Math.hypot(pt.x-x1, pt.y-y1);
        const distE= Math.hypot(pt.x-x2, pt.y-y2);

        if(distS < distE) {
          target.setAttribute('data-moving-end','start');
          offsetX= pt.x - x1; offsetY= pt.y - y1;
        } else {
          target.setAttribute('data-moving-end','end');
          offsetX= pt.x - x2; offsetY= pt.y - y2;
        }
      }
      else if(target.classList.contains('vanishing-point')) {
        // Allow dragging vanishing points
        initiateVanishingPointDrag(target, e);
        return;
      }
      svg.style.cursor='grabbing';
      svg.addEventListener('touchmove', moveElementTouch, {passive: false});
      svg.addEventListener('mousemove', moveElementMouse);
      svg.addEventListener('touchend', dropElementTouch);
      svg.addEventListener('mouseup', dropElementMouse);
    }
  }

  function moveElementMouse(e) {
    if(!selectedElement) return;
    const pt = getSVGPoint(e.clientX, e.clientY);
    moveElement(pt);
  }

  function moveElementTouch(e) {
    if(!selectedElement) return;
    const touch = e.touches[0];
    const pt = getSVGPoint(touch.clientX, touch.clientY);
    moveElement(pt);
  }

  function moveElement(pt) {
    let newX= pt.x - offsetX;
    let newY= pt.y - offsetY;

    if(selectedElement.classList.contains('circle')) {
      const spoints= getAllSnapPointsInArea(newX,newY, highlightThreshold, ['center']);
      const cSnap= findClosestSnapPoint(newX, newY, spoints, highlightThreshold);

      if(cSnap) { newX= cSnap.x; newY= cSnap.y; }
      selectedElement.setAttribute('cx', newX);
      selectedElement.setAttribute('cy', newY);

      removeCircumferenceSnapPoints(selectedElement);
      addCircumferenceSnapPoints(selectedElement);
    }
    else if(selectedElement.classList.contains('line')) {
      const end= selectedElement.getAttribute('data-moving-end')||'end';
      const spoints= getAllSnapPointsInArea(newX, newY, highlightThreshold, 
                    ['center','line-end','circumference']);
      const cSnap= findClosestSnapPoint(newX, newY, spoints, highlightThreshold);

      if(cSnap) { newX= cSnap.x; newY= cSnap.y; }

      if(end==='start') {
        selectedElement.setAttribute('x1', newX);
        selectedElement.setAttribute('y1', newY);
      } else {
        selectedElement.setAttribute('x2', newX);
        selectedElement.setAttribute('y2', newY);
      }
      // Update line label
      updateLineLabel(selectedElement);

      // If line references points, update them
      if(end==='start') {
        const p1id= selectedElement.dataset.point1;
        if(p1id) {
          const p1= document.getElementById(p1id);
          if(p1) {
            p1.setAttribute('cx', newX);
            p1.setAttribute('cy', newY);
          }
        }
      } else {
        const p2id= selectedElement.dataset.point2;
        if(p2id) {
          const p2= document.getElementById(p2id);
          if(p2) {
            p2.setAttribute('cx', newX);
            p2.setAttribute('cy', newY);
          }
        }
      }

      // Re-detect vanishing points with the updated line
      debouncedDetectVP();
    }
  }

  function dropElementMouse(e) {
    if(!selectedElement) return;
    finalizeDrop();
  }

  function dropElementTouch(e) {
    if(!selectedElement) return;
    finalizeDrop();
  }

  function finalizeDrop() {
    if(selectedElement.classList.contains('circle')) {
      const cx= parseFloat(selectedElement.getAttribute('cx'));
      const cy= parseFloat(selectedElement.getAttribute('cy'));
      const spoints= getAllSnapPointsInArea(cx, cy, snapThreshold, ['center']);
      const cSnap= findClosestSnapPoint(cx, cy, spoints, snapThreshold);
      if(cSnap) {
        selectedElement.setAttribute('cx', cSnap.x);
        selectedElement.setAttribute('cy', cSnap.y);
        removeCircumferenceSnapPoints(selectedElement);
        addCircumferenceSnapPoints(selectedElement);
      }
    }
    else if(selectedElement.classList.contains('line')) {
      const end= selectedElement.getAttribute('data-moving-end')||'end';
      let xVal= (end==='start')
                ? parseFloat(selectedElement.getAttribute('x1'))
                : parseFloat(selectedElement.getAttribute('x2'));
      let yVal= (end==='start')
                ? parseFloat(selectedElement.getAttribute('y1'))
                : parseFloat(selectedElement.getAttribute('y2'));
      const spoints= getAllSnapPointsInArea(xVal,yVal, snapThreshold,
                    ['center','line-end','circumference']);
      const cSnap= findClosestSnapPoint(xVal,yVal, spoints, snapThreshold);
      if(cSnap) {
        xVal= cSnap.x; yVal= cSnap.y;
        if(end==='start') {
          selectedElement.setAttribute('x1', xVal);
          selectedElement.setAttribute('y1', yVal);
          const p1id= selectedElement.dataset.point1;
          if(p1id) {
            const p1= document.getElementById(p1id);
            if(p1) { p1.setAttribute('cx', xVal); p1.setAttribute('cy', yVal); }
          }
        } else {
          selectedElement.setAttribute('x2', xVal);
          selectedElement.setAttribute('y2', yVal);
          const p2id= selectedElement.dataset.point2;
          if(p2id) {
            const p2= document.getElementById(p2id);
            if(p2) { p2.setAttribute('cx', xVal); p2.setAttribute('cy', yVal); }
          }
        }
      }
      // Update line label
      updateLineLabel(selectedElement);
    }

    selectedElement.removeAttribute('data-moving-end');
    selectedElement= null;
    svg.removeEventListener('mousemove', moveElementMouse);
    svg.removeEventListener('mousemove', moveElementTouch);
    svg.removeEventListener('touchmove', moveElementTouch, {passive: false});
    svg.removeEventListener('mouseup', dropElementMouse);
    svg.removeEventListener('touchend', dropElementTouch);
    svg.style.cursor='crosshair';
    saveState();
  }

  // =================== VANISHING POINT MARKER DRAGGING ===================
  // Allow dragging vanishing points
  function initiateVanishingPointDrag(vpMarker, event) {
    const onMove = (e) => {
      const { x, y } = getEventPoint(e);
      const pt = getSVGPoint(x, y);
      vpMarker.setAttribute('cx', pt.x);
      vpMarker.setAttribute('cy', pt.y);
      
      // Update vanishing point data
      const vpData = vanishingPoints.find(vpObj => vpObj.id === vpMarker.id);
      if(vpData) {
        vpData.x = pt.x;
        vpData.y = pt.y;
        // Update all associated vanishing lines
        vpData.lines.forEach(lineId => {
          const line = document.getElementById(lineId);
          if(line) {
            drawVanishingLine(line, vpData);
          }
        });
      }
    };

    const onEnd = () => {
      svg.style.cursor='crosshair';
      svg.removeEventListener('touchmove', onMove);
      svg.removeEventListener('mousemove', onMove);
      svg.removeEventListener('touchend', onEnd);
      svg.removeEventListener('mouseup', onEnd);
      saveState();
    };

    svg.style.cursor='grabbing';
    svg.addEventListener('mousemove', onMove);
    svg.addEventListener('touchmove', onMove, {passive: false});
    svg.addEventListener('mouseup', onEnd);
    svg.addEventListener('touchend', onEnd);
  }

  // =================== VANISHING POINT DETECTION ===================
  // Intelligent Detection: Suggest vanishing points without being intrusive
  function detectVanishingPoints() {
    const allLines = Array.from(shapes.querySelectorAll('.line'));
    
    // Clear existing vanishing points and lines
    clearVanishingPoints();

    // Group lines by their angles within the vanishing tolerance
    const angleGroups = [];
    
    allLines.forEach(line => {
      const angle = calculateLineAngle(line);
      let foundGroup = false;
      
      for(let group of angleGroups) {
        const diff = Math.abs(angle - group.angle);
        const adjustedDiff = diff > 180 ? 360 - diff : diff;
        if(adjustedDiff < vanishingTolerance) {
          group.lines.push(line);
          foundGroup = true;
          break;
        }
      }
      
      if(!foundGroup) {
        angleGroups.push({ angle: angle, lines: [line] });
      }
    });
    
    // For each group with two or more lines, calculate vanishing point
    angleGroups.forEach(group => {
      if(group.lines.length >= 2) {
        // Calculate intersection of the first two lines
        const line1 = group.lines[0];
        const line2 = group.lines[1];
        const vp = calculateIntersection(
          parseFloat(line1.getAttribute('x1')), parseFloat(line1.getAttribute('y1')),
          parseFloat(line1.getAttribute('x2')), parseFloat(line1.getAttribute('y2')),
          parseFloat(line2.getAttribute('x1')), parseFloat(line2.getAttribute('y1')),
          parseFloat(line2.getAttribute('x2')), parseFloat(line2.getAttribute('y2'))
        );
        if(vp) {
          // Check if a vanishing point already exists near the intersection
          let existingVP = findVanishingPointAt(vp.x, vp.y, snapThreshold);
          if(!existingVP) {
            // Create a new vanishing point
            existingVP = createVanishingPoint(vp.x, vp.y);
          }
          // Associate all lines in the group with this vanishing point
          group.lines.forEach(line => {
            associateLineWithVanishingPoint(line, existingVP.id);
          });
        }
      }
    });
  }

  // Debounced version of detectVanishingPoints to improve performance
  const debouncedDetectVP = debounce(detectVanishingPoints, 300);

  // =================== POINT MANAGEMENT =======================
  function findOrCreatePoint(x,y,type='point') {
    const existing= findPointAt(x,y,5);
    if(existing) return existing;
    return addPoint(x,y,type);
  }
  function findPointAt(x,y,threshold) {
    const pts= shapes.querySelectorAll('.point');
    for(let p of pts) {
      const px= parseFloat(p.getAttribute('cx'));
      const py= parseFloat(p.getAttribute('cy'));
      const dist= Math.hypot(x-px,y-py);
      if(dist<=threshold) return p;
    }
    return null;
  }
  function addPoint(x,y,type='point') {
    if(pointExists(x,y,5)) return null;
    const p= document.createElementNS("http://www.w3.org/2000/svg","circle");
    p.setAttribute('cx', x);
    p.setAttribute('cy', y);
    p.setAttribute('r', 4);
    p.classList.add('point');
    p.dataset.type= type;
    if(type === 'circumference') {
      p.dataset.circle = currentShape.id;
    }
    p.id= 'point-'+(pointIdCounter++);
    shapes.appendChild(p);
    return p;
  }
  function pointExists(x,y,threshold) {
    const pts= shapes.querySelectorAll('.point');
    for(let p of pts) {
      const px= parseFloat(p.getAttribute('cx'));
      const py= parseFloat(p.getAttribute('cy'));
      const dist= Math.hypot(x-px,y-py);
      if(dist<=threshold) return true;
    }
    return false;
  }

  // =================== MOUSE AND TOUCH EVENTS =======================
  // Unified event handlers for mouse and touch
  function getSVGPoint(x, y) {
    const point = svg.createSVGPoint();
    point.x = x;
    point.y = y;
    return point.matrixTransform(panLayer.getScreenCTM().inverse());
  }

  // =================== MOVE ELEMENTS HANDLING =======================
  // Implemented above as moveElementStart, moveElementMouse, moveElementTouch

  // =================== VANISHING POINT MARKER DRAGGING ===================
  // Handled via initiateVanishingPointDrag function

  // =================== VANISHING TOLERANCE =======================
  // Handled via 'vanishingTolerance' variable and toleranceInput (if any)

  // =================== POINT MANAGEMENT =======================
  // Implemented above as findOrCreatePoint, findPointAt, addPoint, etc.

  // =================== DRAWING MODE SELECTION =======================
  // Handled via gesture-based detection in 'startDrawing' and 'isDrawingCircle'

  // =================== INITIALIZATION =======================
  function init() {
    // Any initial setup can go here
    undoStack.push(shapes.innerHTML);
    rebindAllEventListeners();
  }

  init();

  // =================== REBINDING EVENT LISTENERS ===================
  function rebindAllEventListeners() {
    rebindPointEventListeners();
    rebindVanishingPointEventListeners();
  }

  function rebindPointEventListeners() {
    shapes.querySelectorAll('.point').forEach((p)=>{
      if(p.dataset.bound) return;
      p.dataset.bound='true';

      // Handle touch interactions for points
      p.addEventListener('touchstart',(e)=>{
        if(e.touches.length > 1) { // Use two-finger touch as alternative for Alt+click
          e.preventDefault();
          e.stopPropagation();
          // Only allow moving if the point is connected to at least one line or it's a circumference point connected to a circle
          const connectedLines = getConnectedLines(p);
          const isCircumference = p.dataset.type === 'circumference';
          const connectedToCircle = isCircumference && p.dataset.circle;

          if((connectedLines.length > 0) || connectedToCircle) {
            movingSnapPoint= p;
            highlightConnectedLines(p);

            const origX= parseFloat(p.getAttribute('cx'));
            const origY= parseFloat(p.getAttribute('cy'));
            const mp= getMousePosition(e);
            offsetX= mp.x - origX;
            offsetY= mp.y - origY;

            svg.style.cursor='grabbing';
            svg.addEventListener('touchmove', moveSnapPoint, {passive: false});
            svg.addEventListener('touchend', dropSnapPoint);
            svg.addEventListener('mousemove', moveSnapPoint);
            svg.addEventListener('mouseup', dropSnapPoint);
          }
        }
      });

      // Handle mouse interactions for points
      p.addEventListener('mousedown',(e)=>{
        if(e.altKey) {
          e.preventDefault();
          e.stopPropagation();
          // Only allow moving if the point is connected to at least one line or it's a circumference point connected to a circle
          const connectedLines = getConnectedLines(p);
          const isCircumference = p.dataset.type === 'circumference';
          const connectedToCircle = isCircumference && p.dataset.circle;

          if((connectedLines.length > 0) || connectedToCircle) {
            movingSnapPoint= p;
            highlightConnectedLines(p);

            const origX= parseFloat(p.getAttribute('cx'));
            const origY= parseFloat(p.getAttribute('cy'));
            const mp= getMousePosition(e);
            offsetX= mp.x - origX;
            offsetY= mp.y - origY;

            svg.style.cursor='grabbing';
            svg.addEventListener('mousemove', moveSnapPoint);
            svg.addEventListener('mouseup', dropSnapPoint);
          }
        }
      });
    });
  }

  function highlightConnectedLines(snapPoint) {
    highlightedLines=[];
    const lines= getConnectedLines(snapPoint);
    lines.forEach(L=>{
      L.classList.add('highlighted-line');
      highlightedLines.push(L);
    });
    snapPoint.classList.add('highlighted');
  }
  function unhighlightConnectedLines() {
    highlightedLines.forEach(L=> L.classList.remove('highlighted-line'));
    highlightedLines=[];
    shapes.querySelectorAll('.point.highlighted').forEach(p=>p.classList.remove('highlighted'));
    shapes.querySelectorAll('.circle.snap-candidate, .point.snap-candidate')
          .forEach(el=>el.classList.remove('snap-candidate'));
  }

  // =================== VANISHING POINT DETECTION ===================
  // Rebinding vanishing point event listeners
  function rebindVanishingPointEventListeners() {
    shapes.querySelectorAll('.vanishing-point').forEach(vp=>{
      if(vp.dataset.bound) return;
      vp.dataset.bound='true';

      vp.addEventListener('touchstart', (e)=>{
        if(e.touches.length > 0) {
          initiateVanishingPointDrag(vp, e);
        }
      });

      vp.addEventListener('mousedown', (e)=>{
        initiateVanishingPointDrag(vp, e);
      });
    });
  }

  // =================== PAN AND ZOOM =======================
  // Simple pan and zoom implementation
  let lastTouchDistance = null;

  svg.addEventListener('touchmove', (e) => {
    if(e.touches.length === 2) {
      e.preventDefault();
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const distance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
      if(lastTouchDistance) {
        const delta = distance - lastTouchDistance;
        if(delta > 10) {
          scale *= 1.05;
        } else if(delta < -10) {
          scale /= 1.05;
        }
        scale = Math.min(Math.max(scale, 0.5), 3); // Clamp scale
        panLayer.setAttribute('transform', `translate(${panOffset.x},${panOffset.y}) scale(${scale})`);
      }
      lastTouchDistance = distance;
    }
  }, {passive: false});

  svg.addEventListener('touchend', (e) => {
    if(e.touches.length < 2) {
      lastTouchDistance = null;
    }
  });

  // =================== MOVE ELEMENTS =======================
  // Implemented above as moveElementStart, moveElementMouse, moveElementTouch

  // =================== VANISHING POINT MARKER DRAGGING ===================
  // Handled via initiateVanishingPointDrag function

  // =================== INITIALIZATION =======================
  function init() {
    // Any initial setup can go here
    undoStack.push(shapes.innerHTML);
    rebindAllEventListeners();
  }

  init();

  // =================== FINAL TOUCHES =======================
  // Ensure that touch gestures for panning and drawing do not interfere
  svg.addEventListener('touchstart', (e) => {
    if(e.touches.length === 1) {
      // Single touch: could be drawing or panning
      // If touch is on empty space, start drawing
      const touch = e.touches[0];
      const target = document.elementFromPoint(touch.clientX, touch.clientY);
      if(target === svg || target === panLayer) {
        startDrawing(e);
      }
      else {
        // Else, possibly moving an element
      }
    }
    else if(e.touches.length === 2) {
      // Two-finger touch: could be drawing a circle or zooming
      // Here, we'll prioritize zooming, but also allow drawing circles
      // For simplicity, we'll interpret two-finger touch as drawing circles
      startDrawing(e);
    }
  }, {passive: false});

</script>
</body>
</html>
