<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktive Datenkodierung mit Rauschen</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- DaisyUI Plugin für Tailwind CSS -->
    <link href="https://cdn.jsdelivr.net/npm/daisyui@2.50.0/dist/full.css" rel="stylesheet" type="text/css">
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Chart.js Zoom Plugin (optional für Zoom-Funktionalität) -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.1/dist/chartjs-plugin-zoom.min.js"></script>
</head>
<body class="bg-base-200 flex flex-col h-screen">
    <!-- Header mit Buttons -->
    <div class="navbar bg-base-100 shadow-lg p-4">
        <div class="flex-1">
            <span class="text-xl font-bold">Datenkodierung mit Rauschen</span>
        </div>
        <div class="flex-none space-x-2">
            <button id="saveParameters" class="btn btn-primary btn-sm">Parameter speichern</button>
            <button id="loadParametersButton" class="btn btn-accent btn-sm">Parameter laden</button>
            <button id="reconstructCurve" class="btn btn-success btn-sm">Kurve rekonstruieren</button>
            <!-- Versteckte Dateieingaben -->
            <input type="file" id="loadParameters" accept=".json" class="hidden">
        </div>
    </div>
    
    <div class="flex flex-1 overflow-hidden">
        <!-- Sidebar für Parametersteuerungen -->
        <div class="w-full md:w-1/3 lg:w-1/4 bg-base-100 p-6 overflow-y-auto">
            <!-- Amplitude Slider -->
            <div class="card shadow-lg compact side bg-base-100 mb-4">
                <div class="card-body">
                    <h3 class="card-title">Amplitude (A)</h3>
                    <input type="range" id="amplitude" min="0.1" max="5" step="0.1" value="2" class="range range-primary">
                    <span id="amplitudeValue" class="text-lg">2.0</span>
                </div>
            </div>
            
            <!-- Frequenz Slider -->
            <div class="card shadow-lg compact side bg-base-100 mb-4">
                <div class="card-body">
                    <h3 class="card-title">Frequenz (f)</h3>
                    <input type="range" id="frequency" min="0.1" max="5" step="0.1" value="1" class="range range-secondary">
                    <span id="frequencyValue" class="text-lg">1.0</span>
                </div>
            </div>
            
            <!-- Phasenverschiebung Slider -->
            <div class="card shadow-lg compact side bg-base-100 mb-4">
                <div class="card-body">
                    <h3 class="card-title">Phasenverschiebung (φ) [Radiant]</h3>
                    <input type="range" id="phaseShift" min="0" max="6.28" step="0.1" value="0" class="range range-accent">
                    <span id="phaseShiftValue" class="text-lg">0.0</span>
                </div>
            </div>
            
            <!-- Noise-Amplitude Slider -->
            <div class="card shadow-lg compact side bg-base-100 mb-6">
                <div class="card-body">
                    <h3 class="card-title">Noise-Amplitude (N)</h3>
                    <input type="range" id="noiseAmplitude" min="0" max="1" step="0.01" value="0.25" class="range range-warning">
                    <span id="noiseAmplitudeValue" class="text-lg">0.25</span>
                </div>
            </div>
        </div>
        
        <!-- Bereich für das Chart -->
        <div class="flex-1 bg-base-200 p-6 overflow-hidden">
            <canvas id="waveChart" class="w-full h-full"></canvas>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        console.log("Skript geladen und ausgeführt.");

        // Überprüfen, ob Chart.js geladen ist
        if (typeof Chart === 'undefined') {
            console.error("Chart.js konnte nicht geladen werden. Bitte Internetverbindung prüfen.");
            return;
        }

        const ctx = document.getElementById('waveChart').getContext('2d');

        // Anzahl der Datenpunkte
        const N = 100;
        const t = Array.from({ length: N }, (_, i) => (2 * Math.PI * i) / (N - 1));

        // **Initiale Parameter aus den Slidern auslesen**
        let amplitude = parseFloat(document.getElementById('amplitude').value);
        let frequency = parseFloat(document.getElementById('frequency').value);
        let phaseShift = parseFloat(document.getElementById('phaseShift').value);
        let noiseAmplitude = parseFloat(document.getElementById('noiseAmplitude').value);

        console.log("Initiale Parameter:", { amplitude, frequency, phaseShift, noiseAmplitude });

        // **Generiere Originaldaten basierend auf aktuellen Parametern**
        function generateOriginalData() {
            return t.map(value => amplitude * Math.sin(frequency * value + phaseShift));
        }

        // **Generiere Rauschdaten basierend auf aktuellen Parametern**
        function generateNoisyData(originalData) {
            return originalData.map((value, index) => {
                const noise = noiseAmplitude * (Math.random() * 2 - 1); // Gleichverteiltes Rauschen zwischen -N und +N
                return value + noise;
            });
        }

        // **Funktion zur Kodierung der Originaldaten**
        function encodeVector(amplitude, frequency, phaseShift, data) {
            return data.map((value, index) => {
                const phaseValue = amplitude * Math.cos(frequency * t[index] + phaseShift);
                if (phaseValue === 0) {
                    // Wenn phaseValue genau 0 ist, setzen wir den kodierten Wert auf 0
                    return 0;
                } else {
                    return phaseValue * value;
                }
            });
        }

        // **Funktion zur Rekonstruktion der Originaldaten aus den kodierten Daten**
        function unwind(amplitude, frequency, phaseShift, encodedData, noisyData) {
            let decodedData = [];
            for (let index = 0; index < t.length; index++) {
                const phaseValue = amplitude * Math.cos(frequency * t[index] + phaseShift);
                if (phaseValue === 0) {
                    // Wenn phaseValue genau 0 ist, setzen wir den rekonstruierten Wert auf noisyData(t)
                    decodedData.push(noisyData[index]);
                } else {
                    decodedData.push(encodedData[index] / phaseValue);
                }
            }
            return decodedData;
        }

        // **Funktion zum Speichern der Encoding-Parameter als JSON-Datei**
        function saveParameters() {
            const params = {
                amplitude,
                frequency,
                phaseShift,
                noiseAmplitude
            };
            const dataStr = JSON.stringify(params, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'encodingParameters.json';
            a.click();
            URL.revokeObjectURL(url);
            console.log("Parameter gespeichert:", params);
        }

        // **Funktion zum Laden der Encoding-Parameter aus einer JSON-Datei**
        function loadParameters(file) {
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const params = JSON.parse(event.target.result);
                    console.log("Geladene Parameter:", params);
                    if (params.amplitude !== undefined) {
                        document.getElementById('amplitude').value = params.amplitude;
                        document.getElementById('amplitudeValue').textContent = params.amplitude.toFixed(1);
                        amplitude = params.amplitude;
                    }
                    if (params.frequency !== undefined) {
                        document.getElementById('frequency').value = params.frequency;
                        document.getElementById('frequencyValue').textContent = params.frequency.toFixed(1);
                        frequency = params.frequency;
                    }
                    if (params.phaseShift !== undefined) {
                        document.getElementById('phaseShift').value = params.phaseShift;
                        document.getElementById('phaseShiftValue').textContent = params.phaseShift.toFixed(1);
                        phaseShift = params.phaseShift;
                    }
                    if (params.noiseAmplitude !== undefined) {
                        document.getElementById('noiseAmplitude').value = params.noiseAmplitude;
                        document.getElementById('noiseAmplitudeValue').textContent = params.noiseAmplitude.toFixed(2);
                        noiseAmplitude = params.noiseAmplitude;
                    }
                    updateData();
                } catch (error) {
                    console.error("Fehler beim Laden der Parameter:", error);
                    alert("Fehler beim Laden der Parameter. Bitte stellen Sie sicher, dass die Datei korrekt ist.");
                }
            };
            reader.readAsText(file);
        }

        // **Event Listener für den "Parameter speichern" Button**
        document.getElementById('saveParameters').addEventListener('click', saveParameters);

        // **Event Listener für den "Parameter laden" Button**
        document.getElementById('loadParametersButton').addEventListener('click', () => {
            document.getElementById('loadParameters').click();
        });

        // **Event Listener für den versteckten File-Input "loadParameters"**
        document.getElementById('loadParameters').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                loadParameters(file);
            }
        });

        // **Funktion zum Rekonstruieren der Originaldaten aus den kodierten Daten**
        function reconstructOriginalData() {
            let reconstructed = unwind(amplitude, frequency, phaseShift, encodedData, noisyData);
            reconstructedData = reconstructed;
            console.log("Rekonstruierte Daten:", reconstructedData);

            // **Aktualisiere die rekonstruierte Daten im Chart**
            const existingReconstructed = chart.data.datasets.find(dataset => dataset.label === 'Rekonstruierte Daten');
            if (existingReconstructed) {
                existingReconstructed.data = reconstructedData;
            } else {
                chart.data.datasets.push({
                    label: 'Rekonstruierte Daten',
                    data: reconstructedData,
                    borderColor: 'rgba(34, 197, 94, 0.5)', // Grün
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 3,
                    hidden: false, // Wird angezeigt, sobald rekonstruiert
                    spanGaps: false, // Lücken bei null/NaN-Werten anzeigen
                });
            }

            chart.update();
        }

        // **Funktion zum Aktualisieren der Daten basierend auf den aktuellen Parametern**
        function updateData() {
            // **Generiere Originaldaten basierend auf aktuellen Parametern**
            originalData = generateOriginalData();
            console.log("Originaldaten aktualisiert:", originalData);

            // **Generiere Rauschdaten basierend auf aktuellen Parametern**
            noisyData = generateNoisyData(originalData);
            console.log("Rauschdaten aktualisiert:", noisyData);

            // **Kodierte Daten basierend auf aktuellen Parametern generieren**
            encodedData = encodeVector(amplitude, frequency, phaseShift, noisyData);
            console.log("Kodierte Daten aktualisiert:", encodedData);

            // **Aktualisiere Originaldaten im Chart**
            const existingOriginal = chart.data.datasets.find(dataset => dataset.label === 'Originaldaten');
            if (existingOriginal) {
                existingOriginal.data = originalData;
            } else {
                chart.data.datasets.push({
                    label: 'Originaldaten',
                    data: originalData,
                    borderColor: 'rgba(59, 130, 246, 0.5)', // Blau
                    borderWidth: 2,
                    fill: false,
                    borderDash: [5, 5],
                    pointRadius: 3,
                    hidden: false, // Standardmäßig angezeigt
                });
            }

            // **Aktualisiere Rauschdaten im Chart**
            const existingNoisy = chart.data.datasets.find(dataset => dataset.label === 'Rauschdaten');
            if (existingNoisy) {
                existingNoisy.data = noisyData;
            } else {
                chart.data.datasets.push({
                    label: 'Rauschdaten',
                    data: noisyData,
                    borderColor: 'rgba(255, 159, 64, 0.5)', // Orange
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 3,
                    hidden: true, // Standardmäßig ausgeblendet
                });
            }

            // **Aktualisiere kodierte Daten im Chart**
            const existingEncoded = chart.data.datasets.find(dataset => dataset.label === 'Kodierte Daten');
            if (existingEncoded) {
                existingEncoded.data = encodedData;
            } else {
                chart.data.datasets.push({
                    label: 'Kodierte Daten',
                    data: encodedData,
                    borderColor: 'rgba(255, 99, 132, 0.5)', // Rot
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 3,
                    hidden: true, // Standardmäßig ausgeblendet
                });
            }

            // **Rekonstruierte Daten entfernen, da sie auf veralteten kodierten Daten basieren**
            const existingReconstructed = chart.data.datasets.find(dataset => dataset.label === 'Rekonstruierte Daten');
            if (existingReconstructed) {
                chart.data.datasets.splice(chart.data.datasets.indexOf(existingReconstructed), 1);
                console.log("Rekonstruierte Daten entfernt.");
            }

            chart.update();
        }

        // **Slider-Event-Listener**
        document.getElementById('amplitude').addEventListener('input', e => {
            amplitude = parseFloat(e.target.value);
            document.getElementById('amplitudeValue').textContent = amplitude.toFixed(1);
            console.log("Amplitude geändert:", amplitude);
            updateData();
        });

        document.getElementById('frequency').addEventListener('input', e => {
            frequency = parseFloat(e.target.value);
            document.getElementById('frequencyValue').textContent = frequency.toFixed(1);
            console.log("Frequenz geändert:", frequency);
            updateData();
        });

        document.getElementById('phaseShift').addEventListener('input', e => {
            phaseShift = parseFloat(e.target.value);
            document.getElementById('phaseShiftValue').textContent = phaseShift.toFixed(1);
            console.log("Phasenverschiebung geändert:", phaseShift);
            updateData();
        });

        document.getElementById('noiseAmplitude').addEventListener('input', e => {
            noiseAmplitude = parseFloat(e.target.value);
            document.getElementById('noiseAmplitudeValue').textContent = noiseAmplitude.toFixed(2);
            console.log("Noise-Amplitude geändert:", noiseAmplitude);
            updateData();
        });

        // **Initialisiere Originaldaten, Rauschdaten und kodierte Daten**
        let originalData = generateOriginalData();
        console.log("Originaldaten generiert:", originalData);

        let noisyData = generateNoisyData(originalData);
        console.log("Rauschdaten generiert:", noisyData);

        let encodedData = encodeVector(amplitude, frequency, phaseShift, noisyData);
        console.log("Kodierte Daten generiert:", encodedData);

        let reconstructedData = []; // Wird erst nach Rekonstruktion gesetzt

        // **Chart erstellen**
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: t,
                datasets: [
                    {
                        label: 'Originaldaten',
                        data: originalData,
                        borderColor: 'rgba(59, 130, 246, 0.5)', // Blau
                        borderWidth: 2,
                        fill: false,
                        borderDash: [5, 5],
                        pointRadius: 3,
                        hidden: false, // Standardmäßig angezeigt
                    },
                    {
                        label: 'Rauschdaten',
                        data: noisyData,
                        borderColor: 'rgba(255, 159, 64, 0.5)', // Orange
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 3,
                        hidden: true, // Standardmäßig ausgeblendet
                    },
                    {
                        label: 'Kodierte Daten',
                        data: encodedData,
                        borderColor: 'rgba(255, 99, 132, 0.5)', // Rot
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 3,
                        hidden: true, // Standardmäßig ausgeblendet
                    },
                    {
                        label: 'Rekonstruierte Daten',
                        data: reconstructedData,
                        borderColor: 'rgba(34, 197, 94, 0.5)', // Grün
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 3,
                        hidden: true, // Standardmäßig ausgeblendet
                        spanGaps: false, // Lücken bei null/NaN-Werten anzeigen
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                    },
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                        }
                    },
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'xy'
                        },
                        zoom: {
                            wheel: {
                                enabled: true
                            },
                            pinch: {
                                enabled: true
                            },
                            mode: 'xy'
                        }
                    }
                },
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Zeit (t)'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Amplitude'
                        }
                    }
                }
            }
        });

        // **Event Listener für den "Kurve rekonstruieren" Button**
        document.getElementById('reconstructCurve').addEventListener('click', reconstructOriginalData);

        console.log("Skript vollständig ausgeführt.");
    });
    </script>
</body>
</html>
