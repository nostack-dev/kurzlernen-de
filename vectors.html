<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Drawing App – Full Merging, Detaching, & SHIFT Angle Snaps</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      user-select: none;
      font-family: Arial, sans-serif;
    }
    #canvas {
      display: block;
      background-color: #fff;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
// ======================================================
// Global Variables
// ======================================================
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
canvas.addEventListener("contextmenu", e => e.preventDefault());

const pxPerCm = 35;       // 35 px ~ 1 cm
const snapRadius = 15;    // For merging endpoints or snapping dragging

let endpoints = [];       // Each ep: { x, y, lines:[], selected: bool, parentCircle?: Circle }
let lines = [];
let circles = [];

// Panning offset (unused for now)
let panOffset = { x:0, y:0 };

// Drawing states
let isDrawingLine = false;
let startEndpoint = null;
let currentPosLine = { x:0, y:0 };

let isDrawingCircle = false;
let circleCenter = null;
let currentPosCircle = { x:0, y:0 };

let vKeyHeld = false;  // If "V" => circle creation

// Endpoint dragging
let isDraggingEndpoint = false;
let draggedEndpoints = [];
let dragStartPos = { x:0, y:0 };
let endpointsOriginalPos = [];

// Selection rectangle
let isSelecting = false;
let selectionStart = null;
let selectionCurrent = null;

// Undo/Redo
const undoStack = [];
const redoStack = [];

// Toggles
let labelsVisible = true;
let shiftIsHeld = false;
let showLineLengths = false; // "U"
let showAngles = true;       // "I"

let hoverEndpoint = null;

// ======================================================
// Utility
// ======================================================
function getMousePos(e){
  const rect = canvas.getBoundingClientRect();
  return {
    x: e.clientX - rect.left + panOffset.x,
    y: e.clientY - rect.top + panOffset.y
  };
}
function dist(a,b){
  return Math.hypot(a.x - b.x, a.y - b.y);
}
function pointInRect(p, start, current){
  let xMin= Math.min(start.x, current.x);
  let xMax= Math.max(start.x, current.x);
  let yMin= Math.min(start.y, current.y);
  let yMax= Math.max(start.y, current.y);
  return(p.x>= xMin && p.x<= xMax && p.y>= yMin && p.y<= yMax);
}

// "findEndpoint" must be defined before "spaceMergeDownHoveredEndpoint" uses it
function findEndpoint(x,y){
  for(let ep of endpoints){
    if(dist(ep,{ x,y })<= snapRadius) return ep;
  }
  return null;
}
function getSnappedEndpoint(x,y){
  let existing= findEndpoint(x,y);
  if(existing) return existing;
  let ep= { x, y, lines:[], selected:false };
  endpoints.push(ep);
  return ep;
}
function cleanupEndpoints(){
  for(let i=endpoints.length-1;i>=0;i--){
    if(endpoints[i].lines.length===0){
      endpoints.splice(i,1);
    }
  }
}

// SHIFT angle constraints for dragging or line drawing
function applyConstraints(origin, curr, shiftHeld){
  let { x: ox, y: oy }= origin;
  let { x: cx, y: cy }= curr;
  if(shiftHeld){
    let inputAngle= Math.atan2(cy- oy, cx- ox);
    if(inputAngle<0) inputAngle+= 2*Math.PI;

    // Snap to multiples of 45°, or parallel/perp to lines from "origin"
    let cand45= Math.round(inputAngle/(Math.PI/4))*(Math.PI/4);
    let candidates= [ cand45 ];
    // Also consider angles from lines out of "origin"
    origin.lines.forEach(ln=>{
      let other= (ln.start=== origin)? ln.end: ln.start;
      let a= Math.atan2(other.y- oy, other.x- ox);
      if(a<0) a+= 2*Math.PI;
      candidates.push(a);                 // parallel
      candidates.push( (a+ Math.PI)%(2*Math.PI) );  // opposite direction
      candidates.push( (a+ Math.PI/2)%(2*Math.PI) );// perpendicular
      candidates.push( (a+ 3*Math.PI/2)%(2*Math.PI));// perpendicular opposite
    });

    // Pick whichever is closest
    let best= candidates[0];
    let minDiff= Math.abs(inputAngle- best);
    candidates.forEach(c=>{
      let diff= Math.abs(inputAngle- c);
      if(diff> Math.PI) diff= 2*Math.PI- diff; 
      if(diff< minDiff){
        minDiff= diff;
        best= c;
      }
    });
    let distance= Math.hypot(cx- ox, cy- oy);
    cx= ox+ distance*Math.cos(best);
    cy= oy+ distance*Math.sin(best);
  }
  return { x: cx, y: cy };
}

// Snap dragging endpoint to existing endpoint
function snapDraggedEndpoint(pos, excludeList){
  for(let ep of endpoints){
    if(excludeList.includes(ep)) continue;
    if(dist(ep, pos)<= snapRadius){
      return { x: ep.x, y: ep.y };
    }
  }
  return pos;
}

// ======================================================
// Classes
// ======================================================
function lineExists(ep1, ep2){
  return lines.some(ln=>
    (ln.start=== ep1 && ln.end=== ep2)||
    (ln.start=== ep2 && ln.end=== ep1)
  );
}

class Line {
  constructor(startEp, endEp){
    this.start= startEp;
    this.end= endEp;
    this.length= dist(startEp,endEp)/ pxPerCm;
    startEp.lines.push(this);
    endEp.lines.push(this);
  }
  draw(){
    ctx.strokeStyle="#333";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(this.start.x,this.start.y);
    ctx.lineTo(this.end.x,this.end.y);
    ctx.stroke();
  }
}

class Circle {
  constructor(centerEp, radius){
    this.center= centerEp;
    this.radius= radius;
    this.samplePoints= this.calcPoints();
    this.samplePoints.forEach(pt=>{
      pt.parentCircle= this;
      endpoints.push(pt);
    });
    circles.push(this);
  }
  calcPoints(){
    let n= Math.ceil(this.radius/20);
    n= Math.max(8, Math.min(n,64));
    let arr= [];
    for(let i=0;i<n;i++){
      let angle= (2*Math.PI/n)* i;
      let x= this.center.x+ this.radius* Math.cos(angle);
      let y= this.center.y+ this.radius* Math.sin(angle);
      arr.push({ x,y, lines:[], selected:false, parentCircle:this });
    }
    return arr;
  }
  draw(){
    ctx.strokeStyle="#FF5733";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(this.center.x,this.center.y,this.radius,0,2*Math.PI);
    ctx.stroke();
    ctx.fillStyle="#FF0000";
    this.samplePoints.forEach(pt=>{
      ctx.beginPath();
      ctx.arc(pt.x,pt.y,6,0,2*Math.PI);
      ctx.fill();
    });
  }
}

// ======================================================
// Merge Down (Space), Straighten (SHIFT+Space), Detach (CTRL+Space)
// ======================================================
function pointLineDistance(P,A,B){
  let ABx= B.x- A.x, ABy= B.y- A.y;
  let APx= P.x- A.x, APy= P.y- A.y;
  let ab2= ABx*ABx+ ABy*ABy;
  let t= (APx*ABx+ APy*ABy)/ ab2;
  if(t<0) t=0; if(t>1) t=1;
  let projX= A.x+ t*ABx, projY= A.y+ t*ABy;
  return dist(P, { x: projX, y: projY });
}
function projectPointOntoLine(P,A,B){
  let ABx= B.x- A.x, ABy= B.y- A.y;
  let APx= P.x- A.x, APy= P.y- A.y;
  let ab2= ABx*ABx+ ABy*ABy;
  let t= (APx*ABx + APy*ABy)/ ab2;
  if(t<0) t=0; if(t>1) t=1;
  return { x: A.x+ t*ABx, y: A.y+ t*ABy };
}

function splitLine(line, proj){
  let { start, end }= line;
  // new endpoint at "proj"
  let epProj= getSnappedEndpoint(proj.x, proj.y);
  if(dist(epProj,start)<1e-6|| dist(epProj,end)<1e-6){
    return;
  }
  // remove original line
  let i1= start.lines.indexOf(line);
  if(i1>-1) start.lines.splice(i1,1);
  let i2= end.lines.indexOf(line);
  if(i2>-1) end.lines.splice(i2,1);
  let i3= lines.indexOf(line);
  if(i3>-1) lines.splice(i3,1);

  let ln1= new Line(start, epProj);
  let ln2= new Line(epProj, end);
  lines.push(ln1, ln2);
  cleanupEndpoints();
}

function spaceMergeDownHoveredEndpoint(ep){
  const threshold= 10;
  for(let line of lines){
    if(line.start=== ep|| line.end=== ep) continue;
    let d= pointLineDistance(ep, line.start, line.end);
    if(d<= threshold){
      let proj= projectPointOntoLine(ep, line.start, line.end);
      if(dist(proj,line.start)>1e-6 && dist(proj,line.end)>1e-6){
        splitLine(line, proj);
      }
      let target= findEndpoint(proj.x, proj.y);
      if(target && target!== ep){
        // merge ep => target
        ep.lines.forEach(ln=>{
          if(ln.start=== ep){
            ln.start= target;
            if(!target.lines.includes(ln)) target.lines.push(ln);
          }
          if(ln.end=== ep){
            ln.end= target;
            if(!target.lines.includes(ln)) target.lines.push(ln);
          }
        });
        let idx= endpoints.indexOf(ep);
        if(idx>-1) endpoints.splice(idx,1);
      } else {
        // just place ep on that line
        ep.x= proj.x; ep.y= proj.y;
      }
      draw();
      return;
    }
  }
  draw();
}

function straightenEndpoint(ep){
  // only if exactly 2 lines
  if(!ep|| ep.lines.length!==2) return;
  let l1= ep.lines[0], l2= ep.lines[1];
  let A= (l1.start=== ep)? l1.end: l1.start;
  let B= (l2.start=== ep)? l2.end: l2.start;
  let proj= projectPointOntoLine(ep, A,B);
  ep.x= proj.x; ep.y= proj.y;
  draw();
}

// Detach (CTRL+Space): split lines into separate endpoints
function detachHoveredEndpoint(ep){
  if(!ep) return;
  let linesCopy= ep.lines.slice();
  for(let ln of linesCopy){
    if(ln.start=== ep){
      let newEp= { x: ep.x, y: ep.y, lines:[], selected:false };
      endpoints.push(newEp);
      ln.start= newEp;
      newEp.lines.push(ln);
    } else if(ln.end=== ep){
      let newEp= { x: ep.x, y: ep.y, lines:[], selected:false };
      endpoints.push(newEp);
      ln.end= newEp;
      newEp.lines.push(ln);
    }
  }
  let idx= endpoints.indexOf(ep);
  if(idx>-1) endpoints.splice(idx,1);
  draw();
}

// ======================================================
// Undo/Redo: Full Snapshots
// ======================================================
function snapshot(){
  let endpointsData= endpoints.map(ep=>({
    x: ep.x,y: ep.y, selected: ep.selected||false
  }));
  let linesData= lines.map(ln=>({
    startIndex: endpoints.indexOf(ln.start),
    endIndex: endpoints.indexOf(ln.end)
  }));
  let circlesData= circles.map(circle=>({
    centerIndex: endpoints.indexOf(circle.center),
    radius: circle.radius,
    samplePoints: circle.samplePoints.map(sp=>({
      x: sp.x,y: sp.y, selected: sp.selected||false
    }))
  }));
  return { endpointsData, linesData, circlesData };
}
function restoreSnapshot(snap){
  endpoints.length=0;
  lines.length=0;
  circles.length=0;
  snap.endpointsData.forEach(ed=>{
    endpoints.push({ x: ed.x,y: ed.y, lines:[], selected: ed.selected });
  });
  snap.linesData.forEach(ld=>{
    let sEp= endpoints[ld.startIndex];
    let eEp= endpoints[ld.endIndex];
    let ln= new Line(sEp,eEp);
    lines.push(ln);
  });
  snap.circlesData.forEach(cd=>{
    let centerEp= endpoints[cd.centerIndex];
    let circ= new Circle(centerEp, cd.radius);
    circ.samplePoints.length=0;
    cd.samplePoints.forEach(sp=>{
      let spt= { x: sp.x,y: sp.y, lines:[], selected: sp.selected, parentCircle: circ };
      circ.samplePoints.push(spt);
      endpoints.push(spt);
    });
    circles.push(circ);
  });
  cleanupEndpoints();
  draw();
}
function pushSnapshot(){
  let data= snapshot();
  undoStack.push(data);
  redoStack.length=0;
}
function undo(){
  if(undoStack.length<2) return;
  undoStack.pop();
  let data= undoStack[undoStack.length-1];
  restoreSnapshot(data);
}
function redo(){
  if(redoStack.length===0) return;
  let data= redoStack.pop();
  let current= snapshot();
  undoStack.push(current);
  restoreSnapshot(data);
}

// ======================================================
// Draw
// ======================================================
function drawGrid(){
  if(!labelsVisible) return;
  ctx.strokeStyle="#ddd";
  ctx.lineWidth=1;
  for(let x=0;x<= canvas.width; x+= pxPerCm){
    ctx.beginPath();
    ctx.moveTo(x,0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  for(let y=0;y<= canvas.height; y+= pxPerCm){
    ctx.beginPath();
    ctx.moveTo(0,y);
    ctx.lineTo(canvas.width,y);
    ctx.stroke();
  }
}
function drawVertexAngles(){
  if(!showAngles|| !labelsVisible) return;
  const arcRadius= 20;
  endpoints.forEach(ep=>{
    if(ep.lines.length>=2){
      let angles= ep.lines.map(ln=>{
        let other= (ln.start=== ep)? ln.end: ln.start;
        let a= Math.atan2(other.y- ep.y, other.x- ep.x);
        if(a<0) a+= 2*Math.PI;
        return a;
      });
      angles.sort((a,b)=> a-b);
      for(let i=0;i< angles.length;i++){
        let a1= angles[i];
        let a2= (i=== angles.length-1)? angles[0]+ 2*Math.PI: angles[i+1];
        let gap= a2- a1;
        if(gap> (5*Math.PI/180) && gap< Math.PI){
          ctx.beginPath();
          ctx.strokeStyle="rgba(0,0,blue,0.7)";
          ctx.arc(ep.x, ep.y, arcRadius, a1, a1+ gap);
          ctx.stroke();
          let mid= a1+ gap/2;
          let tx= ep.x+(arcRadius+10)* Math.cos(mid);
          let ty= ep.y+(arcRadius+10)* Math.sin(mid);
          ctx.save();
          ctx.font="12px Arial";
          ctx.fillStyle="rgba(0,0,0,0.9)";
          ctx.fillText((gap*180/Math.PI).toFixed(1)+"°", tx, ty);
          ctx.restore();
        }
      }
    }
  });
}
function drawExtraLineLabels(){
  if(!showLineLengths) return;
  ctx.save();
  ctx.font="12px Arial";
  ctx.fillStyle="green";
  lines.forEach(ln=>{
    let midX= (ln.start.x+ ln.end.x)/2;
    let midY= (ln.start.y+ ln.end.y)/2;
    ctx.fillText(ln.length.toFixed(2)+" cm", midX, midY);
  });
  ctx.restore();
}
function drawPreviewLabel(){
  if(!startEndpoint|| !currentPosLine|| !labelsVisible) return;
  let dx= currentPosLine.x- startEndpoint.x;
  let dy= currentPosLine.y- startEndpoint.y;
  let lenCm= (Math.hypot(dx,dy)/ pxPerCm).toFixed(2);
  let angleDeg= (Math.atan2(dy,dx)*180/ Math.PI).toFixed(1);
  let label="";
  if(showAngles && !showLineLengths) label= "Angle: "+ angleDeg+"°";
  else if(showLineLengths && !showAngles) label= "Length: "+ lenCm+" cm";
  else label= "Angle: "+ angleDeg+"° | "+ lenCm+" cm";
  ctx.save();
  ctx.font="12px Arial";
  ctx.fillStyle="rgba(0,0,0,0.8)";
  ctx.fillText(label, currentPosLine.x+10, currentPosLine.y-10);
  ctx.restore();
}
function drawPreviewCircleLabel(center, radius){
  if(!center|| !radius|| !labelsVisible) return;
  let lenCm= (radius/ pxPerCm).toFixed(2);
  let label= "Radius: "+ lenCm+" cm";
  ctx.save();
  ctx.font="12px Arial";
  ctx.fillStyle="rgba(0,0,0,0.8)";
  ctx.fillText(label, center.x+ radius+10, center.y-10);
  ctx.restore();
}
function drawSelectionRectangle(){
  if(!isSelecting|| !selectionStart|| !selectionCurrent|| !labelsVisible) return;
  ctx.save();
  ctx.strokeStyle="rgba(0,191,255,0.8)";
  ctx.lineWidth=1;
  ctx.setLineDash([4,4]);
  let x= Math.min(selectionStart.x, selectionCurrent.x);
  let y= Math.min(selectionStart.y, selectionCurrent.y);
  let w= Math.abs(selectionStart.x- selectionCurrent.x);
  let h= Math.abs(selectionStart.y- selectionCurrent.y);
  ctx.strokeRect(x,y,w,h);
  ctx.restore();
}
function draw(){
  ctx.clearRect(0,0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(-panOffset.x, -panOffset.y);
  if(labelsVisible) drawGrid();
  lines.forEach(ln=> ln.draw());
  circles.forEach(circ=> circ.draw());
  // endpoints
  if(labelsVisible){
    endpoints.forEach(ep=>{
      if(ep.matchHover){
        ctx.strokeStyle="#00FFFF";
        ctx.lineWidth=3;
        ctx.beginPath();
        ctx.arc(ep.x, ep.y,10,0,2*Math.PI);
        ctx.stroke();
      }
      if(ep=== hoverEndpoint){
        ctx.strokeStyle="orange";
        ctx.lineWidth=4;
        ctx.beginPath();
        ctx.arc(ep.x, ep.y,8,0,2*Math.PI);
        ctx.stroke();
      }
      ctx.fillStyle= ep.selected? "#0000FF":"#FF0000";
      ctx.beginPath();
      ctx.arc(ep.x,ep.y,6,0,2*Math.PI);
      ctx.fill();
    });
  }
  // SHIFT dragging line preview
  endpoints.forEach(ep=>{
    if(ep._dottedRay){
      ctx.save();
      ctx.setLineDash([4,4]);
      ctx.strokeStyle="purple";
      ctx.beginPath();
      ctx.moveTo(ep._dottedRay.origin.x, ep._dottedRay.origin.y);
      ctx.lineTo(ep.x, ep.y);
      ctx.stroke();
      ctx.restore();
    }
  });
  drawVertexAngles();
  drawExtraLineLabels();
  if(isSelecting) drawSelectionRectangle();
  if(isDrawingLine && startEndpoint && currentPosLine){
    ctx.strokeStyle="#aaa";
    ctx.lineWidth=2;
    ctx.setLineDash([5,3]);
    ctx.beginPath();
    ctx.moveTo(startEndpoint.x,startEndpoint.y);
    ctx.lineTo(currentPosLine.x,currentPosLine.y);
    ctx.stroke();
    ctx.setLineDash([]);
    drawPreviewLabel();
  }
  if(isDrawingCircle && circleCenter && currentPosCircle){
    let radius= dist(circleCenter, currentPosCircle);
    ctx.strokeStyle="#aaa";
    ctx.lineWidth=2;
    ctx.setLineDash([5,3]);
    ctx.beginPath();
    ctx.arc(circleCenter.x, circleCenter.y, radius,0,2*Math.PI);
    ctx.stroke();
    ctx.setLineDash([]);
    drawPreviewCircleLabel(circleCenter, radius);
  }
  ctx.restore();
}

// ======================================================
// Mouse Handlers
// ======================================================
canvas.addEventListener("mousedown", e=>{
  let pos= getMousePos(e);

  // SHIFT+Right-click => toggle selection
  if(e.button===2 && e.shiftKey && !e.ctrlKey && !e.altKey){
    let ep= endpoints.find(ep=> dist(ep,pos)<= snapRadius);
    if(ep){
      ep.selected= !ep.selected;
      draw();
    }
    return;
  }
  // Right-click => single select
  if(e.button===2 && !e.shiftKey && !e.ctrlKey && !e.altKey){
    endpoints.forEach(ep=> ep.selected= false);
    let ep= endpoints.find(ep=> dist(ep,pos)<= snapRadius);
    if(ep) ep.selected= true;
    draw();
    return;
  }
  // CTRL+ALT+Right-click => selection rectangle
  if(e.button===2 && e.ctrlKey && e.altKey){
    isSelecting= true;
    selectionStart= pos;
    selectionCurrent= pos;
    draw();
    return;
  }
  // If “V” => circle on left click, else line
  if(e.button===0 && !e.ctrlKey && !e.altKey){
    if(vKeyHeld){
      // circle
      isDrawingCircle= true;
      circleCenter= endpoints.find(ep=> dist(ep,pos)<= snapRadius) || getSnappedEndpoint(pos.x, pos.y);
      currentPosCircle= { x: pos.x,y: pos.y};
      pushSnapshot();
      draw();
      return;
    } else {
      // line
      isDrawingLine= true;
      startEndpoint= endpoints.find(ep=> dist(ep,pos)<= snapRadius) || getSnappedEndpoint(pos.x,pos.y);
      currentPosLine= { x: pos.x,y: pos.y};
      pushSnapshot();
      draw();
      return;
    }
  }
  // CTRL+Left-click => drag endpoints
  if(e.button===0 && e.ctrlKey && !e.altKey){
    let ep= endpoints.find(ep=> dist(ep,pos)<= snapRadius);
    if(ep){
      if(ep.selected){
        isDraggingEndpoint= true;
        draggedEndpoints= endpoints.filter(ept=> ept.selected);
      } else {
        isDraggingEndpoint= true;
        draggedEndpoints=[ ep ];
      }
      dragStartPos= pos;
      endpointsOriginalPos= draggedEndpoints.map(ept=>({ ept, x:ept.x, y:ept.y }));
      pushSnapshot();
      draw();
      return;
    }
  }
});

canvas.addEventListener("mousemove", e=>{
  let pos= getMousePos(e);
  if(isSelecting){
    selectionCurrent= pos;
    draw();
    return;
  }
  if(isDraggingEndpoint && draggedEndpoints.length>0){
    let dx= pos.x- dragStartPos.x;
    let dy= pos.y- dragStartPos.y;
    draggedEndpoints.forEach(ept=>{
      let orig= endpointsOriginalPos.find(o=> o.ept=== ept);
      if(orig){
        let newPos= { x: orig.x+ dx, y: orig.y+ dy };
        // SHIFT => partial angle constraints
        if(e.shiftKey && ept.lines.length>0){
          let ln= ept.lines[0];
          let angle= Math.atan2(ln.end.y- ln.start.y, ln.end.x- ln.start.x);
          const thr= Math.PI/180*5;
          // Snap to near 0°, 90°, etc. 
          // But also see if we do a line-based approach
          // For simplicity, we’ll reuse applyConstraints with "origin=orig" to incorporate line angles
          newPos= applyConstraints({ x: orig.x,y: orig.y, lines:ept.lines }, newPos, true);
        }
        newPos= snapDraggedEndpoint(newPos, draggedEndpoints);
        ept.x= newPos.x; ept.y= newPos.y;
      }
    });
    // highlight merges
    endpoints.forEach(ep=>{
      if(!draggedEndpoints.includes(ep)){
        if(draggedEndpoints.some(de=> dist(ep,de)< snapRadius)) ep.matchHover= true;
        else delete ep.matchHover;
      }
    });
    // recalc lengths
    draggedEndpoints.forEach(ept=>{
      ept.lines.forEach(ln=>{
        ln.length= dist(ln.start, ln.end)/ pxPerCm;
      });
    });
    draw();
    return;
  }
  if(isDrawingLine){
    let posC= applyConstraints(startEndpoint, pos, e.shiftKey);
    if(e.shiftKey && hoverEndpoint && hoverEndpoint!== startEndpoint){
      // snap angle to the line from startEndpoint->hoverEndpoint
      let angle= Math.atan2(hoverEndpoint.y- startEndpoint.y, hoverEndpoint.x- startEndpoint.x);
      let distance= Math.hypot(pos.x- startEndpoint.x, pos.y- startEndpoint.y);
      posC= { x: startEndpoint.x+ distance*Math.cos(angle), y: startEndpoint.y+ distance*Math.sin(angle) };
    }
    currentPosLine= { x: posC.x,y: posC.y};
    draw();
    return;
  }
  if(isDrawingCircle){
    let posC= { x: pos.x,y: pos.y};
    currentPosCircle= { x: posC.x,y: posC.y};
    draw();
    return;
  }
  if(!isDraggingEndpoint && !isDrawingLine && !isDrawingCircle && !isSelecting){
    let newHover= null;
    for(let ep of endpoints){
      if(dist(ep,pos)<= snapRadius){
        newHover= ep; 
        break;
      }
    }
    hoverEndpoint= newHover;
  } else {
    hoverEndpoint= null;
  }
  if(!isDraggingEndpoint){
    endpoints.forEach(ep=> delete ep.matchHover);
  }
  draw();
});

canvas.addEventListener("mouseup", e=>{
  let pos= getMousePos(e);
  if(isSelecting){
    endpoints.forEach(ep=>{
      if(pointInRect(ep, selectionStart, selectionCurrent)){
        ep.selected= !ep.selected;
      }
    });
    isSelecting= false;
    selectionStart= selectionCurrent= null;
    draw();
    return;
  }
  if(isDraggingEndpoint && draggedEndpoints.length>0){
    // Attempt merges
    draggedEndpoints.forEach(dep=>{
      let near= endpoints.find(ep=> 
        !draggedEndpoints.includes(ep) && dist(dep,ep)<= snapRadius
      );
      if(near){
        // Merge dep => near
        dep.lines.forEach(ln=>{
          if(ln.start=== dep){
            ln.start= near;
            if(!near.lines.includes(ln)) near.lines.push(ln);
          }
          if(ln.end=== dep){
            ln.end= near;
            if(!near.lines.includes(ln)) near.lines.push(ln);
          }
        });
        let idx= endpoints.indexOf(dep);
        if(idx>-1) endpoints.splice(idx,1);
      }
    });
    isDraggingEndpoint= false;
    draggedEndpoints=[];
    endpoints.forEach(ep=> delete ep.matchHover);
    cleanupEndpoints();
    draw();
    return;
  }
  if(isDrawingLine){
    let finalPos= applyConstraints(startEndpoint, pos, e.shiftKey);
    let endEp= endpoints.find(ep=> dist(ep, finalPos)<= snapRadius) || getSnappedEndpoint(finalPos.x, finalPos.y);
    if(startEndpoint.x=== endEp.x && startEndpoint.y=== endEp.y){
      isDrawingLine= false;
      draw();
      return;
    }
    if(!lineExists(startEndpoint, endEp)){
      let newLine= new Line(startEndpoint, endEp);
      lines.push(newLine);
    }
    isDrawingLine= false;
    draw();
    return;
  }
  if(isDrawingCircle){
    let radius= dist(circleCenter,pos);
    if(radius<5){
      isDrawingCircle= false;
      draw();
      return;
    }
    let newCircle= new Circle(circleCenter, radius);
    circles.push(newCircle);
    isDrawingCircle= false;
    draw();
    return;
  }
});

// ======================================================
// Keyboard
// ======================================================
window.addEventListener("keydown", e=>{
  if(e.key==="Shift"){
    shiftIsHeld= true;
    draw();
  }
  if(e.key.toLowerCase()==="h"){
    labelsVisible= !labelsVisible;
    draw();
  }
  if(e.ctrlKey && e.key.toLowerCase()==="a"){
    e.preventDefault();
    endpoints.forEach(ep=> ep.selected= true);
    draw();
  }
  if(e.key==="Escape"){
    endpoints.forEach(ep=> ep.selected= false);
    draw();
  }
  if(e.key.toLowerCase()==="v"){
    vKeyHeld= true;
    draw();
  }
  // CTRL+S => save
  if(e.ctrlKey && e.key.toLowerCase()==="s"){
    e.preventDefault();
    pushSnapshot();
    saveProject();
  }
  // CTRL+L => load
  if(e.ctrlKey && e.key.toLowerCase()==="l"){
    e.preventDefault();
    pushSnapshot();
    loadProject();
  }
  // CTRL+P => PNG
  if(e.ctrlKey && e.key.toLowerCase()==="p"){
    e.preventDefault();
    pushSnapshot();
    savePNG();
  }
  // CTRL+Z => undo
  if(e.ctrlKey && (e.key==="z"|| e.key==="Z")){
    e.preventDefault();
    undo();
  }
  // CTRL+Y => redo
  if(e.ctrlKey && (e.key==="y"|| e.key==="Y")){
    e.preventDefault();
    redo();
  }
  if(e.key==="Delete"){
    // remove circle if center or sample points are selected
    let circlesToRemove= new Set();
    endpoints.forEach(ep=>{
      if(ep.selected && ep.parentCircle) circlesToRemove.add(ep.parentCircle);
    });
    circlesToRemove.forEach(circle=> removeCircle(circle));
    for(let i=endpoints.length-1;i>=0;i--){
      if(endpoints[i].selected){
        endpoints[i].lines.forEach(ln=>{
          let idx= lines.indexOf(ln);
          if(idx>-1) lines.splice(idx,1);
        });
        endpoints.splice(i,1);
      }
    }
    cleanupEndpoints();
    draw();
  }
  // SPACE => mergeDown
  if(e.key===" " && !e.ctrlKey && !e.shiftKey){
    if(hoverEndpoint){
      pushSnapshot();
      spaceMergeDownHoveredEndpoint(hoverEndpoint);
      e.preventDefault();
    }
  }
  // SHIFT+SPACE => straighten if exactly 2 lines
  if(e.key===" " && e.shiftKey && !e.ctrlKey){
    if(hoverEndpoint){
      pushSnapshot();
      straightenEndpoint(hoverEndpoint);
      e.preventDefault();
    }
  }
  // CTRL+SPACE => detach
  if(e.key===" " && e.ctrlKey && !e.shiftKey){
    if(hoverEndpoint){
      pushSnapshot();
      detachHoveredEndpoint(hoverEndpoint);
      e.preventDefault();
      draw();
    }
  }
  // "U" => toggle line length
  if(e.key.toLowerCase()==="u"){
    showLineLengths= !showLineLengths;
    e.preventDefault();
    draw();
  }
  // "I" => toggle angles
  if(e.key.toLowerCase()==="i"){
    showAngles= !showAngles;
    e.preventDefault();
    draw();
  }
});

window.addEventListener("keyup", e=>{
  if(e.key==="Shift"){
    shiftIsHeld= false;
    draw();
  }
  if(e.key.toLowerCase()==="v"){
    vKeyHeld= false;
    draw();
  }
});

// ======================================================
// removeCircle
// ======================================================
function removeCircle(circle){
  let idx= circles.indexOf(circle);
  if(idx>-1) circles.splice(idx,1);
  let cIdx= endpoints.indexOf(circle.center);
  if(cIdx>-1){
    endpoints[cIdx].lines.forEach(ln=>{
      let li= lines.indexOf(ln);
      if(li>-1) lines.splice(li,1);
      let other= (ln.start=== endpoints[cIdx])? ln.end: ln.start;
      let li2= other.lines.indexOf(ln);
      if(li2>-1) other.lines.splice(li2,1);
    });
    endpoints.splice(cIdx,1);
  }
  for(let i=endpoints.length-1;i>=0;i--){
    if(endpoints[i].parentCircle=== circle){
      endpoints[i].lines.forEach(ln=>{
        let li= lines.indexOf(ln);
        if(li>-1) lines.splice(li,1);
        let other= (ln.start=== endpoints[i])? ln.end: ln.start;
        let li2= other.lines.indexOf(ln);
        if(li2>-1) other.lines.splice(li2,1);
      });
      endpoints.splice(i,1);
    }
  }
  cleanupEndpoints();
  draw();
}

// ======================================================
// Save, Load, PNG
// ======================================================
function saveProject(){
  pushSnapshot();
  let data= snapshot();
  let json= JSON.stringify(data);
  let blob= new Blob([json], { type:"application/json"});
  let link= document.createElement("a");
  link.download= "project.json";
  link.href= URL.createObjectURL(blob);
  link.click();
}
function loadProject(){
  let input= document.createElement("input");
  input.type= "file";
  input.accept= "application/json";
  input.onchange= function(e){
    let file= e.target.files[0];
    let reader= new FileReader();
    reader.onload= function(ev){
      try{
        let snapData= JSON.parse(ev.target.result);
        pushSnapshot();
        restoreSnapshot(snapData);
        cleanupEndpoints();
        draw();
      } catch(err){
        alert("Failed to load project.");
      }
    };
    reader.readAsText(file);
  };
  input.click();
}
function savePNG(){
  pushSnapshot();
  let tempCanvas= document.createElement("canvas");
  tempCanvas.width= canvas.width;
  tempCanvas.height= canvas.height;
  let tempCtx= tempCanvas.getContext("2d");
  tempCtx.fillStyle="#fff";
  tempCtx.fillRect(0,0, tempCanvas.width, tempCanvas.height);
  tempCtx.save();
  tempCtx.translate(-panOffset.x, -panOffset.y);
  lines.forEach(ln=>{
    tempCtx.strokeStyle="#333";
    tempCtx.lineWidth=2;
    tempCtx.beginPath();
    tempCtx.moveTo(ln.start.x, ln.start.y);
    tempCtx.lineTo(ln.end.x, ln.end.y);
    tempCtx.stroke();
  });
  circles.forEach(circle=>{
    tempCtx.strokeStyle="#FF5733";
    tempCtx.lineWidth=2;
    tempCtx.beginPath();
    tempCtx.arc(circle.center.x, circle.center.y, circle.radius,0,2*Math.PI);
    tempCtx.stroke();
    tempCtx.fillStyle="#FF0000";
    circle.samplePoints.forEach(pt=>{
      tempCtx.beginPath();
      tempCtx.arc(pt.x, pt.y,6,0,2*Math.PI);
      tempCtx.fill();
    });
  });
  tempCtx.restore();
  let link= document.createElement("a");
  link.download= "drawing.png";
  link.href= tempCanvas.toDataURL();
  link.click();
}

// ======================================================
// Resize & initial
// ======================================================
function resizeAndDraw(){
  canvas.width= window.innerWidth;
  canvas.height= window.innerHeight;
  if(undoStack.length===0){
    pushSnapshot();
  }
  draw();
}
window.addEventListener("resize", resizeAndDraw);
resizeAndDraw();
</script>
</body>
</html>
