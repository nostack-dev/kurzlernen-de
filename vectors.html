<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced Vector Drawing with Accurate Rotation</title>
    <style>
        /* Reset default styles */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            user-select: none; /* Prevent text selection while dragging */
        }

        /* Canvas Styling */
        #canvas {
            display: block;
            background-color: #FFFFFF;
        }

        /* Rotation Status Styling */
        #rotationStatus {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: Arial, sans-serif;
            font-size: 14px; /* px for consistent size */
        }

        /* Alignment Status Display Styling */
        #alignmentStatus {
            position: absolute;
            top: 10px;
            right: 120px;
            z-index: 10;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: Arial, sans-serif;
            font-size: 14px; /* px for consistent size */
        }

        /* Selection Rectangle Styling */
        #selectionRect {
            position: absolute;
            border: 2px dashed #00BFFF;
            background-color: rgba(0, 191, 255, 0.2);
            pointer-events: none;
            display: none;
            z-index: 5;
        }

        /* Save Button Styling */
        #saveButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            padding: 10px 20px;
            font-size: 14px; /* px => consistent size on zoom */
            border: none;
            background-color: #008CBA; /* Blue */
            color: white;
            cursor: pointer;
            border-radius: 4px;
        }

        #saveButton:hover {
            background-color: #005f6a;
        }
    </style>
</head>
<body>
    <!-- Rotation Status Display -->
    <div id="rotationStatus">Rotation: Stopped</div>

    <!-- Alignment Status Display -->
    <div id="alignmentStatus">Alignment: None</div>

    <!-- Selection Rectangle Element -->
    <div id="selectionRect"></div>

    <!-- Save Button -->
    <button id="saveButton">Save Image</button>

    <!-- Canvas Element -->
    <canvas id="canvas" width="800" height="600"></canvas>

    <script>
        /********************************************************
         *                Initialization / Globals              *
         ********************************************************/
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const rotationStateElement = document.getElementById('rotationStatus');
        const alignmentStatus = document.getElementById('alignmentStatus');
        const selectionRectElement = document.getElementById('selectionRect');
        const saveButton = document.getElementById('saveButton');

        const gridSize = 35;
        const gridColor = '#A9A9A9';
        const snapRadius = 15; 

        const shapes = [];
        const snapPoints = [];
        const undoStack = [];
        const redoStack = [];
        const triangles = [];

        let isDragging = false;
        let isCtrlDragging = false;
        let isCtrlAltDragging = false;
        let origin = { type:null, line:null, snapPoint:null };
        let currentVector = null;

        let isRotating = false;
        let rotationTarget = null;
        let rotationAnchor = null;
        let initialMousePos = { x:0, y:0 };
        let initialVectors = {};

        let isMotorRunning = false;
        let selectedSnapPoints = [];
        let motorRotationAnchor = null;

        // store lines' original positions for revert
        let motorOriginalPositions = new Map();

        let isSelectionRectActive = false;
        let selectionRectStart = { x:0, y:0 };
        let selectionRectCurrent = { x:0, y:0 };

        let hoveredSnapPoint = null;
        let dragStartPos = { x:0, y:0 };
        let hasDragged = false;
        let currentMouseButton = null;

        let snapPointsVisible = true;
        let arrowsVisible = true;

        let isXAligned = false;
        let isYAligned = false;
        const snapIncrement = Math.PI / 12; 
        const motorRotationSpeed = Math.PI / 180; 

        let panOffset = { x:0, y:0 };
        let isPanning = false;
        let panStart = { x:0, y:0 };

        let selectedSnapPoint = null;
        let shouldFill = false; 

        /******************************************************
         *   (A) "C" Key => Constrain to Horizontal/Vertical  *
         ******************************************************/
        let isCKeyActive = false; 
        // We'll detect the axis once user drags a certain distance from dragStart
        let lockedAxis = null; // 'horizontal' or 'vertical' or null

        /********************************************************
         *            Utility / Helper Functions                *
         ********************************************************/
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left + panOffset.x,
                y: evt.clientY - rect.top + panOffset.y
            };
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function drawGrid() {
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;
            for(let x=0; x<=canvas.width; x+=gridSize){
                ctx.beginPath();
                ctx.moveTo(x - panOffset.x, 0 - panOffset.y);
                ctx.lineTo(x - panOffset.x, canvas.height - panOffset.y);
                ctx.stroke();
            }
            for(let y=0; y<=canvas.height; y+=gridSize){
                ctx.beginPath();
                ctx.moveTo(0 - panOffset.x, y - panOffset.y);
                ctx.lineTo(canvas.width - panOffset.x, y - panOffset.y);
                ctx.stroke();
            }
        }

        function snapToGrid(angle) {
            return Math.round(angle / snapIncrement)*snapIncrement;
        }

        function snapTo45Degrees(angle) {
            const deg = angle*(180/Math.PI);
            const snappedDeg = Math.round(deg/45)*45;
            return snappedDeg*(Math.PI/180);
        }

        function drawArrow(from, to) {
            if(!from||!to) return;
            const headLength=10;
            const angle=Math.atan2(to.y - from.y, to.x - from.x);
            ctx.strokeStyle='#333333';
            ctx.fillStyle='#333333';
            ctx.lineWidth=2;
            ctx.beginPath();
            ctx.moveTo(to.x - panOffset.x, to.y - panOffset.y);
            ctx.lineTo(
                to.x - panOffset.x - headLength*Math.cos(angle - Math.PI/6),
                to.y - panOffset.y - headLength*Math.sin(angle - Math.PI/6)
            );
            ctx.lineTo(
                to.x - panOffset.x - headLength*Math.cos(angle + Math.PI/6),
                to.y - panOffset.y - headLength*Math.sin(angle + Math.PI/6)
            );
            ctx.lineTo(to.x - panOffset.x, to.y - panOffset.y);
            ctx.fill();
        }

        function findNearbySnapPoint(x,y,exclude=null){
            let closest=null;
            let minDist=snapRadius;
            snapPoints.forEach(sp=>{
                if(exclude && exclude.includes(sp)) return;
                const dist=Math.hypot(x - sp.x,y - sp.y);
                if(dist<=snapRadius && dist<minDist){
                    minDist=dist;
                    closest=sp;
                }
            });
            return closest;
        }

        // if isCKeyActive => we detect if user has moved more in X or Y from dragStart
        // then we lock that axis
        function applyCKeyAxisConstraint(start, current){
            if(!isCKeyActive) return current;
            // if not locked yet => check if we moved more horizontally or vertically
            const dx = current.x - start.x;
            const dy = current.y - start.y;
            if(!lockedAxis){
                if(Math.abs(dx) > 10 || Math.abs(dy) > 10){
                    if(Math.abs(dx)>=Math.abs(dy)){
                        lockedAxis='horizontal';
                    } else {
                        lockedAxis='vertical';
                    }
                }
            }
            if(lockedAxis==='horizontal'){
                return { x: current.x, y: start.y };
            } else if(lockedAxis==='vertical'){
                return { x: start.x, y: current.y };
            }
            return current;
        }

        function applyAlignmentConstraints(originalPos, currentPos) {
            let newX=currentPos.x;
            let newY=currentPos.y;
            if(isXAligned && !isYAligned){
                newY=originalPos.y;
            } else if(isYAligned && !isXAligned){
                newX=originalPos.x;
            }
            return { x:newX, y:newY };
        }

        function pointLineDistance(point,start,end){
            const A=point.x - start.x;
            const B=point.y - start.y;
            const C=end.x - start.x;
            const D=end.y - start.y;
            const dot=A*C + B*D;
            const len_sq=C*C + D*D;
            let param=-1;
            if(len_sq!==0) param=dot/len_sq;
            let xx,yy;
            if(param<0){xx=start.x; yy=start.y;}
            else if(param>1){xx=end.x; yy=end.y;}
            else{
                xx=start.x + param*C;
                yy=start.y + param*D;
            }
            const dx=point.x-xx;
            const dy=point.y-yy;
            return Math.hypot(dx,dy);
        }

        function getLineIntersection(line1, line2){
            const x1=line1.start.x;
            const y1=line1.start.y;
            const x2=line1.end.x;
            const y2=line1.end.y;

            const x3=line2.start.x;
            const y3=line2.start.y;
            const x4=line2.end.x;
            const y4=line2.end.y;

            const denom=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
            if(denom===0) return null;
            const Px=((x1*y2 - y1*x2)*(x3-x4)-(x1-x2)*(x3*y4 - y3*x4))/denom;
            const Py=((x1*y2 - y1*x2)*(y3-y4)-(y1-y2)*(x3*y4 - y3*x4))/denom;
            if(
                Math.min(x1,x2)-0.001<=Px && Px<=Math.max(x1,x2)+0.001 &&
                Math.min(y1,y2)-0.001<=Py && Py<=Math.max(y1,y2)+0.001 &&
                Math.min(x3,x4)-0.001<=Px && Px<=Math.max(x3,x4)+0.001 &&
                Math.min(y3,y4)-0.001<=Py && Py<=Math.max(y3,y4)+0.001
            ){
                return { x:Px, y:Py };
            }
            return null;
        }

        function detectTriangles(){
            triangles.length=0;
            snapPoints.forEach(A=>{
                const neighborsA=A.connectedLines.map(conn=>(conn.endPoint==='start'?conn.line.end:conn.line.start));
                neighborsA.forEach(B=>{
                    if(B.id<=A.id) return;
                    const neighborsB=B.connectedLines.map(conn=>(conn.endPoint==='start'?conn.line.end:conn.line.start));
                    neighborsB.forEach(C=>{
                        if(C.id<=B.id) return;
                        if(C===A) return;
                        const isConnected=A.connectedLines.some(conn=>{
                            const other=(conn.endPoint==='start'?conn.line.end:conn.line.start);
                            return other===C;
                        });
                        if(isConnected){
                            triangles.push([A,B,C]);
                        }
                    });
                });
            });
        }

        function draw(){
            ctx.clearRect(0,0,canvas.width,canvas.height);
            drawGrid();
            detectTriangles();

            // fill if needed
            if(shouldFill && selectedSnapPoints.length>=3){
                ctx.fillStyle='rgba(128,128,128,0.3)';
                ctx.beginPath();
                ctx.moveTo(selectedSnapPoints[0].x - panOffset.x, selectedSnapPoints[0].y - panOffset.y);
                for(let i=1;i<selectedSnapPoints.length;i++){
                    ctx.lineTo(selectedSnapPoints[i].x - panOffset.x, selectedSnapPoints[i].y - panOffset.y);
                }
                ctx.closePath();
                ctx.fill();
            }

            shapes.forEach(shape=>{
                shape.draw();
            });

            ctx.strokeStyle='rgba(128,128,128,0.5)';
            ctx.lineWidth=1;
            triangles.forEach(tri=>{
                ctx.beginPath();
                ctx.moveTo(tri[0].x - panOffset.x, tri[0].y - panOffset.y);
                ctx.lineTo(tri[1].x - panOffset.x, tri[1].y - panOffset.y);
                ctx.lineTo(tri[2].x - panOffset.x, tri[2].y - panOffset.y);
                ctx.closePath();
                ctx.stroke();
            });

            if(hoveredSnapPoint){
                ctx.fillStyle='#00FF00';
                ctx.beginPath();
                ctx.arc(hoveredSnapPoint.x - panOffset.x, hoveredSnapPoint.y - panOffset.y, snapRadius,0,2*Math.PI);
                ctx.globalAlpha=0.3;
                ctx.fill();
                ctx.globalAlpha=1.0;
            }

            if(selectedSnapPoints.length>0){
                selectedSnapPoints.forEach(sp=>{
                    ctx.strokeStyle='#00FFFF';
                    ctx.lineWidth=3;
                    ctx.beginPath();
                    ctx.arc(sp.x - panOffset.x, sp.y - panOffset.y, snapRadius,0,2*Math.PI);
                    ctx.stroke();
                });
            }

            if(snapPointsVisible){
                snapPoints.forEach(sp=>{
                    if(sp.connectedLines.length===0){
                        ctx.fillStyle='#FF0000';
                        ctx.beginPath();
                        ctx.arc(sp.x - panOffset.x, sp.y - panOffset.y,6,0,2*Math.PI);
                        ctx.fill();
                    }
                });
            }

            if(snapPointsVisible){
                shapes.forEach(shape=>{
                    if(shape.type==='line'){
                        ctx.fillStyle='#FF0000';
                        ctx.beginPath();
                        ctx.arc(shape.start.x - panOffset.x, shape.start.y - panOffset.y,6,0,2*Math.PI);
                        ctx.fill();

                        ctx.beginPath();
                        ctx.arc(shape.end.x - panOffset.x, shape.end.y - panOffset.y,6,0,2*Math.PI);
                        ctx.fill();
                    }
                });
            }

            if(arrowsVisible){
                shapes.forEach(shape=>{
                    if(shape.type==='line'){
                        drawArrow(shape.start, shape.end);
                    }
                });
            }

            if(isMotorRunning){
                ctx.strokeStyle='rgba(0,0,255,0.3)';
                ctx.lineWidth=1;
                snapPoints.forEach(sp=>{
                    if(sp.trail.length>1){
                        ctx.beginPath();
                        ctx.moveTo(sp.trail[0].x - panOffset.x, sp.trail[0].y - panOffset.y);
                        for(let i=1;i<sp.trail.length;i++){
                            ctx.lineTo(sp.trail[i].x - panOffset.x, sp.trail[i].y - panOffset.y);
                        }
                        ctx.stroke();
                    }
                });
            }

            if(isDragging && currentVector){
                if(origin.type==='line'){
                    ctx.strokeStyle='#B0B0B0';
                    ctx.setLineDash([7,3]);
                    ctx.beginPath();
                    ctx.moveTo(origin.startSnapPoint.x - panOffset.x, origin.startSnapPoint.y - panOffset.y);
                    ctx.lineTo(currentVector.x - panOffset.x, currentVector.y - panOffset.y);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    ctx.strokeStyle='#333333';
                    ctx.beginPath();
                    ctx.arc(currentVector.x - panOffset.x, currentVector.y - panOffset.y,4,0,2*Math.PI);
                    ctx.fill();
                }
            }

            if(isCtrlDragging && origin.snapPoint){
                ctx.fillStyle='#FFA500';
                ctx.beginPath();
                ctx.arc(origin.snapPoint.x - panOffset.x, origin.snapPoint.y - panOffset.y, snapRadius,0,2*Math.PI);
                ctx.globalAlpha=0.2;
                ctx.fill();
                ctx.globalAlpha=1.0;

                const nearestSnap=findNearbySnapPoint(origin.snapPoint.x, origin.snapPoint.y, [origin.snapPoint]);
                if(nearestSnap){
                    ctx.fillStyle='#00FF00';
                    ctx.beginPath();
                    ctx.arc(nearestSnap.x - panOffset.x, nearestSnap.y - panOffset.y, snapRadius,0,2*Math.PI);
                    ctx.globalAlpha=0.3;
                    ctx.fill();
                    ctx.globalAlpha=1.0;
                }
            }

            if(selectedSnapPoint){
                ctx.strokeStyle='#0000FF';
                ctx.lineWidth=3;
                ctx.beginPath();
                ctx.arc(selectedSnapPoint.x - panOffset.x, selectedSnapPoint.y - panOffset.y, snapRadius,0,2*Math.PI);
                ctx.stroke();
            }

            let alignText='None';
            if(isXAligned && isYAligned){
                alignText='X & Y';
            } else if(isXAligned){
                alignText='X';
            } else if(isYAligned){
                alignText='Y';
            }
            alignmentStatus.textContent=`Alignment: ${alignText}`;
        }

        const motorRotatingLines=new Set();
        const rotatingLines=new Set();

        class Shape {
            constructor(type){ this.type=type; }
            isPointInside(x,y){ return false; }
            draw(){}
            getSnapPoints(){ return[]; }
        }

        class SnapPoint {
            static nextId=0;
            constructor(x,y,type='standard'){
                this.id=SnapPoint.nextId++;
                this.x=x;
                this.y=y;
                this.type=type;
                this.connectedLines=[];
                this.rotationDirection='clockwise';
                this.trail=[];
            }
            addLine(line,endPoint){
                this.connectedLines.push({ line, endPoint });
            }
            removeLine(line){
                this.connectedLines=this.connectedLines.filter(conn=>conn.line!==line);
            }
            move(newX,newY,silent=false){
                if(isMotorRunning){
                    this.trail.push({x:newX,y:newY});
                    if(this.trail.length>200){
                        this.trail.shift();
                    }
                }
                this.x=newX; 
                this.y=newY;
                if(!silent){
                    this.connectedLines.forEach(conn=>{
                        conn.line.updateCenter();
                    });
                }
            }
            isNear(x,y){
                return Math.hypot(this.x - x, this.y - y)<=snapRadius;
            }
        }

        class Line extends Shape {
            static nextId=0;
            constructor(start,end){
                super('line');
                this.id=Line.nextId++;
                this.start=start;
                this.end=end;
                this.updateCenter();
                this.start.addLine(this,'start');
                this.end.addLine(this,'end');
            }
            updateCenter(){
                this.center={
                    x:(this.start.x+this.end.x)/2,
                    y:(this.start.y+this.end.y)/2
                };
            }
            isPointInside(x,y){
                const dist=pointLineDistance({x,y},this.start,this.end);
                return dist<=6;
            }
            draw(){
                if(!this.start||!this.end) return;
                if(isMotorRunning && motorRotatingLines.has(this)){
                    ctx.strokeStyle='#32CD32';
                } else if(isRotating && rotatingLines.has(this)){
                    ctx.strokeStyle='#FF4500';
                } else {
                    ctx.strokeStyle='#333333';
                }
                ctx.lineWidth=2;
                ctx.beginPath();
                ctx.moveTo(this.start.x - panOffset.x, this.start.y - panOffset.y);
                ctx.lineTo(this.end.x - panOffset.x, this.end.y - panOffset.y);
                ctx.stroke();

                if(selectedSnapPoints.length>0){
                    selectedSnapPoints.forEach(sp=>{
                        ctx.strokeStyle='#00FFFF';
                        ctx.lineWidth=3;
                        ctx.beginPath();
                        ctx.arc(sp.x - panOffset.x, sp.y - panOffset.y, snapRadius,0,2*Math.PI);
                        ctx.stroke();
                    });
                }

                if(arrowsVisible){
                    drawArrow(this.start,this.end);
                }
            }
            getSnapPoints(){
                return [
                    { x:this.start.x, y:this.start.y },
                    { x:this.end.x,   y:this.end.y }
                ];
            }
            setEndPoint(endPoint,newPos){
                if(endPoint==='start'){
                    if(newPos instanceof SnapPoint){
                        this.start.removeLine(this);
                        this.start=newPos;
                        this.start.addLine(this,'start');
                    } else {
                        this.start.move(newPos.x,newPos.y);
                    }
                } else if(endPoint==='end'){
                    if(newPos instanceof SnapPoint){
                        this.end.removeLine(this);
                        this.end=newPos;
                        this.end.addLine(this,'end');
                    } else {
                        this.end.move(newPos.x,newPos.y);
                    }
                }
                this.updateCenter();
            }
            rotate(deltaAngle,anchor){
                const cos=Math.cos(deltaAngle);
                const sin=Math.sin(deltaAngle);
                let startX=this.start.x - anchor.x;
                let startY=this.start.y - anchor.y;
                let endX=this.end.x - anchor.x;
                let endY=this.end.y - anchor.y;
                const rStartX=startX*cos - startY*sin;
                const rStartY=startX*sin + startY*cos;
                const rEndX=endX*cos - endY*sin;
                const rEndY=endX*sin + endY*cos;
                this.start.move(rStartX+anchor.x,rStartY+anchor.y);
                this.end.move(rEndX+anchor.x,  rEndY+anchor.y);
                this.updateCenter();
            }
            isPointOnLine(point,tolerance=5){
                const dist=pointLineDistance(point,this.start,this.end);
                return dist<=tolerance;
            }
            splitAtPoint(point){
                if((point.x===this.start.x && point.y===this.start.y)||
                   (point.x===this.end.x   && point.y===this.end.y)){
                    console.warn('Split point is an endpoint. Aborted.');
                    return [];
                }
                let existingSnap=findNearbySnapPoint(point.x,point.y);
                if(!existingSnap){
                    existingSnap=new SnapPoint(point.x,point.y);
                    snapPoints.push(existingSnap);
                }
                if((existingSnap.x===this.start.x && existingSnap.y===this.start.y)||
                   (existingSnap.x===this.end.x   && existingSnap.y===this.end.y)){
                    console.warn('Split point is existing endpoint. Aborted.');
                    return [];
                }
                const line1=new Line(this.start,existingSnap);
                const line2=new Line(existingSnap,this.end);
                shapes.push(line1,line2);
                const idx=shapes.findIndex(l=>l.id===this.id);
                if(idx>-1) shapes.splice(idx,1);
                else console.warn(`Original line ID:${this.id} not found in shapes array.`);
                console.log(`Line ID:${this.id} split => line1:${line1.id}, line2:${line2.id}`);
                return [line1,line2];
            }
        }

        function checkAndHandleIntersections(newLine){
            shapes.forEach(existingLine=>{
                if(existingLine===newLine) return;
                const intersection=getLineIntersection(newLine,existingLine);
                if(intersection){
                    console.log(`Intersection at (${intersection.x},${intersection.y}) b/w newLine:${newLine.id} & line:${existingLine.id}`);
                    let existingSnap=findNearbySnapPoint(intersection.x,intersection.y);
                    if(!existingSnap){
                        existingSnap=new SnapPoint(intersection.x,intersection.y);
                        snapPoints.push(existingSnap);
                        console.log(`Created new SnapPoint ID:${existingSnap.id}`);
                    }
                    const [line1,line2]=existingLine.splitAtPoint(existingSnap);
                    if(line1 && line2){
                        undoStack.push({
                            type:'splitLine',
                            originalLineId:existingLine.id,
                            newLines:[line1.id,line2.id],
                            splitPoint:{x:existingSnap.x,y:existingSnap.y}
                        });
                        redoStack.length=0;
                    }
                }
            });
        }

        canvas.addEventListener('contextmenu', e=> e.preventDefault());

        // MOUSE DOWN
        canvas.addEventListener('mousedown', e=>{
            const pos=getMousePos(e);
            dragStartPos=pos;
            hasDragged=false;
            lockedAxis=null; // reset for "C" usage

            currentMouseButton=e.button;

            // ctrl+alt => selection rectangle
            if(e.ctrlKey && e.altKey && e.button===0){
                isSelectionRectActive=true;
                selectionRectStart={x:pos.x,y:pos.y};
                selectionRectCurrent={x:pos.x,y:pos.y};
                selectionRectElement.style.display='block';
                selectionRectElement.style.left=`${selectionRectStart.x - panOffset.x}px`;
                selectionRectElement.style.top=`${selectionRectStart.y - panOffset.y}px`;
                selectionRectElement.style.width='0px';
                selectionRectElement.style.height='0px';
                return;
            }

            if(e.shiftKey && e.button===2){
                const sp=findNearbySnapPoint(pos.x,pos.y);
                if(sp){
                    selectedSnapPoint=sp;
                    console.log(`Selected SnapPoint ID:${sp.id}`);
                } else {
                    selectedSnapPoint=null;
                }
                draw();
                return;
            }

            if(e.button===2||e.button===0) e.preventDefault();

            if((e.button===0||e.button===2) && e.ctrlKey && !e.altKey){
                const sp=findNearbySnapPoint(pos.x,pos.y);
                if(sp){
                    isDragging=true;
                    isCtrlDragging=true;
                    isCtrlAltDragging=e.altKey;
                    origin={type:'snapPoint',snapPoint:sp};
                    currentVector={x:sp.x,y:sp.y};
                    draw();
                    return;
                }
            }

            if(e.altKey){
                rotationTarget=shapes.find(shape=>shape.isPointInside(pos.x,pos.y));
                if(rotationTarget){
                    isRotating=true;
                    rotationAnchor=rotationTarget.center;
                    initialMousePos=pos;
                    initialVectors[rotationTarget.id]={
                        start:{x:rotationTarget.start.x,y:rotationTarget.start.y},
                        end:{x:rotationTarget.end.x,y:rotationTarget.end.y}
                    };
                    rotatingLines.add(rotationTarget);
                    draw();
                    return;
                }
                const sp=findNearbySnapPoint(pos.x,pos.y);
                if(sp){
                    const connectedLines=sp.connectedLines.map(conn=>conn.line);
                    if(connectedLines.length>0){
                        isRotating=true;
                        rotationAnchor=sp;
                        initialMousePos=pos;
                        connectedLines.forEach(line=>{
                            initialVectors[line.id]={
                                start:{x:line.start.x,y:line.start.y},
                                end:{x:line.end.x,y:line.end.y}
                            };
                            rotatingLines.add(line);
                        });
                        draw();
                        return;
                    }
                }
            }

            // left => new line
            if(e.button===0 && !e.altKey && !e.ctrlKey && !e.shiftKey){
                isDragging=true;
                isCtrlDragging=false;
                isCtrlAltDragging=false;
                const sp=findNearbySnapPoint(pos.x,pos.y);
                let startSnapPoint;
                if(sp){
                    startSnapPoint=sp;
                } else {
                    startSnapPoint=new SnapPoint(pos.x,pos.y);
                    snapPoints.push(startSnapPoint);
                }
                currentVector={x:pos.x,y:pos.y};
                origin={type:'line', line:null, startSnapPoint};
                draw();
                return;
            }

            // right => new line
            if(e.button===2 && !e.altKey && !e.ctrlKey && !e.shiftKey){
                isDragging=true;
                isCtrlDragging=false;
                isCtrlAltDragging=false;
                const sp=findNearbySnapPoint(pos.x,pos.y);
                let startSnapPoint;
                if(sp){
                    startSnapPoint=sp;
                } else {
                    startSnapPoint=new SnapPoint(pos.x,pos.y);
                    snapPoints.push(startSnapPoint);
                }
                currentVector={x:pos.x,y:pos.y};
                origin={type:'line',line:null,startSnapPoint};
                draw();
                return;
            }

            // shift+left => detach lines
            if(e.shiftKey && e.button===0){
                if(selectedSnapPoint){
                    const connectedLines=[...selectedSnapPoint.connectedLines];
                    connectedLines.forEach(conn=>{
                        const line=conn.line;
                        const newSnap=new SnapPoint(selectedSnapPoint.x,selectedSnapPoint.y);
                        snapPoints.push(newSnap);
                        if(conn.endPoint==='start'){
                            line.setEndPoint('start',newSnap);
                        } else {
                            line.setEndPoint('end',newSnap);
                        }
                        console.log(`Detached line ${line.id} from snapPoint ${selectedSnapPoint.id}`);
                    });
                    isDragging=true;
                    isCtrlDragging=false;
                    isCtrlAltDragging=false;
                    currentVector={x:pos.x,y:pos.y};
                    origin={type:'line',line:null,startSnapPoint:selectedSnapPoint};
                    draw();
                    return;
                }
            }
        });

        // MOUSE MOVE
        canvas.addEventListener('mousemove', e=>{
            const pos=getMousePos(e);
            hoveredSnapPoint=findNearbySnapPoint(pos.x,pos.y);

            if(isDragging){
                if(isCtrlAltDragging){
                    canvas.style.cursor='not-allowed';
                } else if(isCtrlDragging){
                    if(e.ctrlKey && e.shiftKey){
                        canvas.style.cursor='nwse-resize';
                    } else {
                        canvas.style.cursor='move';
                    }
                } else {
                    if(e.ctrlKey && e.shiftKey){
                        canvas.style.cursor='nwse-resize';
                    } else {
                        canvas.style.cursor='crosshair';
                    }
                }
            } else if(isRotating){
                canvas.style.cursor='grab';
            } else if(isMotorRunning){
                canvas.style.cursor='default';
            } else if(isSelectionRectActive){
                canvas.style.cursor='crosshair';
            } else {
                if(hoveredSnapPoint){
                    canvas.style.cursor='pointer';
                } else {
                    canvas.style.cursor='default';
                }
            }

            if(isDragging && origin.type==='line'){
                // apply "C" axis constraint
                let newPos={ x: pos.x, y: pos.y };
                newPos = applyCKeyAxisConstraint(dragStartPos, newPos);

                // also apply alignment if X or Y is toggled
                if(isXAligned||isYAligned){
                    newPos=applyAlignmentConstraints(dragStartPos,newPos);
                }
                currentVector=newPos;
            }

            if(isSelectionRectActive){
                selectionRectCurrent={x:pos.x,y:pos.y};
                const rect=getRectangleCoordinates(selectionRectStart, selectionRectCurrent);
                selectionRectElement.style.left=`${rect.x - panOffset.x}px`;
                selectionRectElement.style.top=`${rect.y - panOffset.y}px`;
                selectionRectElement.style.width=`${rect.width}px`;
                selectionRectElement.style.height=`${rect.height}px`;
                draw();
                return;
            }

            if(isDragging){
                hasDragged=true;
                if(isCtrlAltDragging){
                    // ...
                } else if(isCtrlDragging){
                    let newX=pos.x;
                    let newY=pos.y;

                    // apply "C" axis constraint
                    let cResult = applyCKeyAxisConstraint(dragStartPos,{x:newX,y:newY});
                    newX=cResult.x; 
                    newY=cResult.y;

                    if(isXAligned||isYAligned){
                        const oldPos={x:origin.snapPoint.x,y:origin.snapPoint.y};
                        const cPos=applyAlignmentConstraints(oldPos,{x:newX,y:newY});
                        newX=cPos.x; newY=cPos.y;
                    }
                    const nearestSnap=findNearbySnapPoint(newX,newY,[origin.snapPoint]);
                    if(nearestSnap){
                        newX=nearestSnap.x; 
                        newY=nearestSnap.y;
                    }
                    if(e.ctrlKey && e.shiftKey){
                        const dx=newX-origin.snapPoint.x;
                        const dy=newY-origin.snapPoint.y;
                        let angle=Math.atan2(dy,dx);
                        angle=snapTo45Degrees(angle);
                        const dist=Math.hypot(dx,dy);
                        newX=origin.snapPoint.x+dist*Math.cos(angle);
                        newY=origin.snapPoint.y+dist*Math.sin(angle);
                    }
                    origin.snapPoint.move(newX,newY);
                } else if(origin.type==='line'){
                    let endX=pos.x;
                    let endY=pos.y;

                    // apply "C" axis constraint
                    let cResult=applyCKeyAxisConstraint(dragStartPos,{x:endX,y:endY});
                    endX=cResult.x; endY=cResult.y;

                    if(isXAligned||isYAligned){
                        const oPos={x:origin.startSnapPoint.x,y:origin.startSnapPoint.y};
                        const adj=applyAlignmentConstraints(oPos,{x:endX,y:endY});
                        endX=adj.x; endY=adj.y;
                    }
                    const sp=findNearbySnapPoint(endX,endY);
                    if(sp){
                        endX=sp.x; 
                        endY=sp.y;
                    }
                    currentVector={x:endX,y:endY};
                }
            }

            if(isRotating && rotationTarget){
                let deltaAngle;
                const anchorX=rotationAnchor.x;
                const anchorY=rotationAnchor.y;
                const angle1=Math.atan2(initialMousePos.y-anchorY, initialMousePos.x-anchorX);
                const angle2=Math.atan2(pos.y-anchorY, pos.x-anchorX);
                deltaAngle=angle2-angle1;
                if(deltaAngle>Math.PI) deltaAngle-=2*Math.PI;
                if(deltaAngle<-Math.PI) deltaAngle+=2*Math.PI;
                if(e.shiftKey) deltaAngle=snapToGrid(deltaAngle);

                if(rotationAnchor.rotationDirection==='counter-clockwise'){
                    deltaAngle=-deltaAngle;
                }
                rotatingLines.forEach(line=>{
                    line.rotate(deltaAngle,rotationAnchor);
                });
                initialMousePos={x:pos.x,y:pos.y};
                draw();
            }

            draw();
        });

        // MOUSE UP
        canvas.addEventListener('mouseup', e=>{
            const pos=getMousePos(e);
            const releasedMouseButton=currentMouseButton;
            currentMouseButton=null;

            if(isSelectionRectActive){
                const rect=getRectangleCoordinates(selectionRectStart, selectionRectCurrent);
                const selectedInRect=snapPoints.filter(sp=>isPointInRect(sp,rect));
                // toggle each sp in or out
                selectedInRect.forEach(sp=>{
                    const idx=selectedSnapPoints.indexOf(sp);
                    if(idx===-1){
                        selectedSnapPoints.push(sp);
                    } else {
                        selectedSnapPoints.splice(idx,1);
                    }
                });
                selectionRectElement.style.display='none';
                isSelectionRectActive=false;
                undoStack.push({
                    type:'selectRectangle',
                    selectedSnapPoints:selectedInRect.map(sp=>sp.id),
                    mode:'toggle'
                });
                redoStack.length=0;
                draw();
                return;
            }

            if(isDragging){
                if(isCtrlDragging){
                    const sp=origin.snapPoint;
                    const nearestSnap=findNearbySnapPoint(sp.x,sp.y,[sp]);
                    // record for undo
                    const action={
                        type:'moveSnapPoint',
                        snapPoint: sp,
                        prevPosition:{x:dragStartPos.x,y:dragStartPos.y},
                        newPosition:{x:sp.x,y:sp.y}
                    };
                    if(nearestSnap){
                        sp.connectedLines.forEach(conn=>{
                            conn.line.setEndPoint(conn.endPoint, nearestSnap);
                            nearestSnap.addLine(conn.line, conn.endPoint);
                        });
                        const idx=snapPoints.indexOf(sp);
                        if(idx>-1) snapPoints.splice(idx,1);
                    }
                    undoStack.push(action);
                    redoStack.length=0;
                } else if(origin.type==='line'){
                    if(hasDragged){
                        let startSnapPoint=origin.startSnapPoint;
                        let endSnapPoint;
                        if(findNearbySnapPoint(currentVector.x,currentVector.y)){
                            endSnapPoint=findNearbySnapPoint(currentVector.x,currentVector.y);
                        } else {
                            endSnapPoint=new SnapPoint(currentVector.x,currentVector.y);
                            snapPoints.push(endSnapPoint);
                        }
                        if(startSnapPoint.x===endSnapPoint.x && startSnapPoint.y===endSnapPoint.y){
                            isDragging=false;
                            draw();
                            return;
                        }
                        const newLine=new Line(startSnapPoint,endSnapPoint);
                        shapes.push(newLine);
                        undoStack.push({type:'addShape',shape:newLine});
                        redoStack.length=0;
                        checkAndHandleIntersections(newLine);
                    }
                }
                currentVector=null;
                isDragging=false;
                isCtrlDragging=false;
                isCtrlAltDragging=false;
            } else if(isRotating){
                const action={
                    type:'rotateShape',
                    shapes:Array.from(rotatingLines).map(line=>line.id),
                    anchor: rotationAnchor.id||null,
                    rotationSpeed: motorRotationSpeed
                };
                undoStack.push(action);
                redoStack.length=0;
                isRotating=false;
                rotationTarget=null;
                rotationAnchor=null;
                initialVectors={};
                rotatingLines.clear();
            } else {
                if(!hasDragged && releasedMouseButton!==null){
                    const sp=findNearbySnapPoint(pos.x,pos.y);
                    if(sp){
                        if((releasedMouseButton===0||releasedMouseButton===2) && e.ctrlKey && e.altKey){
                            toggleSelection(sp,'toggle');
                        } else if((releasedMouseButton===0||releasedMouseButton===2) && e.ctrlKey && !e.altKey){
                            toggleSelection(sp,'add');
                        } else if((releasedMouseButton===0||releasedMouseButton===2) && e.shiftKey){
                            toggleSelection(sp,'toggle');
                        } else {
                            selectedSnapPoints=[sp];
                        }
                        draw();
                    } else {
                        selectedSnapPoints=[];
                        draw();
                    }
                }
            }
            draw();
        });

        // PANNING
        canvas.addEventListener('mousedown', e=>{
            if(e.button===1){
                isPanning=true;
                panStart={x:e.clientX,y:e.clientY};
                canvas.style.cursor='grab';
                e.preventDefault();
            }
        });
        window.addEventListener('mouseup', e=>{
            if(e.button===1){
                isPanning=false;
                canvas.style.cursor='default';
            }
        });
        window.addEventListener('mousemove', e=>{
            if(isPanning){
                const dx=e.clientX - panStart.x;
                const dy=e.clientY - panStart.y;
                panStart={x:e.clientX,y:e.clientY};
                panOffset.x+=dx;
                panOffset.y+=dy;
                draw();
            }
        });

        // KEYBOARD
        window.addEventListener('keydown', e=>{
            // Space => motor
            if(e.code==='Space'){
                e.preventDefault();
                if(!isMotorRunning && selectedSnapPoints.length>0){
                    let anchor=selectedSnapPoints[0];
                    const connectedLines=selectedSnapPoints.flatMap(sp=>sp.connectedLines.map(conn=>conn.line));
                    const uniqueLines=Array.from(new Set(connectedLines));
                    if(uniqueLines.length>0){
                        motorOriginalPositions.clear();
                        uniqueLines.forEach(line=>{
                            motorOriginalPositions.set(line,{
                                start:{x:line.start.x,y:line.start.y},
                                end:{x:line.end.x,y:line.end.y}
                            });
                        });
                        isMotorRunning=true;
                        rotationStateElement.textContent='Rotation: Running';
                        uniqueLines.forEach(line=>motorRotatingLines.add(line));
                        motorRotationAnchor=anchor;
                        let prevTimestamp=null;
                        function rotateMotor(ts){
                            if(!isMotorRunning) return;
                            if(!prevTimestamp) prevTimestamp=ts;
                            const dt=ts - prevTimestamp;
                            prevTimestamp=ts;
                            const deltaAngle=motorRotationSpeed*(dt/(1000/60));
                            motorRotatingLines.forEach(line=>{
                                let angle=deltaAngle;
                                if(motorRotationAnchor.rotationDirection==='counter-clockwise'){
                                    angle=-deltaAngle;
                                }
                                line.rotate(angle,motorRotationAnchor);
                            });
                            draw();
                            requestAnimationFrame(rotateMotor);
                        }
                        requestAnimationFrame(rotateMotor);
                        undoStack.push({
                            type:'startMotorRotation',
                            snapPoints:selectedSnapPoints.map(sp=>sp.id),
                            shapes:uniqueLines.map(line=>line.id),
                            rotationSpeed:motorRotationSpeed,
                            rotationAnchorId:motorRotationAnchor.id
                        });
                        redoStack.length=0;
                    }
                } else if(isMotorRunning){
                    isMotorRunning=false;
                    rotationStateElement.textContent='Rotation: Stopped';
                    motorOriginalPositions.forEach((orig,line)=>{
                        line.start.move(orig.start.x,orig.start.y);
                        line.end.move(orig.end.x,orig.end.y);
                        line.updateCenter();
                    });
                    motorOriginalPositions.clear();
                    motorRotatingLines.clear();
                    motorRotationAnchor=null;
                    undoStack.push({type:'stopMotorRotation'});
                    redoStack.length=0;
                }
                draw();
            }

            // X => toggle x align
            if(e.key.toLowerCase()==='x'){
                e.preventDefault();
                if(isYAligned) isYAligned=false;
                isXAligned=!isXAligned;
                draw();
            }
            // Y => toggle y align
            if(e.key.toLowerCase()==='y'){
                e.preventDefault();
                if(isXAligned) isXAligned=false;
                isYAligned=!isYAligned;
                draw();
            }
            // H => hide snap points & arrows
            if(e.key.toLowerCase()==='h'){
                e.preventDefault();
                snapPointsVisible=!snapPointsVisible;
                arrowsVisible=!arrowsVisible;
                draw();
            }
            // F => fill shape
            if(e.key.toLowerCase()==='f'){
                e.preventDefault();
                shouldFill=!shouldFill;
                console.log('Fill shape toggled =>',shouldFill);
                draw();
            }
            // (B) "C" => toggle axis constraint mode
            if(e.key.toLowerCase()==='c'){
                e.preventDefault();
                isCKeyActive=!isCKeyActive;
                lockedAxis=null; // reset
                console.log('C key toggled =>', isCKeyActive);
            }

            // Delete => remove selected snap points
            if(e.key==='Delete'){
                if(selectedSnapPoints.length>0){
                    const linesToDelete=new Set();
                    selectedSnapPoints.forEach(sp=>{
                        sp.connectedLines.forEach(conn=>{
                            linesToDelete.add(conn.line);
                        });
                    });
                    const snapPointsToDelete=[...selectedSnapPoints];
                    const deletedLines=[...linesToDelete];
                    deletedLines.forEach(line=>{
                        const idx=shapes.indexOf(line);
                        if(idx>-1) shapes.splice(idx,1);
                        [line.start,line.end].forEach(sp=>sp.removeLine(line));
                    });
                    snapPointsToDelete.forEach(sp=>{
                        const spIndex=snapPoints.indexOf(sp);
                        if(spIndex>-1) snapPoints.splice(spIndex,1);
                    });
                    undoStack.push({
                        type:'deleteSnapPoints',
                        snapPoints:snapPointsToDelete.map(sp=>({
                            id:sp.id, x:sp.x, y:sp.y,
                            type:sp.type,
                            rotationDirection:sp.rotationDirection
                        })),
                        lines:deletedLines.map(line=>({
                            id:line.id,
                            start:{
                                id:line.start.id,
                                x:line.start.x,
                                y:line.start.y,
                                type:line.start.type,
                                rotationDirection:line.start.rotationDirection
                            },
                            end:{
                                id:line.end.id,
                                x:line.end.x,
                                y:line.end.y,
                                type:line.end.type,
                                rotationDirection:line.end.rotationDirection
                            }
                        }))
                    });
                    redoStack.length=0;
                    selectedSnapPoints=[];
                    draw();
                }
            }

            // Undo / Redo
            if(e.ctrlKey && (e.key==='z' || e.key==='Z')){
                const action=undoStack.pop();
                if(action){
                    if(action.type==='addShape'){
                        const idx=shapes.indexOf(action.shape);
                        if(idx>-1){
                            shapes.splice(idx,1);
                            [action.shape.start,action.shape.end].forEach(sp=>{
                                sp.removeLine(action.shape);
                                if(sp.connectedLines.length===0 && sp.type!=='center'){
                                    const spIdx=snapPoints.indexOf(sp);
                                    if(spIdx>-1) snapPoints.splice(spIdx,1);
                                }
                            });
                            redoStack.push(action);
                        }
                    } else if(action.type==='rotateShape'){
                        action.shapes.forEach(lineId=>{
                            const line=shapes.find(l=>l.id===lineId);
                            if(line && initialVectors[line.id]){
                                line.setEndPoint('start',{x:initialVectors[line.id].start.x,y:initialVectors[line.id].start.y});
                                line.setEndPoint('end',{x:initialVectors[line.id].end.x,y:initialVectors[line.id].end.y});
                            }
                        });
                        redoStack.push(action);
                    } else if(action.type==='moveSnapPoint'){
                        const sp=snapPoints.find(s=>s.id===action.snapPoint.id);
                        if(sp){
                            sp.move(action.prevPosition.x,action.prevPosition.y);
                            redoStack.push(action);
                        }
                    } else if(action.type==='startMotorRotation'){
                        redoStack.push(action);
                    } else if(action.type==='stopMotorRotation'){
                        redoStack.push(action);
                    } else if(action.type==='deleteSnapPoints'){
                        action.snapPoints.forEach(spData=>{
                            const restored=new SnapPoint(spData.x,spData.y,spData.type);
                            restored.id=spData.id;
                            restored.rotationDirection=spData.rotationDirection;
                            snapPoints.push(restored);
                        });
                        action.lines.forEach(lineData=>{
                            const st=snapPoints.find(s=>s.id===lineData.start.id);
                            const en=snapPoints.find(s=>s.id===lineData.end.id);
                            if(st && en){
                                const restoredLine=new Line(st,en);
                                restoredLine.id=lineData.id;
                                shapes.push(restoredLine);
                            }
                        });
                        redoStack.push(action);
                    } else if(action.type==='selectRectangle'){
                        if(action.mode==='toggle'){
                            action.selectedSnapPoints.forEach(id=>{
                                const sp=snapPoints.find(s=>s.id===id);
                                if(sp){
                                    const idx=selectedSnapPoints.indexOf(sp);
                                    if(idx===-1){
                                        selectedSnapPoints.push(sp);
                                    } else {
                                        selectedSnapPoints.splice(idx,1);
                                    }
                                }
                            });
                        } else if(action.mode==='replace'){
                            selectedSnapPoints=[];
                        }
                        redoStack.push(action);
                    }
                }
                draw();
            } else if(e.ctrlKey && (e.key==='y'||e.key==='Y')){
                const action=redoStack.pop();
                if(action){
                    if(action.type==='addShape'){
                        shapes.push(action.shape);
                        action.shape.start.addLine(action.shape,'start');
                        action.shape.end.addLine(action.shape,'end');
                        undoStack.push(action);
                    } else if(action.type==='rotateShape'){
                        undoStack.push(action);
                    } else if(action.type==='moveSnapPoint'){
                        const sp=snapPoints.find(s=>s.id===action.snapPoint.id);
                        if(sp){
                            sp.move(action.newPosition.x,action.newPosition.y);
                            undoStack.push(action);
                        }
                    } else if(action.type==='startMotorRotation'){
                        if(!isMotorRunning && action.snapPoints.length>0){
                            const connected=action.shapes.map(id=>shapes.find(l=>l.id===id)).filter(l=>l);
                            if(connected.length>0){
                                isMotorRunning=true;
                                rotationStateElement.textContent='Rotation: Running';
                                connected.forEach(line=>motorRotatingLines.add(line));
                                motorRotationAnchor=snapPoints.find(sp=>sp.id===action.rotationAnchorId);
                                let prevTimestamp=null;
                                function rotateMotorRedo(ts){
                                    if(!isMotorRunning) return;
                                    if(!prevTimestamp) prevTimestamp=ts;
                                    const dt=ts-prevTimestamp;
                                    prevTimestamp=ts;
                                    const deltaAngle=action.rotationSpeed*(dt/(1000/60));
                                    motorRotatingLines.forEach(line=>{
                                        let angle=deltaAngle;
                                        if(motorRotationAnchor.rotationDirection==='counter-clockwise'){
                                            angle=-deltaAngle;
                                        }
                                        line.rotate(angle,motorRotationAnchor);
                                    });
                                    draw();
                                    requestAnimationFrame(rotateMotorRedo);
                                }
                                requestAnimationFrame(rotateMotorRedo);
                            }
                        }
                        undoStack.push(action);
                    } else if(action.type==='stopMotorRotation'){
                        if(isMotorRunning){
                            isMotorRunning=false;
                            rotationStateElement.textContent='Rotation: Stopped';
                            motorRotatingLines.clear();
                            motorRotationAnchor=null;
                        }
                        undoStack.push(action);
                    } else if(action.type==='deleteSnapPoints'){
                        const {snapPoints:spList, lines:lList}=action;
                        lList.forEach(lineData=>{
                            const line=shapes.find(l=>l.id===lineData.id);
                            if(line){
                                shapes.splice(shapes.indexOf(line),1);
                                [line.start,line.end].forEach(sp=>sp.removeLine(line));
                            }
                        });
                        spList.forEach(spData=>{
                            const sp=snapPoints.find(s=>s.id===spData.id);
                            if(sp){
                                const spIndex=snapPoints.indexOf(sp);
                                if(spIndex>-1) snapPoints.splice(spIndex,1);
                            }
                        });
                        undoStack.push(action);
                    } else if(action.type==='selectRectangle'){
                        if(action.mode==='toggle'){
                            action.selectedSnapPoints.forEach(id=>{
                                const sp=snapPoints.find(s=>s.id===id);
                                if(sp){
                                    const idx=selectedSnapPoints.indexOf(sp);
                                    if(idx===-1) selectedSnapPoints.push(sp);
                                    else selectedSnapPoints.splice(idx,1);
                                }
                            });
                        } else if(action.mode==='replace'){
                            selectedSnapPoints=action.selectedSnapPoints.map(id=>snapPoints.find(sp=>sp.id===id)).filter(sp=>sp);
                        }
                        undoStack.push(action);
                    }
                }
                draw();
            }
        });

        function toggleSelection(snapPoint, mode='toggle'){
            if(mode==='toggle'){
                const idx=selectedSnapPoints.indexOf(snapPoint);
                if(idx===-1){
                    selectedSnapPoints.push(snapPoint);
                    console.log(`Selecting SnapPoint ID:${snapPoint.id}`);
                } else {
                    selectedSnapPoints.splice(idx,1);
                    console.log(`Deselecting SnapPoint ID:${snapPoint.id}`);
                }
            } else if(mode==='add'){
                if(!selectedSnapPoints.includes(snapPoint)){
                    selectedSnapPoints.push(snapPoint);
                    console.log(`Adding SnapPoint ID:${snapPoint.id} to selection`);
                }
            }
        }

        function getRectangleCoordinates(start, current){
            const x=Math.min(start.x,current.x);
            const y=Math.min(start.y,current.y);
            const width=Math.abs(current.x-start.x);
            const height=Math.abs(current.y-start.y);
            return { x,y,width,height };
        }
        function isPointInRect(sp,rect){
            return (
                sp.x>=rect.x && sp.x<=rect.x+rect.width &&
                sp.y>=rect.y && sp.y<=rect.y+rect.height
            );
        }

        saveButton.addEventListener('click', ()=>{
            const tempCanvas=document.createElement('canvas');
            tempCanvas.width=canvas.width;
            tempCanvas.height=canvas.height;
            const tempCtx=tempCanvas.getContext('2d');
            tempCtx.fillStyle='#FFFFFF';
            tempCtx.fillRect(0,0,tempCanvas.width,tempCanvas.height);
            tempCtx.drawImage(canvas,0,0);
            const link=document.createElement('a');
            link.download='canvas_image.png';
            link.href=tempCanvas.toDataURL();
            link.click();
        });

        draw();
    </script>
</body>
</html>
