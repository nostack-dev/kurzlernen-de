<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>DAW-X — Physikalisch direkte Engine (Single-File, Worklet+Fallback)</title>
<style>
:root{--bg:#0f1117;--fg:#e6edf3;--mut:#8b9eb0;--b1:#18202a;--b2:#212b38;--ac:#4cc9f0;--ok:#2bd97f;--bad:#ff5c7a}
*{box-sizing:border-box}html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu}
.wrap{max-width:1024px;margin:0 auto;padding:18px}
h1{margin:6px 0 2px 0;font-size:18px}
p.small{color:var(--mut);font-size:12px;margin:6px 0 14px}
.panel{background:var(--b1);border:1px solid #2a3544;border-radius:12px;padding:12px;margin:10px 0}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.spacer{flex:1}
button,input,select{background:var(--b2);color:var(--fg);border:1px solid #2a3544;border-radius:8px;padding:10px 12px}
button{cursor:pointer}
button.primary{border-color:var(--ac);box-shadow:inset 0 0 0 1px color-mix(in oklab,var(--ac) 40%, transparent)}
button:disabled{opacity:.5;cursor:not-allowed}
label{display:flex;align-items:center;gap:6px;color:var(--mut)}
input.num{width:92px;text-align:center}
select{padding-right:24px}
.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(230px,1fr));gap:10px}
.kv{display:grid;grid-template-columns:auto 1fr;gap:8px;align-items:center}
.led{width:10px;height:10px;border-radius:50%;display:inline-block;margin-left:6px;box-shadow:0 0 0 1px #0006}
.led.ok{background:var(--ok)}.led.off{background:#555}.led.warn{background:#facc15}.led.bad{background:var(--bad)}
canvas{width:100%;height:72px;background:#0b0f16;border:1px solid #2a3544;border-radius:8px}
</style>
</head>
<body>
<div class="wrap">
  <h1>DAW-X — Physikalisch direkte Engine</h1>
  <p class="small">Eine globale, unteilbare Sample-Zeit <em>n</em> ⇒ Beat-Phase φ(n)=frac(n/SPB). Alle Klänge sind deterministische Funktionen von (n, φ). Keine JS-Timer, kein Sequencer.</p>

  <div class="panel">
    <div class="row">
      <button id="start" class="primary">Start</button>
      <button id="stop">Stop</button>
      <div class="spacer"></div>
      <label>BPM <input id="bpm" class="num" type="number" min="20" max="300" step="1" value="120"></label>
      <button id="bpmDown">−5</button><button id="bpmUp">+5</button>
      <label>Seed <input id="seed" class="num" type="number" value="2654435761"></label>
      <button id="reseat">Re-Seed</button>
      <span class="small">Engine <span id="led" class="led off" title="off=stopped, ok=Worklet, warn=Fallback"></span></span>
    </div>
  </div>

  <div class="panel">
    <div class="grid">
      <div>
        <strong>KICK (Euklidisch)</strong>
        <div class="kv"><label><input type="checkbox" id="kickEn" checked> aktiv</label></div>
        <div class="kv"><label>f0</label><input id="kickF0" class="num" type="number" value="55" min="20" max="200"></div>
        <div class="kv"><label>Sweep Hz</label><input id="kickSweep" class="num" type="number" value="90" min="0" max="600"></div>
        <div class="kv"><label>Decay ms</label><input id="kickDecay" class="num" type="number" value="140" min="10" max="2000"></div>
        <div class="kv"><label>Gain</label><input id="kickGain" class="num" type="number" value="0.9" step="0.05" min="0" max="2"></div>
        <div class="kv"><label>Pattern E(k,S,R)</label>
          <input id="kickSteps" class="num" type="number" value="16" min="1" max="64" title="S (Steps)">
          <input id="kickFill"  class="num" type="number" value="4"  min="0" max="64" title="k (Fill)">
          <input id="kickRot"   class="num" type="number" value="0"  min="0" max="64" title="R (Rotate)">
        </div>
      </div>

      <div>
        <strong>SNARE (Euklidisch)</strong>
        <div class="kv"><label><input type="checkbox" id="snareEn" checked> aktiv</label></div>
        <div class="kv"><label>Noise</label><input id="snareNoise" class="num" type="number" value="0.7" min="0" max="1" step="0.05"></div>
        <div class="kv"><label>HP Hz</label><input id="snareHP" class="num" type="number" value="900" min="60" max="9000"></div>
        <div class="kv"><label>Decay ms</label><input id="snareDecay" class="num" type="number" value="220" min="10" max="2000"></div>
        <div class="kv"><label>Gain</label><input id="snareGain" class="num" type="number" value="0.7" step="0.05" min="0" max="2"></div>
        <div class="kv"><label>Pattern E(k,S,R)</label>
          <input id="snareSteps" class="num" type="number" value="16" min="1" max="64">
          <input id="snareFill"  class="num" type="number" value="2"  min="0" max="64">
          <input id="snareRot"   class="num" type="number" value="8"  min="0" max="64">
        </div>
      </div>

      <div>
        <strong>HI-HAT (Subdivision + Euklidisch)</strong>
        <div class="kv"><label><input type="checkbox" id="hatEn" checked> aktiv</label></div>
        <div class="kv"><label>HP Hz</label><input id="hatHP" class="num" type="number" value="6000" min="1000" max="18000"></div>
        <div class="kv"><label>Decay ms</label><input id="hatDecay" class="num" type="number" value="70" min="5" max="1000"></div>
        <div class="kv"><label>Gain</label><input id="hatGain" class="num" type="number" value="0.45" step="0.05" min="0" max="2"></div>
        <div class="kv"><label>Subdivision N</label><input id="hatSub" class="num" type="number" value="3" min="2" max="16"></div>
        <div class="kv"><label>Pattern E(k,S,R)</label>
          <input id="hatSteps" class="num" type="number" value="12" min="1" max="64">
          <input id="hatFill"  class="num" type="number" value="8"  min="0" max="64">
          <input id="hatRot"   class="num" type="number" value="0"  min="0" max="64">
        </div>
      </div>

      <div>
        <strong>BASS (polyBLEP-fähig)</strong>
        <div class="kv"><label><input type="checkbox" id="bassEn" checked> aktiv</label></div>
        <div class="kv"><label>Wave</label>
          <select id="bassWave">
            <option value="sine">Sine</option>
            <option value="tri">Tri</option>
            <option value="saw">Saw (polyBLEP)</option>
            <option value="square" selected>Square (polyBLEP)</option>
          </select>
        </div>
        <div class="kv"><label>Freq Hz</label><input id="bassFreq" class="num" type="number" value="55" min="20" max="400"></div>
        <div class="kv"><label>Gain</label><input id="bassGain" class="num" type="number" value="0.5" step="0.05" min="0" max="2"></div>
        <div class="kv"><label>Gate % Beat</label><input id="bassGate" class="num" type="number" value="50" min="1" max="100"></div>
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="row">
      <strong>Visualisierung</strong>
      <div class="spacer"></div>
      <button id="exportCfg">Export JSON</button>
      <button id="importCfg">Import JSON</button>
      <input id="importFile" type="file" accept="application/json" style="display:none">
    </div>
    <canvas id="scope"></canvas>
    <p class="small">Hinweis: Visualisierung ist CPU-leicht (kein Audio-Tap). Physik/Takt/Trigger passieren ausschließlich in der Engine.</p>
  </div>

  <!-- AUDIO WORKLET CODE (als Text, wird per Blob in Worklet geladen) -->
  <script id="worklet" type="text/plain">
class PhysEngine extends AudioWorkletProcessor {
  static get parameterDescriptors(){return[]}

  constructor(options){
    super();
    this.sr = sampleRate>>>0; this.n=0; this.playing=true;
    this._bpm=120; this.setBPM(options?.processorOptions?.bpm??120);
    this.seed=(options?.processorOptions?.seed|0)||0x9e3779b9;
    this._rnd=()=>{let x=this.seed|0; x^=x<<13; x^=x>>>17; x^=x<<5; this.seed=x|0; return ((x>>>0)/0xFFFFFFFF)*2-1};

    this.dc_x1=0; this.dc_y1=0; this.dc_R=0.995;

    this.euclid=(k,S,i,r=0)=>{ if(S<=0)return false; const j=(i+r)%S; return (j*k)%S<k };

    this.cfg={
      kick:{en:true,f0:55,sweep:90,decayMs:140,gain:0.9,steps:16,fill:4,rot:0},
      snare:{en:true,noise:0.7,hp:900,decayMs:220,gain:0.7,steps:16,fill:2,rot:8},
      hat:{en:true,hp:6000,decayMs:70,gain:0.45,sub:3,steps:12,fill:8,rot:0},
      bass:{en:true,wave:"square",freq:55,gain:0.5,gatePct:50}
    };
    this.st={
      kick:{env:0,tLoc:0,lastStep:-1},
      snare:{env:0,tLoc:0,lastStep:-1,hpx1:0,hpy1:0},
      hat:{env:0,tLoc:0,lastStep:-1,hpx1:0,hpy1:0},
      bass:{phase:0}
    };
    this._coef={}; this._refresh();
    this.q=[]; this.port.onmessage=e=>this.q.push(e.data);
  }

  setBPM(b){ b=Math.max(20,Math.min(300,b|0)); this._bpm=b; this.spb=this.sr*60/b; this.spbar=this.spb*4; this.port.postMessage({t:"bpm",bpm:b}) }
  phase(){ const x=this.n/this.spb; return x-Math.floor(x) }
  _d(ms){ const tau=ms/1000; return Math.exp(-1/(tau*this.sr)) }
  _hp(fc){ const dt=1/this.sr; const rc=1/(2*Math.PI*Math.max(10,fc)); return rc/(rc+dt) }
  _refresh(){ const c=this._coef, cf=this.cfg; c.kA=this._d(cf.kick.decayMs); c.sA=this._d(cf.snare.decayMs); c.hA=this._d(cf.hat.decayMs); c.sHP=this._hp(cf.snare.hp); c.hHP=this._hp(cf.hat.hp) }

  _polyblep(t,dt){ if(t<dt){const x=t/dt; return x+x-x*x-1} else if(t>1-dt){const x=(t-1)/dt; return x*x+x+x+1} return 0 }
  _saw(phase,f){ const t=phase%1,dt=f/this.sr; let y=2*t-1; y-=this._polyblep(t,dt); return y }
  _square(phase,f){ const t=phase%1,dt=f/this.sr; let y=t<.5?1:-1; y+=this._polyblep(t,dt)-this._polyblep((t+.5)%1,dt); return y }

  _apply(){
    if(!this.q.length) return;
    for(const m of this.q){
      switch(m?.t){
        case "start": this.playing=true; this.n=0; break;
        case "stop":  this.playing=false; break;
        case "seed":  this.seed=m.seed|0; break;
        case "bpm":   this.setBPM(m.bpm); break;
        case "cfg":   if(this.cfg[m.inst] && m.key in this.cfg[m.inst]){ this.cfg[m.inst][m.key]=m.val; this._refresh() } break;
        case "toggle": if(this.cfg[m.inst]) this.cfg[m.inst].en=!!m.en; break;
      }
    }
    this.q.length=0;
  }

  process(inputs,outputs){
    const out=outputs[0]; if(!out||!out[0]) return true;
    this._apply();
    const L=out[0],R=out[1]??out[0], cf=this.cfg, st=this.st, c=this._coef;

    const kStepLen=this.spbar/Math.max(1,cf.kick.steps);
    const sStepLen=this.spbar/Math.max(1,cf.snare.steps);
    const hStepLen=this.spbar/Math.max(1,cf.hat.steps);

    for(let i=0;i<L.length;i++){
      if(!this.playing){ L[i]=R[i]=0; this.n++; continue; }
      const phi=this.phase(); let sum=0;

      if(cf.kick.en){
        const sidx=Math.floor((this.n%this.spbar)/kStepLen);
        if(this.euclid(Math.max(0,cf.kick.fill|0),Math.max(1,cf.kick.steps|0),sidx,cf.kick.rot|0) && sidx!==st.kick.lastStep){ st.kick.lastStep=sidx; st.kick.env=1; st.kick.tLoc=0 }
        const f=Math.max(20, cf.kick.f0 + cf.kick.sweep*Math.exp(-8*st.kick.tLoc));
        sum += Math.sin(2*Math.PI*f*st.kick.tLoc) * st.kick.env * cf.kick.gain;
        st.kick.env*=c.kA; st.kick.tLoc += 1/this.sr;
      }

      if(cf.snare.en){
        const sidx=Math.floor((this.n%this.spbar)/sStepLen);
        if(this.euclid(Math.max(0,cf.snare.fill|0),Math.max(1,cf.snare.steps|0),sidx,cf.snare.rot|0) && sidx!==st.snare.lastStep){ st.snare.lastStep=sidx; st.snare.env=1; st.snare.tLoc=0 }
        let x=this._rnd()*cf.snare.noise;
        const y=c.sHP*(st.snare.hpy1 + x - st.snare.hpx1); st.snare.hpx1=x; st.snare.hpy1=y;
        sum += y*st.snare.env*cf.snare.gain; st.snare.env*=c.sA; st.snare.tLoc+=1/this.sr;
      }

      if(cf.hat.en){
        const N=Math.max(2,cf.hat.sub|0); const subLen=this.spb/N; const subIdx=Math.floor(this.n/subLen);
        if(subIdx!==st.hat.lastStep){ st.hat.lastStep=subIdx; st.hat.env=1; st.hat.tLoc=0 }
        const sidx=Math.floor((this.n%this.spbar)/hStepLen);
        const gate=this.euclid(Math.max(0,cf.hat.fill|0),Math.max(1,cf.hat.steps|0),sidx,cf.hat.rot|0)?1:0;
        let nx=this._rnd(); const yh=c.hHP*(st.hat.hpy1 + nx - st.hat.hpx1); st.hat.hpx1=nx; st.hat.hpy1=yh;
        sum += yh*st.hat.env*cf.hat.gain*gate; st.hat.env*=c.hA; st.hat.tLoc+=1/this.sr;
      }

      if(cf.bass.en){
        const gate = (phi < (cf.bass.gatePct/100)) ? 1:0;
        st.bass.phase += cf.bass.freq/this.sr;
        let osc; switch(cf.bass.wave){
          case "saw":    osc=this._saw(st.bass.phase, cf.bass.freq); break;
          case "square": osc=this._square(st.bass.phase, cf.bass.freq); break;
          case "tri":    { const x=2*Math.abs(2*(st.bass.phase%1)-1)-1; osc=x; break; }
          default:       osc=Math.sin(2*Math.PI*(st.bass.phase%1));
        }
        sum += osc*cf.bass.gain*gate;
      }

      const x=sum; const y=x - this.dc_x1 + this.dc_R*this.dc_y1; this.dc_x1=x; this.dc_y1=y;
      const outv=Math.tanh(y*1.2); L[i]=outv; R[i]=outv; this.n++;
    }
    return true;
  }
}
registerProcessor("phys-engine", PhysEngine);
  </script>

  <!-- MAIN/UI + FALLBACK-DSP (ScriptProcessorNode) -->
  <script type="module">
    const $ = id => document.getElementById(id);
    const led = s => { const el=$("led"); el.className="led "+s };

    // === Shared DSP (Fallback-Klasse, identisch zur Worklet-Logik) ===
    class PhysEngineDSP {
      constructor({sr=48000,bpm=120,seed=0x9e3779b9}={}){
        this.sr=sr>>>0; this.n=0; this.playing=true; this._bpm=120; this.setBPM(bpm);
        this.seed=seed|0; this._rnd=()=>{let x=this.seed|0;x^=x<<13;x^=x>>>17;x^=x<<5;this.seed=x|0;return ((x>>>0)/0xFFFFFFFF)*2-1};
        this.dc_x1=0; this.dc_y1=0; this.dc_R=0.995;
        this.euclid=(k,S,i,r=0)=>{ if(S<=0)return false; const j=(i+r)%S; return (j*k)%S<k };
        this.cfg={
          kick:{en:true,f0:55,sweep:90,decayMs:140,gain:0.9,steps:16,fill:4,rot:0},
          snare:{en:true,noise:0.7,hp:900,decayMs:220,gain:0.7,steps:16,fill:2,rot:8},
          hat:{en:true,hp:6000,decayMs:70,gain:0.45,sub:3,steps:12,fill:8,rot:0},
          bass:{en:true,wave:"square",freq:55,gain:0.5,gatePct:50}
        };
        this.st={kick:{env:0,tLoc:0,lastStep:-1},snare:{env:0,tLoc:0,lastStep:-1,hpx1:0,hpy1:0},hat:{env:0,tLoc:0,lastStep:-1,hpx1:0,hpy1:0},bass:{phase:0}};
        this._coef={}; this._refresh();
      }
      setBPM(b){ b=Math.max(20,Math.min(300,b|0)); this._bpm=b; this.spb=this.sr*60/b; this.spbar=this.spb*4 }
      phase(){ const x=this.n/this.spb; return x-Math.floor(x) }
      _d(ms){ const tau=ms/1000; return Math.exp(-1/(tau*this.sr)) }
      _hp(fc){ const dt=1/this.sr; const rc=1/(2*Math.PI*Math.max(10,fc)); return rc/(rc+dt) }
      _refresh(){ const c=this._coef, cf=this.cfg; c.kA=this._d(cf.kick.decayMs); c.sA=this._d(cf.snare.decayMs); c.hA=this._d(cf.hat.decayMs); c.sHP=this._hp(cf.snare.hp); c.hHP=this._hp(cf.hat.hp) }
      _polyblep(t,dt){ if(t<dt){const x=t/dt; return x+x-x*x-1} else if(t>1-dt){const x=(t-1)/dt; return x*x+x+x+1} return 0 }
      _saw(phase,f){ const t=phase%1,dt=f/this.sr; let y=2*t-1; y-=this._polyblep(t,dt); return y }
      _square(phase,f){ const t=phase%1,dt=f/this.sr; let y=t<.5?1:-1; y+=this._polyblep(t,dt)-this._polyblep((t+.5)%1,dt); return y }
      toggle(inst,en){ if(this.cfg[inst]!=null) this.cfg[inst].en=!!en }
      set(inst,key,val){ if(this.cfg[inst]!=null && key in this.cfg[inst]){ this.cfg[inst][key]=val; this._refresh() } }
      reseed(seed){ this.seed=seed|0 }
      start(){ this.playing=true; this.n=0 }
      stop(){ this.playing=false }
      processBlock(L,R){
        const cf=this.cfg,st=this.st,c=this._coef;
        const frames=L.length;
        const kStepLen=this.spbar/Math.max(1,cf.kick.steps);
        const sStepLen=this.spbar/Math.max(1,cf.snare.steps);
        const hStepLen=this.spbar/Math.max(1,cf.hat.steps);
        for(let i=0;i<frames;i++){
          if(!this.playing){ L[i]=R[i]=0; this.n++; continue; }
          const phi=this.phase(); let sum=0;

          if(cf.kick.en){
            const sidx=Math.floor((this.n%this.spbar)/kStepLen);
            if(this.euclid(Math.max(0,cf.kick.fill|0),Math.max(1,cf.kick.steps|0),sidx,cf.kick.rot|0) && sidx!==st.kick.lastStep){ st.kick.lastStep=sidx; st.kick.env=1; st.kick.tLoc=0 }
            const f=Math.max(20, cf.kick.f0 + cf.kick.sweep*Math.exp(-8*st.kick.tLoc));
            sum += Math.sin(2*Math.PI*f*st.kick.tLoc) * st.kick.env * cf.kick.gain;
            st.kick.env*=c.kA; st.kick.tLoc += 1/this.sr;
          }

          if(cf.snare.en){
            const sidx=Math.floor((this.n%this.spbar)/sStepLen);
            if(this.euclid(Math.max(0,cf.snare.fill|0),Math.max(1,cf.snare.steps|0),sidx,cf.snare.rot|0) && sidx!==st.snare.lastStep){ st.snare.lastStep=sidx; st.snare.env=1; st.snare.tLoc=0 }
            let x=this._rnd()*cf.snare.noise; const y=c.sHP*(st.snare.hpy1 + x - st.snare.hpx1); st.snare.hpx1=x; st.snare.hpy1=y;
            sum += y*st.snare.env*cf.snare.gain; st.snare.env*=c.sA; st.snare.tLoc+=1/this.sr;
          }

          if(cf.hat.en){
            const N=Math.max(2,cf.hat.sub|0); const subLen=this.spb/N; const subIdx=Math.floor(this.n/subLen);
            if(subIdx!==st.hat.lastStep){ st.hat.lastStep=subIdx; st.hat.env=1; st.hat.tLoc=0 }
            const sidx=Math.floor((this.n%this.spbar)/hStepLen);
            const gate=this.euclid(Math.max(0,cf.hat.fill|0),Math.max(1,cf.hat.steps|0),sidx,cf.hat.rot|0)?1:0;
            let nx=this._rnd(); const yh=c.hHP*(st.hat.hpy1 + nx - st.hat.hpx1); st.hat.hpx1=nx; st.hat.hpy1=yh;
            sum += yh*st.hat.env*cf.hat.gain*gate; st.hat.env*=c.hA; st.hat.tLoc+=1/this.sr;
          }

          if(cf.bass.en){
            const gate = (phi < (cf.bass.gatePct/100)) ? 1:0;
            st.bass.phase += cf.bass.freq/this.sr; let osc;
            switch(cf.bass.wave){
              case "saw":    osc=this._saw(st.bass.phase, cf.bass.freq); break;
              case "square": osc=this._square(st.bass.phase, cf.bass.freq); break;
              case "tri":    { const x=2*Math.abs(2*(st.bass.phase%1)-1)-1; osc=x; break; }
              default:       osc=Math.sin(2*Math.PI*(st.bass.phase%1));
            }
            sum += osc*cf.bass.gain*gate;
          }

          const x=sum; const y=x - this.dc_x1 + this.dc_R*this.dc_y1; this.dc_x1=x; this.dc_y1=y;
          const outv=Math.tanh(y*1.2); L[i]=outv; R[i]=outv; this.n++;
        }
      }
    }

    // === Boot: Worklet versuchen, sonst Fallback ===
    let ac=null, node=null, spn=null, engineDSP=null, useWorklet=false, scopeRAF=null;

    async function boot(){
      if(ac) return;
      ac = new (window.AudioContext||window.webkitAudioContext)({ sampleRate:48000 });

      try {
        const code = document.getElementById("worklet").textContent;
        const blob = new Blob([code], {type:"application/javascript"});
        const url  = URL.createObjectURL(blob);
        await ac.audioWorklet.addModule(url);
        URL.revokeObjectURL(url);

        node = new AudioWorkletNode(ac,"phys-engine",{
          processorOptions:{
            bpm: parseInt($("bpm").value,10),
            seed: parseInt($("seed").value,10)
          }
        });
        node.connect(ac.destination);
        node.port.onmessage = ()=>{};
        useWorklet = true;
        led("ok");
      } catch (e) {
        // Fallback: ScriptProcessorNode
        engineDSP = new PhysEngineDSP({ sr: ac.sampleRate, bpm: parseInt($("bpm").value,10), seed: parseInt($("seed").value,10) });
        spn = ac.createScriptProcessor(1024, 0, 2);
        spn.onaudioprocess = ev=>{
          const L = ev.outputBuffer.getChannelData(0);
          const R = ev.outputBuffer.getChannelData(1);
          engineDSP.processBlock(L,R);
        };
        spn.connect(ac.destination);
        useWorklet = false;
        led("warn");
      }
    }

    // === Messaging / Control (Worklet vs Fallback) ===
    const post = (t,p={})=>{
      if(useWorklet) node?.port.postMessage({t,...p});
      else {
        switch(t){
          case "start": engineDSP?.start(); break;
          case "stop":  engineDSP?.stop(); break;
          case "seed":  engineDSP?.reseed(p.seed|0); break;
          case "bpm":   engineDSP?.setBPM(p.bpm|0); break;
          case "cfg":   engineDSP?.set(p.inst,p.key,p.val); break;
          case "toggle":engineDSP?.toggle(p.inst, !!p.en); break;
        }
      }
    };

    // === UI Bindings ===
    function bind(){
      const bindToggle = (id,inst)=> $(id).addEventListener("change", e=> post("toggle",{inst,en:e.target.checked}));
      const bindSet = (id,inst,key,coerce=v=>v)=> $(id).addEventListener("input", e=> post("cfg",{inst,key,val:coerce(e.target.value)}));

      $("start").addEventListener("click", async ()=>{ await boot(); await ac.resume(); post("start") });
      $("stop").addEventListener("click", async ()=>{ if(!ac) return; await ac.suspend(); post("stop"); led("off") });
      $("reseat").addEventListener("click", ()=> post("seed",{seed: parseInt($("seed").value,10)}));
      $("bpmUp").addEventListener("click", ()=>{ $("bpm").value = Math.min(300, parseInt($("bpm").value,10)+5); post("bpm",{bpm: parseInt($("bpm").value,10)}) });
      $("bpmDown").addEventListener("click", ()=>{ $("bpm").value = Math.max(20, parseInt($("bpm").value,10)-5); post("bpm",{bpm: parseInt($("bpm").value,10)}) });
      $("bpm").addEventListener("change", ()=> post("bpm",{bpm: parseInt($("bpm").value,10)}));

      bindToggle("kickEn","kick");
      bindSet("kickF0","kick","f0",v=>+v);
      bindSet("kickSweep","kick","sweep",v=>+v);
      bindSet("kickDecay","kick","decayMs",v=>+v);
      bindSet("kickGain","kick","gain",v=>+v);
      bindSet("kickSteps","kick","steps",v=>parseInt(v,10));
      bindSet("kickFill","kick","fill",v=>parseInt(v,10));
      bindSet("kickRot","kick","rot",v=>parseInt(v,10));

      bindToggle("snareEn","snare");
      bindSet("snareNoise","snare","noise",v=>+v);
      bindSet("snareHP","snare","hp",v=>+v);
      bindSet("snareDecay","snare","decayMs",v=>+v);
      bindSet("snareGain","snare","gain",v=>+v);
      bindSet("snareSteps","snare","steps",v=>parseInt(v,10));
      bindSet("snareFill","snare","fill",v=>parseInt(v,10));
      bindSet("snareRot","snare","rot",v=>parseInt(v,10));

      bindToggle("hatEn","hat");
      bindSet("hatHP","hat","hp",v=>+v);
      bindSet("hatDecay","hat","decayMs",v=>+v);
      bindSet("hatGain","hat","gain",v=>+v);
      bindSet("hatSub","hat","sub",v=>parseInt(v,10));
      bindSet("hatSteps","hat","steps",v=>parseInt(v,10));
      bindSet("hatFill","hat","fill",v=>parseInt(v,10));
      bindSet("hatRot","hat","rot",v=>parseInt(v,10));

      bindToggle("bassEn","bass");
      bindSet("bassWave","bass","wave",v=>v);
      bindSet("bassFreq","bass","freq",v=>+v);
      bindSet("bassGain","bass","gain",v=>+v);
      bindSet("bassGate","bass","gatePct",v=>+v);

      // Export / Import
      $("exportCfg").addEventListener("click", ()=>{
        const cfg = {
          bpm: parseInt($("bpm").value,10),
          seed: parseInt($("seed").value,10),
          kick:{en:$("kickEn").checked,f0:+$("kickF0").value,sweep:+$("kickSweep").value,decayMs:+$("kickDecay").value,gain:+$("kickGain").value,steps:+$("kickSteps").value,fill:+$("kickFill").value,rot:+$("kickRot").value},
          snare:{en:$("snareEn").checked,noise:+$("snareNoise").value,hp:+$("snareHP").value,decayMs:+$("snareDecay").value,gain:+$("snareGain").value,steps:+$("snareSteps").value,fill:+$("snareFill").value,rot:+$("snareRot").value},
          hat:{en:$("hatEn").checked,hp:+$("hatHP").value,decayMs:+$("hatDecay").value,gain:+$("hatGain").value,sub:+$("hatSub").value,steps:+$("hatSteps").value,fill:+$("hatFill").value,rot:+$("hatRot").value},
          bass:{en:$("bassEn").checked,wave:$("bassWave").value,freq:+$("bassFreq").value,gain:+$("bassGain").value,gatePct:+$("bassGate").value}
        };
        const blob = new Blob([JSON.stringify(cfg,null,2)],{type:"application/json"});
        const a = document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="dawx-config.json"; a.click(); URL.revokeObjectURL(a.href);
      });

      $("importCfg").addEventListener("click", ()=> $("importFile").click());
      $("importFile").addEventListener("change", async e=>{
        const f=e.target.files?.[0]; if(!f) return;
        const cfg = JSON.parse(await f.text());
        const set = (id,val)=>{ const el=$(id); if(el!=null){ if(el.type==="checkbox") el.checked=!!val; else el.value=val } };
        set("bpm",cfg.bpm??$("bpm").value); post("bpm",{bpm: parseInt($("bpm").value,10)});
        set("seed",cfg.seed??$("seed").value); post("seed",{seed: parseInt($("seed").value,10)});
        // Kick
        set("kickEn",cfg.kick?.en); set("kickF0",cfg.kick?.f0); set("kickSweep",cfg.kick?.sweep);
        set("kickDecay",cfg.kick?.decayMs); set("kickGain",cfg.kick?.gain);
        set("kickSteps",cfg.kick?.steps); set("kickFill",cfg.kick?.fill); set("kickRot",cfg.kick?.rot);
        // Snare
        set("snareEn",cfg.snare?.en); set("snareNoise",cfg.snare?.noise); set("snareHP",cfg.snare?.hp);
        set("snareDecay",cfg.snare?.decayMs); set("snareGain",cfg.snare?.gain);
        set("snareSteps",cfg.snare?.steps); set("snareFill",cfg.snare?.fill); set("snareRot",cfg.snare?.rot);
        // Hat
        set("hatEn",cfg.hat?.en); set("hatHP",cfg.hat?.hp); set("hatDecay",cfg.hat?.decayMs);
        set("hatGain",cfg.hat?.gain); set("hatSub",cfg.hat?.sub);
        set("hatSteps",cfg.hat?.steps); set("hatFill",cfg.hat?.fill); set("hatRot",cfg.hat?.rot);
        // Bass
        set("bassEn",cfg.bass?.en); $("bassWave").value = cfg.bass?.wave ?? $("bassWave").value;
        set("bassFreq",cfg.bass?.freq); set("bassGain",cfg.bass?.gain); set("bassGate",cfg.bass?.gatePct);
        // Events auslösen, damit Engine alle Werte bekommt
        document.querySelectorAll("input,select").forEach(el=>el.dispatchEvent(new Event(el.type==="checkbox"?"change":"input")));
      });
    }

    // === Visualisierung (leichtgewichtig) ===
    function scope(){
      const cvs=$("scope"), c=cvs.getContext("2d"); let w=0,h=0;
      const fit=()=>{ w=cvs.width=cvs.clientWidth; h=cvs.height=72 }; new ResizeObserver(fit).observe(cvs); fit();
      let p=0, t=0;
      const draw=()=>{
        c.fillStyle="#0b0f16"; c.fillRect(0,0,w,h);
        const bpm=parseInt($("bpm").value,10); const beatDur=60/bpm; t+=1/60; p=(p+(1/60)/beatDur)%1;
        c.fillStyle="#223047"; c.fillRect(0,0,w,12); c.fillStyle="#4cc9f0"; c.fillRect(0,0,Math.floor(w*p),12);
        c.strokeStyle="#cfe5ff"; c.lineWidth=1; c.beginPath();
        for(let x=0;x<w;x++){
          const u=x/w;
          const y=0.25*Math.sin(2*Math.PI*(4*u+p)) + 0.15*Math.sin(2*Math.PI*(u+2*p));
          const Y=12 + (h-18)*(0.5 - y*0.45);
          if(x===0) c.moveTo(x,Y); else c.lineTo(x,Y);
        }
        c.stroke();
        scopeRAF=requestAnimationFrame(draw);
      };
      cancelAnimationFrame(scopeRAF); scopeRAF=requestAnimationFrame(draw);
    }

    // === Init ===
    (function init(){
      bind(); scope();
      document.addEventListener("visibilitychange", ()=>{ if(document.hidden && ac){ ac.suspend(); post("stop"); led("off") } });
    })();
  </script>
</div>
</body>
</html>
