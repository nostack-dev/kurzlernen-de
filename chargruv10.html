<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Text-BPE Atom-LLM — O(M) dilatiert (schnell) + LLM-Refiner (FINAL)</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.22.0/dist/tf-backend-webgl.min.js"></script>
  <style>
    body{background:#f5f6f8;color:#1f2937;font-family:ui-sans-serif,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .container{max-width:1100px;margin:32px auto;padding:0 16px}
    .card{background:#fff;border:1px solid #e5e7eb;border-radius:14px;box-shadow:0 1px 2px rgba(0,0,0,.04);padding:18px;margin:16px 0}
    .row{display:grid;gap:12px}
    @media(min-width:1000px){.row{grid-template-columns:1fr 1fr}}
    textarea,input,button,select{font-family:inherit}
    textarea{width:100%;min-height:80px;border:1px solid #d1d5db;border-radius:10px;padding:10px}
    input,select{width:100%;border:1px solid #d1d5db;border-radius:10px;padding:8px}
    label{font-size:12px;color:#6b7280;margin-bottom:4px;display:block}
    .btn{background:#4f46e5;border:none;color:#fff;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer}
    .btn.secondary{background:#059669}
    .btn.grey{background:#6b7280}
    .btn.warn{background:#f59e0b}
    .btn.red{background:#ef4444}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .log{height:220px;overflow:auto;background:#0b1020;color:#d1d5db;border-radius:10px;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace;word-break:break-word;white-space:pre-wrap}
    .muted{color:#6b7280}
    .spinner{border:4px solid rgba(0,0,0,.1);border-left-color:#4f46e5;border-radius:50%;width:20px;height:20px;animation:spin .8s linear infinite;display:inline-block}
    .kpi{display:flex;gap:10px;flex-wrap:wrap}
    .kpi div{background:#f9fafb;border:1px solid #e5e7eb;border-radius:10px;padding:8px 10px}
    .row4{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
    .mb-1{margin-bottom:0.25rem}.mb-2{margin-bottom:0.5rem}.mb-4{margin-bottom:1rem}
    .mt-2{margin-top:0.5rem}.mt-3{margin-top:0.75rem}
    .flex{display:flex}.items-end{align-items:flex-end}.items-center{align-items:center}
    .gap-3{gap:0.75rem}
    .text-2xl{font-size:1.5rem;line-height:2rem}.text-lg{font-size:1.125rem;line-height:1.75rem}
    .font-bold{font-weight:700}.font-extrabold{font-weight:800}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>
<body>
<div class="container">
  <h1 class="text-2xl font-extrabold mb-1">Text-BPE Atom-LLM — O(M) dilatiert (schnell) + LLM-Refiner</h1>
  <div class="muted mb-4">
    Presets: <b>M=64</b>, <b>L=5</b>, <b>K=5</b> (dilat. emuliert, RF≥M), <b>d=192</b>, <b>dFF=640</b>, <b>B=16</b>, <b>LR=0.001</b>, <b>Heads=4</b>, <b>λ=0.5</b> (ab Ep. 2).
  </div>

  <div class="card">
    <h3 class="font-bold text-lg mb-2">1) Korpus laden &amp; BPE-Tokenizer</h3>
    <div class="row">
      <div>
        <label for="corpusFiles" class="btn grey" style="cursor:pointer;display:inline-block;margin-bottom:10px;">Korpus-Datei(en) (.txt, .jsonl)</label>
        <input type="file" id="corpusFiles" multiple accept=".txt,.jsonl" style="display:none;">
        <div id="fileInfo" class="muted mb-2">Keine Korpus-Dateien ausgewählt.</div>
      </div>
      <div>
        <label>JSONL Text-Schlüssel</label>
        <input id="jsonlKey" type="text" value="text">
      </div>
    </div>
    <textarea id="txt" placeholder="ODER kurz Text einfügen"></textarea>
    <div class="row" style="margin-top:10px">
      <div>
        <label>Atom-Vokabular</label>
        <input id="atomVocab" type="number" min="64" max="4096" step="32" value="512">
      </div>
      <div>
        <label>Max. Kontext M</label>
        <input id="seqLen" type="number" min="32" max="1024" step="32" value="64">
      </div>
    </div>
    <div class="row" style="margin-top:10px">
      <div class="flex items-center gap-3">
        <button id="btnBuildBPE" class="btn warn">1. Atome lernen (BPE auf Text)</button>
      </div>
      <div class="flex items-center gap-3">
        <button id="btnClear" class="btn red">Alles zurücksetzen</button>
        <button id="btnDbgDump" class="btn">Debug Dump</button>
      </div>
    </div>
    <div class="kpi mt-3">
      <div id="kpiChars" class="muted">Textzeichen: –</div>
      <div id="kpiAtoms" class="muted">Atome: –</div>
      <div id="kpiComp" class="muted">Kompression: –</div>
    </div>
  </div>

  <div class="card">
    <h3 class="font-bold text-lg mb-2">2) Lineares Modell (dilatiert) &amp; Training</h3>
    <div class="row4">
      <div><label>Schichten L</label><input id="nLayers" type="number" min="1" max="16" value="5"></div>
      <div><label>d_model</label><input id="dModel" type="number" min="64" max="1024" step="32" value="192"></div>
      <div><label>FFN-Dim</label><input id="dFF" type="number" min="128" max="4096" step="64" value="640"></div>
      <div><label>Epochen</label><input id="epochs" type="number" min="1" max="80" value="6"></div>
    </div>
    <div class="row4 mt-3">
      <div><label>LR (Adam)</label><input id="lr" type="number" min="0.00002" max="0.02" step="0.00002" value="0.001"></div>
      <div><label>Batchgröße</label><input id="batch" type="number" min="8" max="256" step="8" value="16"></div>
      <div><label>Steps/Epoche (0=auto)</label><input id="stepCap" type="number" min="0" max="100000" step="50" value="400"></div>
      <div class="flex items-end gap-3">
        <label class="muted"><input id="useGPU" type="checkbox" checked> WebGL</label>
        <label class="muted"><input id="useDropout" type="checkbox"> Dropout 0.1</label>
        <label class="muted"><input id="autoLR" type="checkbox" checked> Auto-LR (auf RefCE)</label>
      </div>
    </div>
    <div class="row4 mt-3">
      <div><label>LLM-Refiner λ</label><input id="attLambda" type="number" min="0.0" max="1.0" step="0.05" value="0.5"></div>
      <div><label>Refiner Köpfe</label><input id="attHeads" type="number" min="1" max="16" step="1" value="4"></div>
      <div><label>Kernel-Größe K</label><input id="kernel" type="number" min="3" max="15" step="2" value="5"></div>
      <div class="flex items-end gap-3">
        <label class="muted"><input id="maskPadRef" type="checkbox" checked> Pad-Maske im Refiner</label>
        <label class="muted"><input id="attWarmup" type="number" min="0" max="5" step="1" value="1"> &nbsp;Warmup-Epochen</label>
      </div>
    </div>
    <div class="flex items-center gap-3 mt-3">
      <button id="btnTrain" class="btn" disabled>
        <span id="trainText">2. Training starten</span>
        <span id="spin" class="spinner" style="display:none;margin-left:8px;"></span>
      </button>
      <button id="btnStop" class="btn red" disabled>Stop</button>
      <button id="btnExport" class="btn warn" disabled>Modell exportieren (JSON)</button>
      <label class="btn secondary" for="fileImport" style="cursor:pointer">Modell importieren (JSON)</label>
      <input id="fileImport" type="file" accept="application/json" style="display:none">
      <div id="stats" class="muted">V=– • M=– • B=– • L=– • d=– • dFF=– • K=– • RF=– • Steps/Ep=–</div>
    </div>
  </div>

  <div class="card">
    <h3 class="font-bold text-lg mb-2">3) Inferenz (Text-BPE)</h3>
    <textarea id="prompt" placeholder="Prompt … (Enter=Send, Shift+Enter=Zeilenumbruch)" disabled></textarea>
    <div class="row">
      <div><label>Sampling-Modus</label>
        <select id="sampleMode">
          <option value="topp" selected>Top-p</option>
          <option value="topk">Top-k</option>
        </select>
      </div>
      <div><label>Top-k</label><input id="topK" type="number" min="1" max="200" value="64" disabled></div>
      <div><label>Top-p</label><input id="topP" type="number" min="0.05" max="1.0" step="0.05" value="0.9"></div>
      <div><label>Temperatur</label><input id="temp" type="number" min="0.1" max="2.0" step="0.1" value="0.9"></div>
    </div>
    <div class="row mt-2">
      <div><label>Tokens generieren</label><input id="nGen" type="number" min="1" max="4000" value="200"></div>
      <div class="flex items-end gap-3">
        <label class="muted"><input id="useAttnInfer" type="checkbox" checked> LLM-Refiner bei Inferenz</label>
        <button id="btnGen" class="btn secondary" disabled>Generieren</button>
        <button id="btnStopGen" class="btn red" disabled>Stop</button>
        <div id="inferStats" class="muted">Tokens: 0 • Latenz 0.0 ms</div>
      </div>
    </div>
    <div class="mt-3">
      <div class="muted mb-1">Ausgabe (Text)</div>
      <div id="outText" class="mono" style="white-space:pre-wrap;background:#fff;border:1px solid #c5d7f8;border-radius:10px;padding:10px;min-height:80px;font-size:1.1em;line-height:1.6"></div>
    </div>
  </div>

  <div class="card">
    <h3 class="font-bold text-lg mb-2">Perplexity &amp; Log</h3>
    <div id="metrics" class="muted mb-2"><b>Epoche –/–</b> &nbsp; Loss=– &nbsp; Val PPL(conv)=– &nbsp; RefCE=– &nbsp; ~Tok/s=– &nbsp; LR=–</div>
    <div id="log" class="log">[Log bereit. O(M)-Training (dilatierte Convs emuliert) aktiv. LLM-Refiner warmup → voll.]</div>
  </div>
</div>

<script>
const $ = id => document.getElementById(id);
const MAX_LOG_CHARS = 120000;
const BOS_ID = 0, EOS_ID = 1;

const STATE = {
  corpusText: '',
  atomizer: null,
  tokens: null,
  model: null,
  modelRev: 0,
  cancelTrain: false,
  cancelGen: false
};

function logLine(msg){const el=$('log');const line=`[${new Date().toLocaleTimeString()}] ${msg}\n`;el.textContent=line+el.textContent;if(el.textContent.length>MAX_LOG_CHARS)el.textContent=el.textContent.slice(0,MAX_LOG_CHARS)}
function clamp(v,lo,hi){v=Number.isFinite(v)?v:lo;return Math.max(lo,Math.min(hi,v))}
function valNum(id,fallback,lo=null,hi=null){const el=$(id);let v=Number(el?.value);if(!Number.isFinite(v))v=fallback;if(lo!=null)v=Math.max(lo,v);if(hi!=null)v=Math.min(hi,v);return v}
function valBool(id,fallback=false){return $(id)?.checked??fallback}
function setButtonState(id,disabled,text,showSpinner=false){const btn=$(id);if(!btn)return;btn.disabled=!!disabled;if(id==='btnTrain'){const labelEl=btn.querySelector('#trainText');if(labelEl&&text!=null)labelEl.textContent=String(text);const spinEl=btn.querySelector('#spin');if(spinEl)spinEl.style.display=showSpinner?'inline-block':'none'}else{const span=btn.querySelector('span');if(span&&text!=null)span.textContent=String(text);else if(text!=null)btn.textContent=String(text)}}
async function microYield(){await new Promise(r=>setTimeout(r,0))}
function dbgState(tag=''){const A=STATE.atomizer;const T=STATE.tokens;logLine(`[DBG ${tag}] atomizer=${!!A} vocab=${A?.vocabSize??'–'} | tokens=${T?(T.length+' (Uint32Array='+(T instanceof Uint32Array)+')'):'null'}`)}

/* ---------- Text-BPE ---------- */
function strToCodepoints(str){const arr=[];for(let i=0;i<str.length;i++)arr.push(str.charCodeAt(i));return arr}
function codepointsToStr(arr){return String.fromCharCode(...arr)}
function buildAtomBPE(rawText, targetVocab=512){
  return new Promise(async (resolve)=>{
    logLine(`Starte BPE-Training (Text) auf ${rawText.length.toLocaleString()} Zeichen … Ziel-Vokabular: ${targetVocab}`);
    const cps=strToCodepoints(rawText);
    const uniq=Array.from(new Set(cps.filter(x=>!Number.isNaN(x)))).sort((a,b)=>a-b);
    const cp2id=new Map(), id2cp=new Map(); let nextId=2;
    for(const c of uniq){cp2id.set(c,nextId);id2cp.set(nextId,c);nextId++}
    let seq=cps.map(c=>cp2id.get(c)??BOS_ID);
    const merges=[]; const baseVocab=nextId;
    function countPairs(sequence){const m=new Map();for(let i=0;i<sequence.length-1;i++){const k=sequence[i]+','+sequence[i+1];m.set(k,(m.get(k)||0)+1)}return m}
    function apply(sequence,a,b,newId){const out=[];for(let i=0;i<sequence.length;){if(i<sequence.length-1&&sequence[i]===a&&sequence[i+1]===b){out.push(newId);i+=2}else{out.push(sequence[i]);i++}}return out}
    const target=Math.max(baseVocab+10,Math.min(targetVocab,8192));
    const totalMerges=target-baseVocab;
    for(let step=0;step<totalMerges;step++){
      if((step%32)===0){setButtonState('btnBuildBPE',true,`Lerne Atome (${step+1}/${totalMerges})…`,false);await microYield()}
      const counts=countPairs(seq); if(counts.size===0)break;
      let best=null,cnt=0; for(const[k,c]of counts){if(c>cnt){cnt=c;best=k}} if(!best)break;
      const[aStr,bStr]=best.split(',');const a=parseInt(aStr,10),b=parseInt(bStr,10);
      const id=nextId++; merges.push({a,b,id}); seq=apply(seq,a,b,id);
      if((step%200)===0)logLine(`BPE merge ${step+1}: (${a},${b}) → ${id} (count=${cnt})`);
    }
    logLine(`BPE-Training abgeschlossen. Vokabulargröße: ${nextId}`);
    function encodeTextToAtoms(str,addBos=false,addEos=false){
      const seq0=strToCodepoints(str).map(c=>cp2id.get(c));
      let tokens=seq0.filter(v=>Number.isFinite(v));
      for(const m of merges){const{a,b,id}=m;const out=[];for(let i=0;i<tokens.length;){if(i<tokens.length-1&&tokens[i]===a&&tokens[i+1]===b){out.push(id);i+=2}else{out.push(tokens[i]);i++}}tokens=out}
      if(addBos)tokens=[BOS_ID,...tokens]; if(addEos)tokens=[...tokens,EOS_ID]; return tokens;
    }
    function decodeAtomsToText(tokens){
      const id2pair=new Map(merges.map(m=>[m.id,[m.a,m.b]]));
      function expand(id){if(id===BOS_ID||id===EOS_ID)return[];if(id2cp.has(id))return[id2cp.get(id)];const pr=id2pair.get(id);if(!pr)return[];return expand(pr[0]).concat(expand(pr[1]))}
      const cpsOut=[];for(const t of tokens){if(t===BOS_ID||t===EOS_ID)continue;if(id2cp.has(t))cpsOut.push(id2cp.get(t));else cpsOut.push(...expand(t))}
      return codepointsToStr(cpsOut);
    }
    resolve({encodeTextToAtoms,decodeAtomsToText,vocabSize:nextId,merges,cp2id,id2cp});
  });
}

/* ---------- Dilations & RF ---------- */
function requiredSumD(T, K){return Math.ceil((T-1)/Math.max(1,(K-1)))}
function makeDilations(nLayers, K, T){
  const need=requiredSumD(T,K);
  const ds=[]; let sum=0; let d=1;
  for(let i=0;i<nLayers;i++){
    if(sum+d<=need){ds.push(d); sum+=d; d*=2}
    else{const rest=Math.max(1,need-sum); ds.push(rest); sum+=rest}
  }
  if(sum<need){ds[ds.length-1]+= (need-sum)}
  return ds;
}
function receptiveField(K, dilations){const sumD=dilations.reduce((a,b)=>a+b,0);return 1 + (K-1)*sumD}

/* ---------- Dilation-Emulation (Gradient-fähig in WebGL) ---------- */
function buildDilationMask(K, D){
  const Kexp = 1 + (K - 1) * D;
  const data = new Float32Array(Kexp * K);
  for (let j = 0; j < K; j++) {
    const i = j * D;
    data[i * K + j] = 1;
  }
  const mask = tf.tensor2d(data, [Kexp, K], 'float32');
  return { mask, Kexp };
}

/* ---------- Modell ---------- */
function rmsNorm(x,gamma,eps=1e-5){const meanSq=tf.mean(tf.square(x),-1,true);const xhat=tf.div(x,tf.sqrt(tf.add(meanSq,eps)));return tf.mul(xhat,gamma)}
function sinusoidalPositionalEncoding(T,d){
  const pos=tf.range(0,T,1,'float32');const half=Math.floor(d/2);
  const i2=tf.range(0,half,1,'float32');
  const div=tf.exp(tf.mul(i2,tf.scalar(-Math.log(10000.0)/(Math.max(1,half-1)))));
  const ang=tf.matMul(pos.reshape([T,1]),div.reshape([1,half]));
  const sin=tf.sin(ang),cos=tf.cos(ang);
  let pe=tf.concat([sin,cos],-1);
  if(2*half<d){const pad=tf.zeros([T,d-2*half]);pe=tf.concat([pe,pad],-1)}
  return pe;
}
function softmaxCEfromLogits(logits,targets){
  const [B,T,V]=logits.shape;
  const oneHot=tf.oneHot(targets.toInt(),V).reshape([B*T,V]);
  const logits2d=logits.reshape([B*T,V]);
  const lossPer=tf.losses.softmaxCrossEntropy(oneHot,logits2d); return tf.mean(lossPer);
}
function buildModel(cfg){
  const {V,dModel,dFF,nLayers,T,weightTying=true,dropoutTrain,CONV_KERNEL_SIZE=5,attHeads=4,dilations}=cfg;
  const E=tf.variable(tf.randomNormal([V,dModel],0,0.02,'float32'),true,'E');
  const pe=sinusoidalPositionalEncoding(T,dModel);
  const layers=[];
  const fixedTensors=[];

  for(let l=0;l<nLayers;l++){
    const dilationRate=dilations[l]||1;
    const { mask, Kexp } = buildDilationMask(CONV_KERNEL_SIZE, dilationRate);
    fixedTensors.push(mask);
    layers.push({
      l,dilationRate,Kexp,
      maskKD: mask,
      g1:tf.variable(tf.ones([dModel]),true,`L${l}_g1`),
      g2:tf.variable(tf.ones([dModel]),true,`L${l}_g2`),
      W_Conv:tf.variable(tf.randomNormal([CONV_KERNEL_SIZE,dModel,dModel],0,Math.sqrt(2/(dModel+dModel))),true,`L${l}_W_Conv`),
      W_Gate:tf.variable(tf.randomNormal([dModel,dModel],0,Math.sqrt(2/(dModel+dModel))),true,`L${l}_W_Gate`),
      b_Gate:tf.variable(tf.zeros([dModel]),true,`L${l}_b_Gate`),
      W1:tf.variable(tf.randomNormal([dModel,dFF],0,Math.sqrt(2/(dModel+dFF))),true,`L${l}_W1`),
      b1:tf.variable(tf.zeros([dFF]),true,`L${l}_b1`),
      W2:tf.variable(tf.randomNormal([dFF,dModel],0,Math.sqrt(2/(dFF+dModel))),true,`L${l}_W2`),
      b2:tf.variable(tf.zeros([dModel]),true,`L${l}_b2`)
    });
  }
  const h=(dModel%attHeads===0)?attHeads:1;
  const dHead=Math.floor(dModel/h);
  const Wq=tf.variable(tf.randomNormal([dModel,dModel],0,0.02),true,'ATT_Wq');
  const Wk=tf.variable(tf.randomNormal([dModel,dModel],0,0.02),true,'ATT_Wk');
  const Wv=tf.variable(tf.randomNormal([dModel,dModel],0,0.02),true,'ATT_Wv');
  const Wo=tf.variable(tf.randomNormal([dModel,dModel],0,0.02),true,'ATT_Wo');

  const bout=tf.variable(tf.zeros([V]),true,'bout');
  const W_out=tf.variable(tf.randomNormal([dModel,V],0,0.02,'float32'),true,'W_out');

  const params={E,layers,bout,pe,cfg:{...cfg,attHeads:h,dHead,CONV_KERNEL_SIZE},W_out,Wq,Wk,Wv,Wo,fixedTensors};

  function dropout(x,rate){
    if(!dropoutTrain||rate<=0)return x;
    const keep=1-rate;
    const m=tf.randomUniform(x.shape,'float32').greater(tf.scalar(rate)).toFloat();
    return tf.mul(x, tf.div(m, tf.scalar(keep)));
  }
  function forwardHidden(ids,training=true){
    return tf.tidy(()=>{
      const B=ids.shape[0],Tcur=ids.shape[1],dM=params.cfg.dModel;
      const emb=tf.gather(params.E, ids.flatten()).reshape([B,Tcur,dM]);
      let x=tf.add(emb, params.pe.slice([0,0],[Tcur,dM]).reshape([1,Tcur,dM]));
      if(params.cfg.dropoutTrain&&training)x=dropout(x,0.1);
      for(const L of params.layers){
        let h=rmsNorm(x,L.g1);
        const K=params.cfg.CONV_KERNEL_SIZE;
        const D=L.dilationRate;
        const Kexp=L.Kexp;

        const Wexp = tf.tidy(()=>tf.tensordot(L.maskKD, L.W_Conv, [[1],[0]]));
        const paddingAmount = Kexp - 1;
        const zeroPadding = tf.zeros([B, paddingAmount, dM]);
        const paddedH = tf.concat([zeroPadding, h], 1);
        const conv_out = tf.conv1d(paddedH, Wexp, 1, 'valid', 'NWC', 1);
        Wexp.dispose();

        const gate_proj=tf.add(tf.matMul(conv_out.reshape([-1,dM]),L.W_Gate),L.b_Gate);
        const gate=tf.sigmoid(gate_proj).reshape([B,Tcur,dM]);
        const linear_out=tf.mul(conv_out,gate);
        x=tf.add(x,(params.cfg.dropoutTrain&&training)?dropout(linear_out,0.1):linear_out);

        let h2=rmsNorm(x,L.g2);
        const mlp=tf.add(tf.matMul(h2.reshape([-1,dM]),L.W1),L.b1);
        const silu=tf.mul(mlp,tf.sigmoid(mlp));
        const mlp_out=tf.add(tf.matMul(silu,L.W2),L.b2).reshape([B,Tcur,dM]);
        x=tf.add(x,(params.cfg.dropoutTrain&&training)?dropout(mlp_out,0.1):mlp_out);
      }
      return x;
    });
  }
  function projectToVocab(x3d){
    const dM=params.cfg.dModel;
    const x_2d=x3d.reshape([-1,dM]);
    const logits_2d=params.cfg.weightTying?tf.matMul(x_2d,params.E.transpose()):tf.matMul(x_2d,params.W_out);
    const [B,T]=x3d.shape;
    return tf.add(logits_2d.reshape([B,T,params.cfg.V]), params.bout);
  }
  function forward(ids,training=true){return tf.tidy(()=>projectToVocab(forwardHidden(ids,training)))}

  function buildPadMask(ids){
    return ids.equal(tf.scalar(BOS_ID,'int32')).toFloat().reshape([ids.shape[0],1,1,ids.shape[1]]);
  }
  function attnLastLogitsFromHidden(x, ids=null, usePadMask=false){
    const B=x.shape[0],Tcur=x.shape[1],dM=params.cfg.dModel;
    const h=params.cfg.attHeads,dH=params.cfg.dHead;
    const q_in=x.slice([0,Tcur-1,0],[B,1,dM]).reshape([B,dM]);
    const k_in=x.reshape([B*Tcur,dM]); const v_in=k_in;
    const Q=tf.matMul(q_in,params.Wq).reshape([B,h,dH]);
    const K=tf.matMul(k_in,params.Wk).reshape([B,Tcur,h,dH]).transpose([0,2,1,3]);
    const V=tf.matMul(v_in,params.Wv).reshape([B,Tcur,h,dH]).transpose([0,2,1,3]);
    const Qe=Q.reshape([B,h,1,dH]);
    const KT=K.transpose([0,1,3,2]);
    let scores=tf.matMul(Qe,KT).div(tf.scalar(Math.sqrt(dH)));
    if(usePadMask && ids){const m=buildPadMask(ids); scores=tf.add(scores, tf.mul(m, tf.scalar(-1e9)))}
    const attn=tf.softmax(scores,-1);
    const ctx=tf.matMul(attn,V);
    const ctx2=ctx.transpose([0,2,1,3]).reshape([B,dM]);
    const z=tf.matMul(ctx2,params.Wo).reshape([B,1,dM]);
    const logits_1=params.cfg.weightTying?tf.matMul(z.reshape([B,dM]),params.E.transpose()):tf.matMul(z.reshape([B,dM]),params.W_out);
    return tf.add(logits_1,params.bout);
  }
  function variables(){const vs=[E,bout];for(const L of params.layers)vs.push(L.g1,L.g2,L.W_Conv,L.W_Gate,L.b_Gate,L.W1,L.b1,L.W2,L.b2);vs.push(W_out,Wq,Wk,Wv,Wo);return vs}
  function dispose(){
    for(const v of variables()) try{v.dispose()}catch(_){}
    try{pe.dispose()}catch(_){}
    for(const t of fixedTensors) try{t.dispose()}catch(_){}
  }
  return {params,forward,forwardHidden,projectToVocab,attnLastLogitsFromHidden,variables,dispose};
}

/* ---------- Backend ---------- */
async function setupBackend(preferGPU=true){
  try{logLine("Setze WebGL-Backend …");await tf.setBackend('webgl');await tf.ready();logLine(`Backend: ${tf.getBackend()}`)}
  catch(e){logLine(`WebGL nicht verfügbar (${e?.message||e}). Fallback CPU …`);await tf.setBackend('cpu');await tf.ready();logLine(`Backend: ${tf.getBackend()} (CPU)`)}
}

/* ---------- Daten ---------- */
function buildStarts(tokens,T,valPct){
  const N=tokens.length;const usable=Math.max(0,N-(T+1));
  const all_starts=[];const buf=new Uint32Array(tokens);
  logLine(`Scanne ${usable.toLocaleString()} mögliche Startpunkte…`);
  for(let i=0;i<usable;i++){if(buf[i+T]!==BOS_ID)all_starts.push(i)}
  logLine(`… ${all_starts.length.toLocaleString()} valide Startpunkte gefunden.`);
  const all=new Uint32Array(all_starts);
  const valN=Math.floor(all.length*(valPct/100));const trainN=all.length-valN;
  return {train:all.slice(0,trainN), val:all.slice(valN?trainN:all.length)};
}
function sampleBatch(starts,tokens,B,T){
  const X=new Int32Array(B*T), Y=new Int32Array(B*T);
  const n=starts.length; if(n===0){logLine("WARNUNG: sampleBatch 0 Startpunkte.");return{X:tf.tensor2d(X,[B,T],'int32'),Y:tf.tensor2d(Y,[B,T],'int32')}}
  for(let b=0;b<B;b++){const s=starts[(Math.random()*n)|0];for(let t=0;t<T;t++){X[b*T+t]=tokens[s+t];Y[b*T+t]=tokens[s+t+1]}}
  return {X:tf.tensor2d(X,[B,T],'int32'), Y:tf.tensor2d(Y,[B,T],'int32')};
}

/* ---------- Training ---------- */
async function train(){
  await setupBackend(valBool('useGPU',true));
  const textToProcess=STATE.corpusText||($('txt')?.value??'').trim();
  if(!textToProcess){logLine('Fehler: Kein Korpus.');return}
  const Tctx=valNum('seqLen',64,32,1024);
  if(!STATE.atomizer||!(STATE.tokens instanceof Uint32Array)){logLine('Fehler: Bitte zuerst BPE bauen.');return}
  if(STATE.tokens.length<(Tctx+1)){logLine(`Fehler: Tokens=${STATE.tokens.length} < T+1=${Tctx+1}.`);return}
  setButtonState('btnTrain',true,'Trainiere…',true);$('btnStop').disabled=false;STATE.cancelTrain=false;

  try{
    const epochs=valNum('epochs',6), B=valNum('batch',16); let lr=valNum('lr',0.001);
    const stepCap=valNum('stepCap',400), valSplit=10, autoLR=valBool('autoLR',true);
    const L=valNum('nLayers',5), dModel=valNum('dModel',192), dFF=valNum('dFF',640);
    const weightTying=true, dropoutTrain=valBool('useDropout',false);
    const V=STATE.atomizer.vocabSize;
    const K=valNum('kernel',5,3,15)|0;
    const attHeads=valNum('attHeads',4,1,16)|0;
    const attLambdaBase=clamp(valNum('attLambda',0.5,0,1),0,1);
    const attWarmup=valNum('attWarmup',1,0,5)|0;
    const usePadMask=valBool('maskPadRef',true);

    const dilations=makeDilations(L,K,Tctx);
    const RF=receptiveField(K,dilations);
    if(Tctx>RF){logLine(`WARNUNG: RF=${RF} < M=${Tctx}. Dilations werden angepasst.`)}
    logLine(`Dilations: [${dilations.join(', ')}], RF=${RF} für K=${K}, L=${L}`);

    if(STATE.model){STATE.model.dispose(); STATE.model=null}
    STATE.model=buildModel({V,dModel,dFF,nLayers:L,T:Tctx,weightTying,dropoutTrain,CONV_KERNEL_SIZE:K,attHeads,dilations});

    let optim=tf.train.adam(lr,0.9,0.999,1e-8);
    const {train:trainStarts, val:valStarts}=buildStarts(STATE.tokens,Tctx,valSplit);
    if(trainStarts.length===0){logLine('FEHLER: Keine Trainings-Startpunkte.');throw new Error('Keine Daten')}
    const rawSteps=Math.max(1, Math.floor(trainStarts.length/B));
    const stepsPerEpoch= stepCap>0? Math.min(stepCap,rawSteps) : rawSteps;
    $('stats').textContent=`V=${V} • M=${Tctx} • B=${B} • L=${L} • d=${dModel} • dFF=${dFF} • K=${K} • RF=${RF} • Steps/Ep=${stepsPerEpoch}`;
    logLine(`[DBG] starts: train=${trainStarts.length} val=${valStarts.length} steps/Ep=${stepsPerEpoch}`);

    let bestRefCE=Infinity, bad=0; const myModelRev=++STATE.modelRev;

    for(let ep=0; ep<epochs; ep++){
      if(myModelRev!==STATE.modelRev||STATE.cancelTrain)break;
      const lam = (ep < attWarmup) ? 0.0 : attLambdaBase;
      logLine(`Epoche ${ep+1}/${epochs} (λ=${lam.toFixed(2)}) mit LR=${lr.toFixed(6)}`);
      const t0=performance.now(); let lossAcc=0;

      for(let s=0;s<stepsPerEpoch;s++){
        if(myModelRev!==STATE.modelRev||STATE.cancelTrain)break;
        const {X,Y}=sampleBatch(trainStarts,STATE.tokens,B,Tctx);

        const gradsAndLoss = tf.tidy(()=>{
          const f = ()=>{
            const H=STATE.model.forwardHidden(X,true);
            const logits_all=STATE.model.projectToVocab(H);
            const loss_conv=softmaxCEfromLogits(logits_all,Y);
            let total=loss_conv;
            if(lam>0){
              const logits_last=STATE.model.attnLastLogitsFromHidden(H, X, usePadMask);
              const y_last=Y.slice([0,Tctx-1],[B,1]).reshape([B]);
              const ce_last=tf.losses.softmaxCrossEntropy(tf.oneHot(y_last.toInt(),V), logits_last);
              total=total.add(ce_last.mul(lam));
            }
            return total;
          };
          const {value,grads}=tf.variableGrads(f, STATE.model.variables());
          const clipped={}; for(const [name,g] of Object.entries(grads)){clipped[name]=tf.clipByValue(g,-1,1)}
          return {loss:value, grads:clipped};
        });

        const lossVal=(await gradsAndLoss.loss.data())[0];
        optim.applyGradients(gradsAndLoss.grads);
        gradsAndLoss.loss.dispose();
        for(const g of Object.values(gradsAndLoss.grads)) g.dispose();
        X.dispose(); Y.dispose();

        if(!Number.isFinite(lossVal)){logLine(`FEHLER: Loss=${lossVal}`);throw new Error('NaN/Inf')}
        lossAcc+=lossVal;
        if((s%100)===0||s===stepsPerEpoch-1)logLine(`Ep ${ep+1} Step ${s}/${stepsPerEpoch} Loss=${lossVal.toFixed(4)}`);
        if((s%200)===0){const m=tf.memory();logLine(`mem: tensors=${m.numTensors} bytes=${m.numBytes}`)}
        await tf.nextFrame();
      }
      if(myModelRev!==STATE.modelRev||STATE.cancelTrain)break;

      const t1=performance.now(); let nllSum=0,tokCount=0,refSum=0,refCnt=0;
      const evalB=Math.min(B,32);
      const evalSteps=Math.min(5, Math.max(0, Math.floor(valStarts.length/Math.max(1,evalB))));
      logLine(`Validierung (${evalSteps} Steps)…`);
      for(let es=0; es<evalSteps; es++){
        if(myModelRev!==STATE.modelRev||STATE.cancelTrain)break;
        const {X,Y}=sampleBatch(valStarts,STATE.tokens,evalB,Tctx);

        const convLossTensor=tf.tidy(()=>{const logitsConv=STATE.model.forward(X,false);return softmaxCEfromLogits(logitsConv,Y)});
        const convLoss=(await convLossTensor.data())[0]; convLossTensor.dispose();
        nllSum += convLoss*(evalB*Tctx); tokCount += (evalB*Tctx);

        if(lam>0 && (es%2===0)){
          const refLossTensor=tf.tidy(()=>{
            const H=STATE.model.forwardHidden(X,false);
            const logitsLast=STATE.model.attnLastLogitsFromHidden(H, X, usePadMask);
            const yLast=Y.slice([0,Tctx-1],[evalB,1]).reshape([evalB]);
            return tf.losses.softmaxCrossEntropy(tf.oneHot(yLast.toInt(),STATE.model.params.cfg.V), logitsLast);
          });
          const refLoss=(await refLossTensor.data())[0]; refLossTensor.dispose();
          refSum += refLoss; refCnt += 1;
        }

        X.dispose(); Y.dispose();
        await tf.nextFrame();
      }

      const valPPL=Math.exp(nllSum/Math.max(1,tokCount));
      const refCE=(refCnt>0)?(refSum/refCnt):NaN;
      const tokps=(stepsPerEpoch*B*Tctx)/Math.max(0.001,(t1-t0)/1000);
      $('metrics').innerHTML=`<b>Epoche ${ep+1}/${epochs}</b> &nbsp; Loss=${(lossAcc/stepsPerEpoch).toFixed(4)} &nbsp; Val PPL(conv)=${valPPL.toFixed(2)} &nbsp; RefCE=${Number.isNaN(refCE)?'–':refCE.toFixed(3)} &nbsp; ~Tok/s=${tokps.toFixed(0)} &nbsp; LR=${lr.toFixed(5)}`;
      logLine(`Epoche ${ep+1} FERTIG: loss=${(lossAcc/stepsPerEpoch).toFixed(4)} | ValPPL=${valPPL.toFixed(2)} | RefCE=${Number.isNaN(refCE)?'–':refCE.toFixed(3)} | ${(t1-t0).toFixed(0)}ms | ~${tokps.toFixed(0)} tok/s`);

      if(autoLR && !Number.isNaN(refCE)){
        if(refCE+1e-3<bestRefCE){bestRefCE=refCE;bad=0}
        else{bad++; if(bad>=2 && lr>1e-5){lr=Math.max(1e-5, lr*0.5); optim.setLearningRate(lr); bad=0; logLine(`Auto-LR → ${lr.toFixed(6)}`)}}
      }
      await tf.nextFrame();
    }

    logLine('Training abgeschlossen. Modell bereit zur Inferenz.');
    $('prompt').disabled=false; $('btnGen').disabled=false; $('btnExport').disabled=false;

  }catch(e){console.error(e);logLine('Fehler: '+(e?.message||e))}
  finally{setButtonState('btnTrain',false,'2. Training starten',false);$('btnStop').disabled=true;STATE.cancelTrain=false;}
}

/* ---------- Inferenz ---------- */
function sampleFromProbs(probs,mode,topK,topP){
  const order=Array.from(probs.keys()).sort((a,b)=>probs[b]-probs[a]);
  if(mode==='topk'){
    const K=Math.max(1,Math.min(topK,probs.length));
    const keep=order.slice(0,K); let s=0; for(const i of keep)s+=probs[i];
    let r=Math.random()*s; for(const i of keep){r-=probs[i]; if(r<=0)return i} return keep[keep.length-1];
  }else{
    const pth=clamp(topP,0.05,1.0); let cum=0,keep=[];
    for(const i of order){keep.push(i); cum+=probs[i]; if(cum>=pth)break}
    let s=0; for(const i of keep)s+=probs[i];
    let r=Math.random()*s; for(const i of keep){r-=probs[i]; if(r<=0)return i} return keep[keep.length-1];
  }
}
async function generate(){
  if(!STATE.model||!STATE.atomizer){logLine('Bitte zuerst Tokenizer + Modell trainieren/laden.');return}
  $('btnGen').disabled=true; $('btnStopGen').disabled=false; $('inferStats').textContent='Generiere…'; STATE.cancelGen=false;

  const mode=$('sampleMode').value, topK=valNum('topK',64), topP=valNum('topP',0.9), temp=valNum('temp',0.9);
  const nGen=valNum('nGen',200), T=STATE.model.params.cfg.T;
  const prompt=($('prompt')?.value??'').trim();
  const useAttn=valBool('useAttnInfer',true);
  const usePadMask=valBool('maskPadRef',true);
  if(!prompt){logLine('Kein Prompt.');$('btnGen').disabled=false;$('btnStopGen').disabled=true;return}

  let ctx=STATE.atomizer.encodeTextToAtoms(prompt,true,false);
  const t0=performance.now(); let outTokens=[];
  for(let step=0; step<nGen; step++){
    if(STATE.cancelGen){logLine('Generierung abgebrochen.');break}
    const slice=ctx.slice(-T); const len=slice.length, pad=T-len;
    const inpArr=(pad>0)?(new Int32Array([...Array(pad).fill(BOS_ID),...slice])):new Int32Array(slice);

    const last=(()=>{const t=tf.tidy(()=>{
      const input=tf.tensor2d(inpArr,[1,T],'int32');
      if(!useAttn){
        const logits=STATE.model.forward(input,false);
        return logits.slice([0,T-1,0],[1,1,STATE.model.params.cfg.V]).reshape([STATE.model.params.cfg.V]);
      }else{
        const H=STATE.model.forwardHidden(input,false);
        return STATE.model.attnLastLogitsFromHidden(H, input, usePadMask).reshape([STATE.model.params.cfg.V]);
      }
    }); const arr=t.dataSync(); t.dispose(); return arr;})();

    let maxv=-Infinity; for(let i=0;i<last.length;i++) if(last[i]>maxv)maxv=last[i];
    const probs=new Float32Array(last.length); let Z=0; const invT=1/clamp(temp,0.1,2.0);
    for(let i=0;i<last.length;i++){const e=Math.exp((last[i]-maxv)*invT); probs[i]=e; Z+=e}
    for(let i=0;i<probs.length;i++) probs[i]/=Z;

    const nxt=sampleFromProbs(probs,mode,topK,topP);
    if(nxt===EOS_ID)break;
    ctx.push(nxt); outTokens.push(nxt);
    if((step%8)===0)await tf.nextFrame();
  }
  const t1=performance.now();
  $('btnGen').disabled=false; $('btnStopGen').disabled=true; $('inferStats').textContent=`Tokens: ${outTokens.length} • Latenz ${(t1-t0).toFixed(1)} ms`;
  const genText=STATE.atomizer.decodeAtomsToText(outTokens);
  $('outText').textContent=genText;
  logLine(`Generiert ${outTokens.length} Atome (${(t1-t0).toFixed(0)} ms) — Inferenz: ${useAttn?'Refiner':'Conv-only'} (PadMask=${usePadMask}).`);
}

/* ---------- Export / Import ---------- */
function ab2b64(buf){const bytes=new Uint8Array(buf);let bin='';for(let i=0;i<bytes.length;i++)bin+=String.fromCharCode(bytes[i]);return btoa(bin)}
function b642ab(b64){const bin=atob(b64);const bytes=new Uint8Array(bin.length);for(let i=0;i<bin.length;i++)bytes[i]=bin.charCodeAt(i);return bytes.buffer}
function downloadBlob(filename,blob){const url=URL.createObjectURL(blob);const a=document.createElement('a');a.href=url;a.download=filename;document.body.appendChild(a);a.click();a.remove();URL.revokeObjectURL(url)}
async function exportModel(){
  if(!STATE.model||!STATE.atomizer){logLine('Export: Kein Modell/Tokenizer.');return}
  setButtonState('btnExport',true,'Exportiere …',false);
  try{
    const named={}; for(const v of STATE.model.variables()){if(!v.name)throw new Error('Variable ohne Namen.'); if(named[v.name])throw new Error('Duplikat: '+v.name); named[v.name]=v}
    const {data,specs}=await tf.io.encodeWeights(named);
    const payload={version:4,cfg:STATE.model.params.cfg,weightSpecs:specs,weightDataB64:ab2b64(data),atomizer:{merges:STATE.atomizer.merges,cp2id:Object.fromEntries(STATE.atomizer.cp2id),id2cp:Object.fromEntries(STATE.atomizer.id2cp),vocabSize:STATE.atomizer.vocabSize}};
    const blob=new Blob([JSON.stringify(payload)],{type:'application/json'});
    downloadBlob('text-bpe-atom-llm-dilated.json',blob);
    logLine(`Export abgeschlossen: ${(data.byteLength/1024/1024).toFixed(2)} MiB`);
  }catch(e){logLine('Export-Fehler: '+(e?.message||e))}
  finally{setButtonState('btnExport',false,'Modell exportieren (JSON)',false)}
}
async function importModel(file){
  if(!file){logLine('Import: Keine Datei.');return}
  const reader=new FileReader();
  reader.onload=async()=>{
    try{
      const obj=JSON.parse(reader.result);
      if(!obj.cfg||!obj.atomizer)throw new Error("Import-Datei ungültig ('cfg' oder 'atomizer' fehlt).");
      const cfg=obj.cfg;
      if(STATE.model){STATE.model.dispose(); STATE.model=null}
      logLine("Baue Modell-Architektur …");
      STATE.model=buildModel(cfg);
      const weightData=b642ab(obj.weightDataB64);
      const weightMap=await tf.io.decodeWeights(weightData,obj.weightSpecs);
      const byName={}; for(const v of STATE.model.variables())byName[v.name]=v;
      for(const [name,tensor] of Object.entries(weightMap)){
        if(byName[name]){byName[name].assign(tensor); tensor.dispose()} else {logLine(`Warnung: Gew. '${name}' nicht im Modell.`); tensor.dispose()}
      }
      logLine("Modell-Gewichte geladen.");
      STATE.atomizer={
        merges:obj.atomizer.merges,
        cp2id:new Map(Object.entries(obj.atomizer.cp2id).map(([k,v])=>[Number(k),v])),
        id2cp:new Map(Object.entries(obj.atomizer.id2cp).map(([k,v])=>[Number(k),v])),
        vocabSize:obj.atomizer.vocabSize,
        encodeTextToAtoms:function(str,addBos=false,addEos=false){
          const merges=this.merges; const cp2id=this.cp2id;
          let tokens=strToCodepoints(str).map(c=>cp2id.get(c)).filter(v=>Number.isFinite(v));
          for(const m of merges){const{a,b,id}=m; const out=[]; for(let i=0;i<tokens.length;){if(i<tokens.length-1&&tokens[i]===a&&tokens[i+1]===b){out.push(id);i+=2}else{out.push(tokens[i]);i++}} tokens=out}
          if(addBos)tokens=[BOS_ID,...tokens]; if(addEos)tokens=[...tokens,EOS_ID]; return tokens;
        },
        decodeAtomsToText:function(tokens){
          const id2pair=new Map(this.merges.map(m=>[m.id,[m.a,m.b]])); const id2cp=this.id2cp;
          function expand(id){if(id===BOS_ID||id===EOS_ID)return[]; if(id2cp.has(id))return[id2cp.get(id)]; const pr=id2pair.get(id); if(!pr)return[]; return expand(pr[0]).concat(expand(pr[1]))}
          const cpsOut=[]; for(const t of tokens){if(t===BOS_ID||t===EOS_ID)continue; if(id2cp.has(t))cpsOut.push(id2cp.get(t)); else cpsOut.push(...expand(t))}
          return codepointsToStr(cpsOut);
        }
      };
      $('prompt').disabled=false; $('btnGen').disabled=false; $('btnExport').disabled=false;
      logLine('Import abgeschlossen. Tokenizer & Modell bereit.');
      dbgState('after-import');
    }catch(e){logLine('Import-Fehler: '+(e?.message||e));console.error(e)}
  };
  reader.readAsText(file);
}

/* ---------- UI ---------- */
window.addEventListener('load', async ()=>{
  await setupBackend(valBool('useGPU',true));
  const fileInput=$('corpusFiles'); const fileInfo=$('fileInfo');

  fileInput.addEventListener('change', async (event)=>{
    const files=event.target.files;
    if(!files||files.length===0){fileInfo.textContent='Keine Korpus-Dateien ausgewählt.';STATE.corpusText='';return}
    fileInfo.textContent=`Lese ${files.length} Datei(en)…`;
    let combinedText=''; const jsonlKey=$('jsonlKey').value.trim()||'text';
    try{
      for(const file of files){
        logLine(`Lese Datei: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)`);
        const content=await file.text();
        if(file.name.endsWith('.jsonl')){
          const lines=content.split('\n'); let added=0;
          for(const line of lines){if(line.trim()==='')continue; try{const obj=JSON.parse(line); if(typeof obj[jsonlKey]==='string'){combinedText+=obj[jsonlKey]+"\n"; added++}}catch(_){}} 
          logLine(`… ${added} Einträge aus .jsonl extrahiert.`);
        }else{combinedText += content + "\n"}
        await microYield();
      }
      STATE.corpusText=combinedText; $('txt').value='';
      fileInfo.textContent=`${files.length} Datei(en) geladen (${(STATE.corpusText.length/1024/1024).toFixed(2)} MB Text).`;
      $('kpiChars').textContent=`Textzeichen: ${STATE.corpusText.length.toLocaleString()}`;
    }catch(err){logLine(`Fehler beim Laden: ${err}`); fileInfo.textContent=`Fehler: ${err}`; STATE.corpusText=''}
  });

  $('btnBuildBPE').addEventListener('click', async ()=>{
    const textToProcess=STATE.corpusText||($('txt')?.value??'').trim();
    if(!textToProcess){logLine('Kein Text zum Verarbeiten.');return}
    const atomVocab=valNum('atomVocab',512);
    const T=valNum('seqLen',64);
    setButtonState('btnBuildBPE',true,'Lerne Atome…',false);
    try{
      const atomizer=await buildAtomBPE(textToProcess, atomVocab);
      const atomIds=atomizer.encodeTextToAtoms(textToProcess,true,true);
      STATE.atomizer=atomizer;
      logLine("Erstelle Uint32Array für Token …");
      STATE.tokens=new Uint32Array(atomIds);
      logLine("… Token-Array erstellt.");
      const atomCount=STATE.tokens.length;
      $('kpiAtoms').textContent=`Atome: ${atomCount.toLocaleString()} (Vocab: ${STATE.atomizer.vocabSize})`;
      const roughComp=(textToProcess.length>0)?(textToProcess.length/atomCount).toFixed(2):'–';
      $('kpiComp').textContent=`Kompression: ${roughComp}×`;
      dbgState('after-bpe');
      $('btnTrain').disabled = (STATE.tokens.length>=(T+1))? false : true;
    }catch(e){logLine(`Fehler beim BPE-Training: ${e.message}`)}
    finally{setButtonState('btnBuildBPE',false,'1. Atome lernen (BPE auf Text)',false)}
  });

  $('prompt').addEventListener('keydown',(e)=>{if(e.key==='Enter'&&!e.shiftKey){e.preventDefault(); if(!$('btnGen').disabled)generate()}});
  $('btnTrain').addEventListener('click',train);
  $('btnGen').addEventListener('click',generate);
  $('btnStop').addEventListener('click',()=>{STATE.cancelTrain=true; $('btnStop').disabled=true; logLine('Training gestoppt (Step-/Epochenende).')} );
  $('btnStopGen').addEventListener('click',()=>{STATE.cancelGen=true; $('btnStopGen').disabled=true});
  $('btnDbgDump').addEventListener('click',()=>{
    dbgState('manual');
    if(STATE.tokens instanceof Uint32Array){
      const T=valNum('seqLen',64);
      const starts=buildStarts(STATE.tokens,T,10);
      logLine(`[DBG] seqLen=${T} tokens=${STATE.tokens.length} starts.train=${starts.train.length} starts.val=${starts.val.length}`);
      if(STATE.atomizer)logLine(`[DBG] merges=${STATE.atomizer.merges.length} exampleMerge=${JSON.stringify(STATE.atomizer.merges[0]||null)}`);
    }
  });
  $('btnClear').addEventListener('click',()=>{
    STATE.corpusText=''; STATE.atomizer=null; STATE.tokens=null;
    if(STATE.model){STATE.model.dispose(); STATE.model=null}
    $('kpiChars').textContent='Textzeichen: –'; $('kpiAtoms').textContent='Atome: –'; $('kpiComp').textContent='Kompression: –';
    $('outText').textContent=''; $('txt').value=''; $('fileInfo').textContent='Keine Korpus-Dateien ausgewählt.'; $('corpusFiles').value=null;
    $('btnTrain').disabled=true; $('btnExport').disabled=true; $('prompt').disabled=true; $('btnGen').disabled=true;
    logLine('Zustand zurückgesetzt.');
  });
  $('btnExport').addEventListener('click',exportModel);
  $('fileImport').addEventListener('change',(e)=>{if(e.target.files?.[0])importModel(e.target.files[0]); e.target.value=null});
  $('sampleMode').addEventListener('change',()=>{const m=$('sampleMode').value; $('topK').disabled=(m!=='topk'); $('topP').disabled=(m!=='topp')});
});
</script>
</body>
</html>
